{"version":3,"sources":["out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/fake","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/map.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/mime.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stream.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/stringBuilder.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/textChange.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/contextkey/common/scanner.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/instantiation/common/instantiation.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/contextkey/common/contextkey.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/contrib/notebook/common/notebookCommon.ts","out-vscode-reh-web/vs/workbench/contrib/notebook/common/services/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/contrib/notebook/common/services/notebookSimpleWorker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { extname } from 'vs/base/common/path';\n\nexport const Mimes = Object.freeze({\n\ttext: 'text/plain',\n\tbinary: 'application/octet-stream',\n\tunknown: 'application/unknown',\n\tmarkdown: 'text/markdown',\n\tlatex: 'text/latex',\n\turiList: 'text/uri-list',\n});\n\ninterface MapExtToMediaMimes {\n\t[index: string]: string;\n}\n\nconst mapExtToTextMimes: MapExtToMediaMimes = {\n\t'.css': 'text/css',\n\t'.csv': 'text/csv',\n\t'.htm': 'text/html',\n\t'.html': 'text/html',\n\t'.ics': 'text/calendar',\n\t'.js': 'text/javascript',\n\t'.mjs': 'text/javascript',\n\t'.txt': 'text/plain',\n\t'.xml': 'text/xml'\n};\n\n// Known media mimes that we can handle\nconst mapExtToMediaMimes: MapExtToMediaMimes = {\n\t'.aac': 'audio/x-aac',\n\t'.avi': 'video/x-msvideo',\n\t'.bmp': 'image/bmp',\n\t'.flv': 'video/x-flv',\n\t'.gif': 'image/gif',\n\t'.ico': 'image/x-icon',\n\t'.jpe': 'image/jpg',\n\t'.jpeg': 'image/jpg',\n\t'.jpg': 'image/jpg',\n\t'.m1v': 'video/mpeg',\n\t'.m2a': 'audio/mpeg',\n\t'.m2v': 'video/mpeg',\n\t'.m3a': 'audio/mpeg',\n\t'.mid': 'audio/midi',\n\t'.midi': 'audio/midi',\n\t'.mk3d': 'video/x-matroska',\n\t'.mks': 'video/x-matroska',\n\t'.mkv': 'video/x-matroska',\n\t'.mov': 'video/quicktime',\n\t'.movie': 'video/x-sgi-movie',\n\t'.mp2': 'audio/mpeg',\n\t'.mp2a': 'audio/mpeg',\n\t'.mp3': 'audio/mpeg',\n\t'.mp4': 'video/mp4',\n\t'.mp4a': 'audio/mp4',\n\t'.mp4v': 'video/mp4',\n\t'.mpe': 'video/mpeg',\n\t'.mpeg': 'video/mpeg',\n\t'.mpg': 'video/mpeg',\n\t'.mpg4': 'video/mp4',\n\t'.mpga': 'audio/mpeg',\n\t'.oga': 'audio/ogg',\n\t'.ogg': 'audio/ogg',\n\t'.opus': 'audio/opus',\n\t'.ogv': 'video/ogg',\n\t'.png': 'image/png',\n\t'.psd': 'image/vnd.adobe.photoshop',\n\t'.qt': 'video/quicktime',\n\t'.spx': 'audio/ogg',\n\t'.svg': 'image/svg+xml',\n\t'.tga': 'image/x-tga',\n\t'.tif': 'image/tiff',\n\t'.tiff': 'image/tiff',\n\t'.wav': 'audio/x-wav',\n\t'.webm': 'video/webm',\n\t'.webp': 'image/webp',\n\t'.wma': 'audio/x-ms-wma',\n\t'.wmv': 'video/x-ms-wmv',\n\t'.woff': 'application/font-woff',\n};\n\nexport function getMediaOrTextMime(path: string): string | undefined {\n\tconst ext = extname(path);\n\tconst textMime = mapExtToTextMimes[ext.toLowerCase()];\n\tif (textMime !== undefined) {\n\t\treturn textMime;\n\t} else {\n\t\treturn getMediaMime(path);\n\t}\n}\n\nexport function getMediaMime(path: string): string | undefined {\n\tconst ext = extname(path);\n\treturn mapExtToMediaMimes[ext.toLowerCase()];\n}\n\nexport function getExtensionForMimeType(mimeType: string): string | undefined {\n\tfor (const extension in mapExtToMediaMimes) {\n\t\tif (mapExtToMediaMimes[extension] === mimeType) {\n\t\t\treturn extension;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nconst _simplePattern = /^(.+)\\/(.+?)(;.+)?$/;\n\nexport function normalizeMimeType(mimeType: string): string;\nexport function normalizeMimeType(mimeType: string, strict: true): string | undefined;\nexport function normalizeMimeType(mimeType: string, strict?: true): string | undefined {\n\n\tconst match = _simplePattern.exec(mimeType);\n\tif (!match) {\n\t\treturn strict\n\t\t\t? undefined\n\t\t\t: mimeType;\n\t}\n\t// https://datatracker.ietf.org/doc/html/rfc2045#section-5.1\n\t// media and subtype must ALWAYS be lowercase, parameter not\n\treturn `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable {\n\tlet destroyed = false;\n\n\tstream.on('error', error => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n\n\treturn toDisposable(() => destroyed = true);\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from 'vs/base/common/lazy';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array) {\n\t\tconst needle = subarray instanceof VSBuffer ? subarray.buffer : subarray;\n\t\tconst needleLen = needle.byteLength;\n\t\tconst haystack = this.buffer;\n\t\tconst haystackLen = haystack.byteLength;\n\n\t\tif (needleLen === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (needleLen === 1) {\n\t\t\treturn haystack.indexOf(needle[0]);\n\t\t}\n\n\t\tif (needleLen > haystackLen) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// find index of the subarray using boyer-moore-horspool algorithm\n\t\tconst table = indexOfTable.value;\n\t\ttable.fill(needle.length);\n\t\tfor (let i = 0; i < needle.length; i++) {\n\t\t\ttable[needle[i]] = needle.length - i - 1;\n\t\t}\n\n\t\tlet i = needle.length - 1;\n\t\tlet j = i;\n\t\tlet result = -1;\n\t\twhile (i < haystackLen) {\n\t\t\tif (haystack[i] === needle[j]) {\n\t\t\t\tif (j === 0) {\n\t\t\t\t\tresult = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\t\tj = needle.length - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new Error('Throttler is disposed');\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface INextTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithNextTask {\n\treadonly next: INextTask;\n}\n\nexport class TaskSequentializer {\n\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: INextTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending?.promise;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n\n\thasNext(): this is ITaskSequentializerWithNextTask {\n\t\treturn !!this._next;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._next?.promise ?? this._pending?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters, ltrim } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\nimport * as platform from 'vs/base/common/platform';\nimport * as buffer from 'vs/base/common/buffer';\n\nlet _utf16LE_TextDecoder: TextDecoder | null;\nfunction getUTF16LE_TextDecoder(): TextDecoder {\n\tif (!_utf16LE_TextDecoder) {\n\t\t_utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n\t}\n\treturn _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder: TextDecoder | null;\nfunction getUTF16BE_TextDecoder(): TextDecoder {\n\tif (!_utf16BE_TextDecoder) {\n\t\t_utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n\t}\n\treturn _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder: TextDecoder | null;\nexport function getPlatformTextDecoder(): TextDecoder {\n\tif (!_platformTextDecoder) {\n\t\t_platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n\t}\n\treturn _platformTextDecoder;\n}\n\nexport function decodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst view = new Uint16Array(source.buffer, offset, len);\n\tif (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n\t\t// UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n\t\t// It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n\t\t// We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n\t\t// So we use the manual decoder\n\t\treturn compatDecodeUTF16LE(source, offset, len);\n\t}\n\treturn getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst result: string[] = [];\n\tlet resultLen = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst charCode = buffer.readUInt16LE(source, offset); offset += 2;\n\t\tresult[resultLen++] = String.fromCharCode(charCode);\n\t}\n\treturn result.join('');\n}\n\nexport class StringBuilder {\n\n\tprivate readonly _capacity: number;\n\tprivate readonly _buffer: Uint16Array;\n\n\tprivate _completedStrings: string[] | null;\n\tprivate _bufferLength: number;\n\n\tconstructor(capacity: number) {\n\t\tthis._capacity = capacity | 0;\n\t\tthis._buffer = new Uint16Array(this._capacity);\n\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic build(): string {\n\t\tif (this._completedStrings !== null) {\n\t\t\tthis._flushBuffer();\n\t\t\treturn this._completedStrings.join('');\n\t\t}\n\t\treturn this._buildBuffer();\n\t}\n\n\tprivate _buildBuffer(): string {\n\t\tif (this._bufferLength === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n\t\treturn getPlatformTextDecoder().decode(view);\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tconst bufferString = this._buildBuffer();\n\t\tthis._bufferLength = 0;\n\n\t\tif (this._completedStrings === null) {\n\t\t\tthis._completedStrings = [bufferString];\n\t\t} else {\n\t\t\tthis._completedStrings[this._completedStrings.length] = bufferString;\n\t\t}\n\t}\n\n\t/**\n\t * Append a char code (<2^16)\n\t */\n\tpublic appendCharCode(charCode: number): void {\n\t\tconst remainingSpace = this._capacity - this._bufferLength;\n\n\t\tif (remainingSpace <= 1) {\n\t\t\tif (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n\t\t\t\tthis._flushBuffer();\n\t\t\t}\n\t\t}\n\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\t/**\n\t * Append an ASCII char code (<2^8)\n\t */\n\tpublic appendASCIICharCode(charCode: number): void {\n\t\tif (this._bufferLength === this._capacity) {\n\t\t\t// buffer is full\n\t\t\tthis._flushBuffer();\n\t\t}\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendString(str: string): void {\n\t\tconst strLen = str.length;\n\n\t\tif (this._bufferLength + strLen >= this._capacity) {\n\t\t\t// This string does not fit in the remaining buffer space\n\n\t\t\tthis._flushBuffer();\n\t\t\tthis._completedStrings![this._completedStrings!.length] = str;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < strLen; i++) {\n\t\t\tthis._buffer[this._bufferLength++] = str.charCodeAt(i);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as buffer from 'vs/base/common/buffer';\nimport { decodeUTF16LE } from 'vs/editor/common/core/stringBuilder';\n\nfunction escapeNewLine(str: string): string {\n\treturn (\n\t\tstr\n\t\t\t.replace(/\\n/g, '\\\\n')\n\t\t\t.replace(/\\r/g, '\\\\r')\n\t);\n}\n\nexport class TextChange {\n\n\tpublic get oldLength(): number {\n\t\treturn this.oldText.length;\n\t}\n\n\tpublic get oldEnd(): number {\n\t\treturn this.oldPosition + this.oldText.length;\n\t}\n\n\tpublic get newLength(): number {\n\t\treturn this.newText.length;\n\t}\n\n\tpublic get newEnd(): number {\n\t\treturn this.newPosition + this.newText.length;\n\t}\n\n\tconstructor(\n\t\tpublic readonly oldPosition: number,\n\t\tpublic readonly oldText: string,\n\t\tpublic readonly newPosition: number,\n\t\tpublic readonly newText: string\n\t) { }\n\n\tpublic toString(): string {\n\t\tif (this.oldText.length === 0) {\n\t\t\treturn `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n\t\t}\n\t\tif (this.newText.length === 0) {\n\t\t\treturn `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n\t\t}\n\t\treturn `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n\t}\n\n\tprivate static _writeStringSize(str: string): number {\n\t\treturn (\n\t\t\t4 + 2 * str.length\n\t\t);\n\t}\n\n\tprivate static _writeString(b: Uint8Array, str: string, offset: number): number {\n\t\tconst len = str.length;\n\t\tbuffer.writeUInt32BE(b, len, offset); offset += 4;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tbuffer.writeUInt16LE(b, str.charCodeAt(i), offset); offset += 2;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tprivate static _readString(b: Uint8Array, offset: number): string {\n\t\tconst len = buffer.readUInt32BE(b, offset); offset += 4;\n\t\treturn decodeUTF16LE(b, offset, len);\n\t}\n\n\tpublic writeSize(): number {\n\t\treturn (\n\t\t\t+ 4 // oldPosition\n\t\t\t+ 4 // newPosition\n\t\t\t+ TextChange._writeStringSize(this.oldText)\n\t\t\t+ TextChange._writeStringSize(this.newText)\n\t\t);\n\t}\n\n\tpublic write(b: Uint8Array, offset: number): number {\n\t\tbuffer.writeUInt32BE(b, this.oldPosition, offset); offset += 4;\n\t\tbuffer.writeUInt32BE(b, this.newPosition, offset); offset += 4;\n\t\toffset = TextChange._writeString(b, this.oldText, offset);\n\t\toffset = TextChange._writeString(b, this.newText, offset);\n\t\treturn offset;\n\t}\n\n\tpublic static read(b: Uint8Array, offset: number, dest: TextChange[]): number {\n\t\tconst oldPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst newPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst oldText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(oldText);\n\t\tconst newText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(newText);\n\t\tdest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n\t\treturn offset;\n\t}\n}\n\nexport function compressConsecutiveTextChanges(prevEdits: TextChange[] | null, currEdits: TextChange[]): TextChange[] {\n\tif (prevEdits === null || prevEdits.length === 0) {\n\t\treturn currEdits;\n\t}\n\tconst compressor = new TextChangeCompressor(prevEdits, currEdits);\n\treturn compressor.compress();\n}\n\nclass TextChangeCompressor {\n\n\tprivate _prevEdits: TextChange[];\n\tprivate _currEdits: TextChange[];\n\n\tprivate _result: TextChange[];\n\tprivate _resultLen: number;\n\n\tprivate _prevLen: number;\n\tprivate _prevDeltaOffset: number;\n\n\tprivate _currLen: number;\n\tprivate _currDeltaOffset: number;\n\n\tconstructor(prevEdits: TextChange[], currEdits: TextChange[]) {\n\t\tthis._prevEdits = prevEdits;\n\t\tthis._currEdits = currEdits;\n\n\t\tthis._result = [];\n\t\tthis._resultLen = 0;\n\n\t\tthis._prevLen = this._prevEdits.length;\n\t\tthis._prevDeltaOffset = 0;\n\n\t\tthis._currLen = this._currEdits.length;\n\t\tthis._currDeltaOffset = 0;\n\t}\n\n\tpublic compress(): TextChange[] {\n\t\tlet prevIndex = 0;\n\t\tlet currIndex = 0;\n\n\t\tlet prevEdit = this._getPrev(prevIndex);\n\t\tlet currEdit = this._getCurr(currIndex);\n\n\t\twhile (prevIndex < this._prevLen || currIndex < this._currLen) {\n\n\t\t\tif (prevEdit === null) {\n\t\t\t\tthis._acceptCurr(currEdit!);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit === null) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldEnd <= prevEdit.newPosition) {\n\t\t\t\tthis._acceptCurr(currEdit);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newEnd <= currEdit.oldPosition) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldPosition < prevEdit.newPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n\t\t\t\tthis._acceptCurr(e1);\n\t\t\t\tcurrEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newPosition < currEdit.oldPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n\t\t\t\tthis._acceptPrev(e1);\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point, currEdit.oldPosition === prevEdit.newPosition\n\n\t\t\tlet mergePrev: TextChange;\n\t\t\tlet mergeCurr: TextChange;\n\n\t\t\tif (currEdit.oldEnd === prevEdit.newEnd) {\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else if (currEdit.oldEnd < prevEdit.newEnd) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n\t\t\t\tmergePrev = e1;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = e1;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = e2;\n\t\t\t}\n\n\t\t\tthis._result[this._resultLen++] = new TextChange(\n\t\t\t\tmergePrev.oldPosition,\n\t\t\t\tmergePrev.oldText,\n\t\t\t\tmergeCurr.newPosition,\n\t\t\t\tmergeCurr.newText\n\t\t\t);\n\t\t\tthis._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n\t\t\tthis._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n\t\t}\n\n\t\tconst merged = TextChangeCompressor._merge(this._result);\n\t\tconst cleaned = TextChangeCompressor._removeNoOps(merged);\n\t\treturn cleaned;\n\t}\n\n\tprivate _acceptCurr(currEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n\t\tthis._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n\t}\n\n\tprivate _getCurr(currIndex: number): TextChange | null {\n\t\treturn (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n\t}\n\n\tprivate _acceptPrev(prevEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n\t\tthis._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n\t}\n\n\tprivate _getPrev(prevIndex: number): TextChange | null {\n\t\treturn (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n\t}\n\n\tprivate static _rebaseCurr(prevDeltaOffset: number, currEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tcurrEdit.oldPosition - prevDeltaOffset,\n\t\t\tcurrEdit.oldText,\n\t\t\tcurrEdit.newPosition,\n\t\t\tcurrEdit.newText\n\t\t);\n\t}\n\n\tprivate static _rebasePrev(currDeltaOffset: number, prevEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tprevEdit.oldPosition,\n\t\t\tprevEdit.oldText,\n\t\t\tprevEdit.newPosition + currDeltaOffset,\n\t\t\tprevEdit.newText\n\t\t);\n\t}\n\n\tprivate static _splitPrev(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.newText.substr(0, offset);\n\t\tconst postText = edit.newText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tedit.oldText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tpreText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldEnd,\n\t\t\t\t'',\n\t\t\t\tedit.newPosition + offset,\n\t\t\t\tpostText\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _splitCurr(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.oldText.substr(0, offset);\n\t\tconst postText = edit.oldText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tpreText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tedit.newText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition + offset,\n\t\t\t\tpostText,\n\t\t\t\tedit.newEnd,\n\t\t\t\t''\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _merge(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tlet prev = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst curr = edits[i];\n\n\t\t\tif (prev.oldEnd === curr.oldPosition) {\n\t\t\t\t// Merge into `prev`\n\t\t\t\tprev = new TextChange(\n\t\t\t\t\tprev.oldPosition,\n\t\t\t\t\tprev.oldText + curr.oldText,\n\t\t\t\t\tprev.newPosition,\n\t\t\t\t\tprev.newText + curr.newText\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = prev;\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\tresult[resultLen++] = prev;\n\n\t\treturn result;\n\t}\n\n\tprivate static _removeNoOps(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\n\t\t\tif (edit.oldText === edit.newText) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[resultLen++] = edit;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Piece, PieceTreeBase } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\n\nexport class TreeNode {\n\tparent: TreeNode;\n\tleft: TreeNode;\n\tright: TreeNode;\n\tcolor: NodeColor;\n\n\t// Piece\n\tpiece: Piece;\n\tsize_left: number; // size of the left subtree (not inorder)\n\tlf_left: number; // line feeds cnt in the left subtree (not in order)\n\n\tconstructor(piece: Piece, color: NodeColor) {\n\t\tthis.piece = piece;\n\t\tthis.color = color;\n\t\tthis.size_left = 0;\n\t\tthis.lf_left = 0;\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t}\n\n\tpublic next(): TreeNode {\n\t\tif (this.right !== SENTINEL) {\n\t\t\treturn leftest(this.right);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.left === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic prev(): TreeNode {\n\t\tif (this.left !== SENTINEL) {\n\t\t\treturn righttest(this.left);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nexport const SENTINEL: TreeNode = new TreeNode(null!, NodeColor.Black);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = NodeColor.Black;\n\nexport function leftest(node: TreeNode): TreeNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nexport function righttest(node: TreeNode): TreeNode {\n\twhile (node.right !== SENTINEL) {\n\t\tnode = node.right;\n\t}\n\treturn node;\n}\n\nfunction calculateSize(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.size_left + node.piece.length + calculateSize(node.right);\n}\n\nfunction calculateLF(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n}\n\nexport function leftRotate(tree: PieceTreeBase, x: TreeNode) {\n\tconst y = x.right;\n\n\t// fix size_left\n\ty.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\tx.right = y.left;\n\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\n\tif (x.parent === SENTINEL) {\n\t\ttree.root = y;\n\t} else if (x.parent.left === x) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\ty.left = x;\n\tx.parent = y;\n}\n\nexport function rightRotate(tree: PieceTreeBase, y: TreeNode) {\n\tconst x = y.left;\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\n\t// fix size_left\n\ty.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n\tif (y.parent === SENTINEL) {\n\t\ttree.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n}\n\nexport function rbDelete(tree: PieceTreeBase, z: TreeNode) {\n\tlet x: TreeNode;\n\tlet y: TreeNode;\n\n\tif (z.left === SENTINEL) {\n\t\ty = z;\n\t\tx = y.right;\n\t} else if (z.right === SENTINEL) {\n\t\ty = z;\n\t\tx = y.left;\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\t}\n\n\tif (y === tree.root) {\n\t\ttree.root = x;\n\n\t\t// if x is null, we are removing the only node\n\t\tx.color = NodeColor.Black;\n\t\tz.detach();\n\t\tresetSentinel();\n\t\ttree.root.parent = SENTINEL;\n\n\t\treturn;\n\t}\n\n\tconst yWasRed = (y.color === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t\trecomputeTreeMetadata(tree, x);\n\t} else {\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\t// as we make changes to x's hierarchy, update size_left of subtree first\n\t\trecomputeTreeMetadata(tree, x);\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\ty.color = z.color;\n\n\t\tif (z === tree.root) {\n\t\t\ttree.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t\t// update metadata\n\t\t// we replace z with y, so in this sub tree, the length change is z.item.length\n\t\ty.size_left = z.size_left;\n\t\ty.lf_left = z.lf_left;\n\t\trecomputeTreeMetadata(tree, y);\n\t}\n\n\tz.detach();\n\n\tif (x.parent.left === x) {\n\t\tconst newSizeLeft = calculateSize(x);\n\t\tconst newLFLeft = calculateLF(x);\n\t\tif (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n\t\t\tconst delta = newSizeLeft - x.parent.size_left;\n\t\t\tconst lf_delta = newLFLeft - x.parent.lf_left;\n\t\t\tx.parent.size_left = newSizeLeft;\n\t\t\tx.parent.lf_left = newLFLeft;\n\t\t\tupdateTreeMetadata(tree, x.parent, delta, lf_delta);\n\t\t}\n\t}\n\n\trecomputeTreeMetadata(tree, x.parent);\n\n\tif (yWasRed) {\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: TreeNode;\n\twhile (x !== tree.root && x.color === NodeColor.Black) {\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (w.right.color === NodeColor.Black) {\n\t\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\trightRotate(tree, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (w.left.color === NodeColor.Black) {\n\t\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\tleftRotate(tree, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t}\n\t}\n\tx.color = NodeColor.Black;\n\tresetSentinel();\n}\n\nexport function fixInsert(tree: PieceTreeBase, x: TreeNode) {\n\trecomputeTreeMetadata(tree, x);\n\n\twhile (x !== tree.root && x.parent.color === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(tree, x);\n\t\t\t\t}\n\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(tree, x);\n\t\t\t\t}\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\ttree.root.color = NodeColor.Black;\n}\n\nexport function updateTreeMetadata(tree: PieceTreeBase, x: TreeNode, delta: number, lineFeedCntDelta: number): void {\n\t// node length change or line feed count change\n\twhile (x !== tree.root && x !== SENTINEL) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lineFeedCntDelta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n\nexport function recomputeTreeMetadata(tree: PieceTreeBase, x: TreeNode) {\n\tlet delta = 0;\n\tlet lf_delta = 0;\n\tif (x === tree.root) {\n\t\treturn;\n\t}\n\n\t// go upwards till the node whose left subtree is changed.\n\twhile (x !== tree.root && x === x.parent.right) {\n\t\tx = x.parent;\n\t}\n\n\tif (x === tree.root) {\n\t\t// well, it means we add a node to the end (inorder)\n\t\treturn;\n\t}\n\n\t// x is the node whose right subtree is changed.\n\tx = x.parent;\n\n\tdelta = calculateSize(x.left) - x.size_left;\n\tlf_delta = calculateLF(x.left) - x.lf_left;\n\tx.size_left += delta;\n\tx.lf_left += lf_delta;\n\n\n\t// go upwards till root. O(logN)\n\twhile (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lf_delta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { FindMatch, ITextSnapshot, SearchData } from 'vs/editor/common/model';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from 'vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase';\nimport { Searcher, createFindMatch, isValidMatch } from 'vs/editor/common/model/textModelSearch';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\n\nfunction createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nclass LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\ninterface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainder in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\ninterface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: '\\r\\n' | '\\n';\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic equal(other: PieceTreeBase): boolean {\n\t\tif (this.getLength() !== other.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getLineCount() !== other.getLineCount()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet offset = 0;\n\t\tconst ret = this.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tconst startPosition = other.nodeAt(offset);\n\t\t\tconst endPosition = other.nodeAt(offset + len);\n\t\t\tconst val = other.getValueInRange2(startPosition, endPosition);\n\n\t\t\toffset += len;\n\t\t\treturn str === val;\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = '';\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = '';\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === CharCode.CarriageReturn) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += (\n\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n\t\t\t\t\t: buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t);\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = (\n\t\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t\t? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n\t\t\t\t\t\t: buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t\t);\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === CharCode.CarriageReturn) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = '';\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tconst retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\tconst end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tconst nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLinesRawContent(): string {\n\t\treturn this.getContentOfSubTree(this.root);\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(node: TreeNode, accumulatedValue: number): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\tprivate getContentOfSubTree(node: TreeNode): string {\n\t\tlet str = '';\n\n\t\tthis.iterate(node, node => {\n\t\t\tstr += this.getNodeContent(node);\n\t\t\treturn true;\n\t\t});\n\n\t\treturn str;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport * as strings from 'vs/base/common/strings';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from 'vs/editor/common/model';\nimport { PieceTreeBase, StringBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { countEOL, StringEOL } from 'vs/editor/common/core/eolCounter';\nimport { TextChange } from 'vs/editor/common/core/textChange';\nimport { Disposable } from 'vs/base/common/lifecycle';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeContent: Event<void> = this._onDidChangeContent.event;\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\n\t// #region TextBuffer\n\tpublic equals(other: ITextBuffer): boolean {\n\t\tif (!(other instanceof PieceTreeTextBuffer)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._BOM !== other._BOM) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getEOL() !== other.getEOL()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._pieceTree.equal(other._pieceTree);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getCharCode(offset: number): number {\n\t\treturn this._pieceTree.getCharCode(offset);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\treturn this.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t// #endregion\n\n\t// #region helper\n\t// testing purpose.\n\tpublic getPieceTree(): PieceTreeBase {\n\t\treturn this._pieceTree;\n\t}\n\n\tpublic static _getInverseEditRange(range: Range, text: string) {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\t\tlet resultRange: Range;\n\n\t\tif (text.length > 0) {\n\t\t\t// the operation inserts something\n\t\t\tconst lineCount = eolCount + 1;\n\n\t\t\tif (lineCount === 1) {\n\t\t\t\t// single line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);\n\t\t\t} else {\n\t\t\t\t// multi line insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// There is nothing to insert\n\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t}\n\n\t\treturn resultRange;\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport * as strings from 'vs/base/common/strings';\nimport { DefaultEndOfLine, ITextBuffer, ITextBufferBuilder, ITextBufferFactory } from 'vs/editor/common/model';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase';\nimport { PieceTreeTextBuffer } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer';\n\nclass PieceTreeTextBufferFactory implements ITextBufferFactory {\n\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _containsUnusualLineTerminators: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean\n\t) { }\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): '\\r\\n' | '\\n' {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn (defaultEOL === DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn '\\r\\n';\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn '\\n';\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable } {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tconst chunks = this._chunks;\n\n\t\tif (this._normalizeEOL &&\n\t\t\t((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n\t\t\t\t|| (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tconst str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tconst newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\tconst textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n\t\treturn { textBuffer: textBuffer, disposable: textBuffer };\n\t}\n\n\tpublic getFirstLineText(lengthLimit: number): string {\n\t\treturn this._chunks[0].buffer.substr(0, lengthLimit).split(/\\r\\n|\\r|\\n/)[0];\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate containsUnusualLineTerminators: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = '';\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.containsUnusualLineTerminators = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (!lineStarts.isBasicASCII) {\n\t\t\t// this chunk contains non basic ASCII characters\n\t\t\tthis.isBasicASCII = false;\n\t\t\tif (!this.containsRTL) {\n\t\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t\t}\n\t\t\tif (!this.containsUnusualLineTerminators) {\n\t\t\t\tthis.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL: boolean = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.containsUnusualLineTerminators,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1('', true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tconst lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tconst newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { illegalState } from 'vs/base/common/errors';\nimport { localize } from 'vs/nls';\n\nexport const enum TokenType {\n\tLParen,\n\tRParen,\n\tNeg,\n\tEq,\n\tNotEq,\n\tLt,\n\tLtEq,\n\tGt,\n\tGtEq,\n\tRegexOp,\n\tRegexStr,\n\tTrue,\n\tFalse,\n\tIn,\n\tNot,\n\tAnd,\n\tOr,\n\tStr,\n\tQuotedStr,\n\tError,\n\tEOF,\n}\n\nexport type Token =\n\t| { type: TokenType.LParen; offset: number }\n\t| { type: TokenType.RParen; offset: number }\n\t| { type: TokenType.Neg; offset: number }\n\t| { type: TokenType.Eq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.NotEq; offset: number; isTripleEq: boolean }\n\t| { type: TokenType.Lt; offset: number }\n\t| { type: TokenType.LtEq; offset: number }\n\t| { type: TokenType.Gt; offset: number }\n\t| { type: TokenType.GtEq; offset: number }\n\t| { type: TokenType.RegexOp; offset: number }\n\t| { type: TokenType.RegexStr; offset: number; lexeme: string }\n\t| { type: TokenType.True; offset: number }\n\t| { type: TokenType.False; offset: number }\n\t| { type: TokenType.In; offset: number }\n\t| { type: TokenType.Not; offset: number }\n\t| { type: TokenType.And; offset: number }\n\t| { type: TokenType.Or; offset: number }\n\t| { type: TokenType.Str; offset: number; lexeme: string }\n\t| { type: TokenType.QuotedStr; offset: number; lexeme: string }\n\t| { type: TokenType.Error; offset: number; lexeme: string }\n\t| { type: TokenType.EOF; offset: number };\n\ntype KeywordTokenType = TokenType.Not | TokenType.In | TokenType.False | TokenType.True;\ntype TokenTypeWithoutLexeme =\n\tTokenType.LParen |\n\tTokenType.RParen |\n\tTokenType.Neg |\n\tTokenType.Lt |\n\tTokenType.LtEq |\n\tTokenType.Gt |\n\tTokenType.GtEq |\n\tTokenType.RegexOp |\n\tTokenType.True |\n\tTokenType.False |\n\tTokenType.In |\n\tTokenType.Not |\n\tTokenType.And |\n\tTokenType.Or |\n\tTokenType.EOF;\n\n/**\n * Example:\n * `foo == bar'` - note how single quote doesn't have a corresponding closing quote,\n * so it's reported as unexpected\n */\nexport type LexingError = {\n\toffset: number; /** note that this doesn't take into account escape characters from the original encoding of the string, e.g., within an extension manifest file's JSON encoding  */\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nfunction hintDidYouMean(...meant: string[]) {\n\tswitch (meant.length) {\n\t\tcase 1:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean1', \"Did you mean {0}?\", meant[0]);\n\t\tcase 2:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean2', \"Did you mean {0} or {1}?\", meant[0], meant[1]);\n\t\tcase 3:\n\t\t\treturn localize('contextkey.scanner.hint.didYouMean3', \"Did you mean {0}, {1} or {2}?\", meant[0], meant[1], meant[2]);\n\t\tdefault: // we just don't expect that many\n\t\t\treturn undefined;\n\t}\n}\n\nconst hintDidYouForgetToOpenOrCloseQuote = localize('contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote', \"Did you forget to open or close the quote?\");\nconst hintDidYouForgetToEscapeSlash = localize('contextkey.scanner.hint.didYouForgetToEscapeSlash', \"Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\\\\\/\\'.\");\n\n/**\n * A simple scanner for context keys.\n *\n * Example:\n *\n * ```ts\n * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');\n * const tokens = [...scanner];\n * if (scanner.errorTokens.length > 0) {\n *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\\nHint: ${err.additional}`));\n * } else {\n *     // process tokens\n * }\n * ```\n */\nexport class Scanner {\n\n\tstatic getLexeme(token: Token): string {\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.LParen:\n\t\t\t\treturn '(';\n\t\t\tcase TokenType.RParen:\n\t\t\t\treturn ')';\n\t\t\tcase TokenType.Neg:\n\t\t\t\treturn '!';\n\t\t\tcase TokenType.Eq:\n\t\t\t\treturn token.isTripleEq ? '===' : '==';\n\t\t\tcase TokenType.NotEq:\n\t\t\t\treturn token.isTripleEq ? '!==' : '!=';\n\t\t\tcase TokenType.Lt:\n\t\t\t\treturn '<';\n\t\t\tcase TokenType.LtEq:\n\t\t\t\treturn '<=';\n\t\t\tcase TokenType.Gt:\n\t\t\t\treturn '>=';\n\t\t\tcase TokenType.GtEq:\n\t\t\t\treturn '>=';\n\t\t\tcase TokenType.RegexOp:\n\t\t\t\treturn '=~';\n\t\t\tcase TokenType.RegexStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\treturn 'true';\n\t\t\tcase TokenType.False:\n\t\t\t\treturn 'false';\n\t\t\tcase TokenType.In:\n\t\t\t\treturn 'in';\n\t\t\tcase TokenType.Not:\n\t\t\t\treturn 'not';\n\t\t\tcase TokenType.And:\n\t\t\t\treturn '&&';\n\t\t\tcase TokenType.Or:\n\t\t\t\treturn '||';\n\t\t\tcase TokenType.Str:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.Error:\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.EOF:\n\t\t\t\treturn 'EOF';\n\t\t\tdefault:\n\t\t\t\tthrow illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);\n\t\t}\n\t}\n\n\tprivate static _regexFlags = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0)));\n\n\tprivate static _keywords = new Map<string, KeywordTokenType>([\n\t\t['not', TokenType.Not],\n\t\t['in', TokenType.In],\n\t\t['false', TokenType.False],\n\t\t['true', TokenType.True],\n\t]);\n\n\tprivate _input: string = '';\n\tprivate _start: number = 0;\n\tprivate _current: number = 0;\n\tprivate _tokens: Token[] = [];\n\tprivate _errors: LexingError[] = [];\n\n\tget errors(): Readonly<LexingError[]> {\n\t\treturn this._errors;\n\t}\n\n\treset(value: string) {\n\t\tthis._input = value;\n\n\t\tthis._start = 0;\n\t\tthis._current = 0;\n\t\tthis._tokens = [];\n\t\tthis._errors = [];\n\n\t\treturn this;\n\t}\n\n\tscan() {\n\t\twhile (!this._isAtEnd()) {\n\n\t\t\tthis._start = this._current;\n\n\t\t\tconst ch = this._advance();\n\t\t\tswitch (ch) {\n\t\t\t\tcase CharCode.OpenParen: this._addToken(TokenType.LParen); break;\n\t\t\t\tcase CharCode.CloseParen: this._addToken(TokenType.RParen); break;\n\n\t\t\t\tcase CharCode.ExclamationMark:\n\t\t\t\t\tif (this._match(CharCode.Equals)) {\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `!==`\n\t\t\t\t\t\tthis._tokens.push({ type: TokenType.NotEq, offset: this._start, isTripleEq });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._addToken(TokenType.Neg);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.SingleQuote: this._quotedString(); break;\n\t\t\t\tcase CharCode.Slash: this._regex(); break;\n\n\t\t\t\tcase CharCode.Equals:\n\t\t\t\t\tif (this._match(CharCode.Equals)) { // support `==`\n\t\t\t\t\t\tconst isTripleEq = this._match(CharCode.Equals); // eat last `=` if `===`\n\t\t\t\t\t\tthis._tokens.push({ type: TokenType.Eq, offset: this._start, isTripleEq });\n\t\t\t\t\t} else if (this._match(CharCode.Tilde)) {\n\t\t\t\t\t\tthis._addToken(TokenType.RegexOp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('==', '=~'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.LessThan: this._addToken(this._match(CharCode.Equals) ? TokenType.LtEq : TokenType.Lt); break;\n\n\t\t\t\tcase CharCode.GreaterThan: this._addToken(this._match(CharCode.Equals) ? TokenType.GtEq : TokenType.Gt); break;\n\n\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\tif (this._match(CharCode.Ampersand)) {\n\t\t\t\t\t\tthis._addToken(TokenType.And);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('&&'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CharCode.Pipe:\n\t\t\t\t\tif (this._match(CharCode.Pipe)) {\n\t\t\t\t\t\tthis._addToken(TokenType.Or);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._error(hintDidYouMean('||'));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.\n\t\t\t\tcase CharCode.Space:\n\t\t\t\tcase CharCode.CarriageReturn:\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\tcase CharCode.LineFeed:\n\t\t\t\tcase CharCode.NoBreakSpace: // &nbsp\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._string();\n\t\t\t}\n\t\t}\n\n\t\tthis._start = this._current;\n\t\tthis._addToken(TokenType.EOF);\n\n\t\treturn Array.from(this._tokens);\n\t}\n\n\tprivate _match(expected: number): boolean {\n\t\tif (this._isAtEnd()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._input.charCodeAt(this._current) !== expected) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._current++;\n\t\treturn true;\n\t}\n\n\tprivate _advance(): number {\n\t\treturn this._input.charCodeAt(this._current++);\n\t}\n\n\tprivate _peek(): number {\n\t\treturn this._isAtEnd() ? CharCode.Null : this._input.charCodeAt(this._current);\n\t}\n\n\tprivate _addToken(type: TokenTypeWithoutLexeme) {\n\t\tthis._tokens.push({ type, offset: this._start });\n\t}\n\n\tprivate _error(additional?: string) {\n\t\tconst offset = this._start;\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tconst errToken: Token = { type: TokenType.Error, offset: this._start, lexeme };\n\t\tthis._errors.push({ offset, lexeme, additionalInfo: additional });\n\t\tthis._tokens.push(errToken);\n\t}\n\n\t// u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)\n\tprivate stringRe = /[a-zA-Z0-9_<>\\-\\./\\\\:\\*\\?\\+\\[\\]\\^,#@;\"%\\$\\p{L}-]+/uy;\n\tprivate _string() {\n\t\tthis.stringRe.lastIndex = this._start;\n\t\tconst match = this.stringRe.exec(this._input);\n\t\tif (match) {\n\t\t\tthis._current = this._start + match[0].length;\n\t\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\t\tconst keyword = Scanner._keywords.get(lexeme);\n\t\t\tif (keyword) {\n\t\t\t\tthis._addToken(keyword);\n\t\t\t} else {\n\t\t\t\tthis._tokens.push({ type: TokenType.Str, lexeme, offset: this._start });\n\t\t\t}\n\t\t}\n\t}\n\n\t// captures the lexeme without the leading and trailing '\n\tprivate _quotedString() {\n\t\twhile (this._peek() !== CharCode.SingleQuote && !this._isAtEnd()) { // TODO@ulugbekna: add support for escaping ' ?\n\t\t\tthis._advance();\n\t\t}\n\n\t\tif (this._isAtEnd()) {\n\t\t\tthis._error(hintDidYouForgetToOpenOrCloseQuote);\n\t\t\treturn;\n\t\t}\n\n\t\t// consume the closing '\n\t\tthis._advance();\n\n\t\tthis._tokens.push({ type: TokenType.QuotedStr, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });\n\t}\n\n\t/*\n\t * Lexing a regex expression: /.../[igsmyu]*\n\t * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181\n\t *\n\t * Note that we want slashes within a regex to be escaped, e.g., /file:\\\\/\\\\/\\\\// should match `file:///`\n\t */\n\tprivate _regex() {\n\t\tlet p = this._current;\n\n\t\tlet inEscape = false;\n\t\tlet inCharacterClass = false;\n\t\twhile (true) {\n\t\t\tif (p >= this._input.length) {\n\t\t\t\tthis._current = p;\n\t\t\t\tthis._error(hintDidYouForgetToEscapeSlash);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst ch = this._input.charCodeAt(p);\n\n\t\t\tif (inEscape) { // parsing an escape character\n\t\t\t\tinEscape = false;\n\t\t\t} else if (ch === CharCode.Slash && !inCharacterClass) { // end of regex\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t} else if (ch === CharCode.OpenSquareBracket) {\n\t\t\t\tinCharacterClass = true;\n\t\t\t} else if (ch === CharCode.Backslash) {\n\t\t\t\tinEscape = true;\n\t\t\t} else if (ch === CharCode.CloseSquareBracket) {\n\t\t\t\tinCharacterClass = false;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\t// Consume flags // TODO@ulugbekna: use regex instead\n\t\twhile (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {\n\t\t\tp++;\n\t\t}\n\n\t\tthis._current = p;\n\n\t\tconst lexeme = this._input.substring(this._start, this._current);\n\t\tthis._tokens.push({ type: TokenType.RegexStr, lexeme, offset: this._start });\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._current >= this._input.length;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as descriptors from './descriptors';\nimport { ServiceCollection } from './serviceCollection';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Event } from 'vs/base/common/event';\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from 'vs/base/common/platform';\nimport { isFalsyOrWhitespace } from 'vs/base/common/strings';\nimport { Scanner, LexingError, Token, TokenType } from 'vs/platform/contextkey/common/scanner';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { localize } from 'vs/nls';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { illegalArgument } from 'vs/base/common/errors';\n\nconst CONSTANT_VALUES = new Map<string, boolean>();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\n\n/** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */\nexport function setConstant(key: string, value: boolean) {\n\tif (CONSTANT_VALUES.get(key) !== undefined) { throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`'); }\n\n\tCONSTANT_VALUES.set(key, value);\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport const enum ContextKeyExprType {\n\tFalse = 0,\n\tTrue = 1,\n\tDefined = 2,\n\tNot = 3,\n\tEquals = 4,\n\tNotEquals = 5,\n\tAnd = 6,\n\tRegex = 7,\n\tNotRegex = 8,\n\tOr = 9,\n\tIn = 10,\n\tNotIn = 11,\n\tGreater = 12,\n\tGreaterEquals = 13,\n\tSmaller = 14,\n\tSmallerEquals = 15,\n}\n\nexport interface IContextKeyExprMapper {\n\tmapDefined(key: string): ContextKeyExpression;\n\tmapNot(key: string): ContextKeyExpression;\n\tmapEquals(key: string, value: any): ContextKeyExpression;\n\tmapNotEquals(key: string, value: any): ContextKeyExpression;\n\tmapGreater(key: string, value: any): ContextKeyExpression;\n\tmapGreaterEquals(key: string, value: any): ContextKeyExpression;\n\tmapSmaller(key: string, value: any): ContextKeyExpression;\n\tmapSmallerEquals(key: string, value: any): ContextKeyExpression;\n\tmapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;\n\tmapIn(key: string, valueKey: string): ContextKeyInExpr;\n\tmapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;\n}\n\nexport interface IContextKeyExpression {\n\tcmp(other: ContextKeyExpression): number;\n\tequals(other: ContextKeyExpression): boolean;\n\tsubstituteConstants(): ContextKeyExpression | undefined;\n\tevaluate(context: IContext): boolean;\n\tserialize(): string;\n\tkeys(): string[];\n\tmap(mapFnc: IContextKeyExprMapper): ContextKeyExpression;\n\tnegate(): ContextKeyExpression;\n\n}\n\nexport type ContextKeyExpression = (\n\tContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr\n\t| ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr\n\t| ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr\n\t| ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr\n\t| ContextKeySmallerExpr | ContextKeySmallerEqualsExpr\n);\n\n\n/*\n\nSyntax grammar:\n\n```ebnf\n\nexpression ::= or\n\nor ::= and { '||' and }*\n\nand ::= term { '&&' term }*\n\nterm ::=\n\t| '!' (KEY | true | false | parenthesized)\n\t| primary\n\nprimary ::=\n\t| 'true'\n\t| 'false'\n\t| parenthesized\n\t| KEY '=~' REGEX\n\t| KEY [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'not' 'in' | 'in') value ]\n\nparenthesized ::=\n\t| '(' expression ')'\n\nvalue ::=\n\t| 'true'\n\t| 'false'\n\t| 'in'      \t// we support `in` as a value because there's an extension that uses it, ie \"when\": \"languageId == in\"\n\t| VALUE \t\t// matched by the same regex as KEY; consider putting the value in single quotes if it's a string (e.g., with spaces)\n\t| SINGLE_QUOTED_STR\n\t| EMPTY_STR  \t// this allows \"when\": \"foo == \" which's used by existing extensions\n\n```\n*/\n\nexport type ParserConfig = {\n\t/**\n\t * with this option enabled, the parser can recover from regex parsing errors, e.g., unescaped slashes: `/src//` is accepted as `/src\\//` would be\n\t */\n\tregexParsingWithErrorRecovery: boolean;\n};\n\nconst defaultConfig: ParserConfig = {\n\tregexParsingWithErrorRecovery: true\n};\n\nexport type ParsingError = {\n\tmessage: string;\n\toffset: number;\n\tlexeme: string;\n\tadditionalInfo?: string;\n};\n\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n\t// Note: this doesn't produce an exact syntax tree but a normalized one\n\t// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\n\n\tprivate static _parseError = new Error();\n\n\t// lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n\tprivate readonly _scanner = new Scanner();\n\n\t// lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n\tprivate _tokens: Token[] = [];\n\tprivate _current = 0; \t\t\t\t\t// invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n\tprivate _parsingErrors: ParsingError[] = [];\n\n\tget lexingErrors(): Readonly<LexingError[]> {\n\t\treturn this._scanner.errors;\n\t}\n\n\tget parsingErrors(): Readonly<ParsingError[]> {\n\t\treturn this._parsingErrors;\n\t}\n\n\tconstructor(private readonly _config: ParserConfig = defaultConfig) {\n\t}\n\n\t/**\n\t * Parse a context key expression.\n\t *\n\t * @param input the expression to parse\n\t * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n\t */\n\tparse(input: string): ContextKeyExpression | undefined {\n\n\t\tif (input === '') {\n\t\t\tthis._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n\t\t\treturn undefined;\n\t\t}\n\n\t\tthis._tokens = this._scanner.reset(input).scan();\n\t\t// @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n\n\t\tthis._current = 0;\n\t\tthis._parsingErrors = [];\n\n\t\ttry {\n\t\t\tconst expr = this._expr();\n\t\t\tif (!this._isAtEnd()) {\n\t\t\t\tconst peek = this._peek();\n\t\t\t\tconst additionalInfo = peek.type === TokenType.Str ? hintUnexpectedToken : undefined;\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n\t\t\t\tthrow Parser._parseError;\n\t\t\t}\n\t\t\treturn expr;\n\t\t} catch (e) {\n\t\t\tif (!(e === Parser._parseError)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate _expr(): ContextKeyExpression | undefined {\n\t\treturn this._or();\n\t}\n\n\tprivate _or(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._and()];\n\n\t\twhile (this._matchOne(TokenType.Or)) {\n\t\t\tconst right = this._and();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n\t}\n\n\tprivate _and(): ContextKeyExpression | undefined {\n\t\tconst expr = [this._term()];\n\n\t\twhile (this._matchOne(TokenType.And)) {\n\t\t\tconst right = this._term();\n\t\t\texpr.push(right);\n\t\t}\n\n\t\treturn expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n\t}\n\n\tprivate _term(): ContextKeyExpression | undefined {\n\t\tif (this._matchOne(TokenType.Neg)) {\n\t\t\tconst peek = this._peek();\n\t\t\tswitch (peek.type) {\n\t\t\t\tcase TokenType.True:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\tcase TokenType.False:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\tcase TokenType.LParen: {\n\t\t\t\t\tthis._advance();\n\t\t\t\t\tconst expr = this._expr();\n\t\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\t\treturn expr?.negate();\n\t\t\t\t}\n\t\t\t\tcase TokenType.Str:\n\t\t\t\t\tthis._advance();\n\t\t\t\t\treturn ContextKeyNotExpr.create(peek.lexeme);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n\t\t\t}\n\t\t}\n\t\treturn this._primary();\n\t}\n\n\tprivate _primary(): ContextKeyExpression | undefined {\n\n\t\tconst peek = this._peek();\n\t\tswitch (peek.type) {\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.true();\n\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn ContextKeyExpr.false();\n\n\t\t\tcase TokenType.LParen: {\n\t\t\t\tthis._advance();\n\t\t\t\tconst expr = this._expr();\n\t\t\t\tthis._consume(TokenType.RParen, errorClosingParenthesis);\n\t\t\t\treturn expr;\n\t\t\t}\n\n\t\t\tcase TokenType.Str: {\n\t\t\t\t// KEY\n\t\t\t\tconst key = peek.lexeme;\n\t\t\t\tthis._advance();\n\n\t\t\t\t// =~ regex\n\t\t\t\tif (this._matchOne(TokenType.RegexOp)) {\n\n\t\t\t\t\t// @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n\t\t\t\t\tconst expr = this._peek();\n\n\t\t\t\t\tif (!this._config.regexParsingWithErrorRecovery) {\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\tif (expr.type !== TokenType.RegexStr) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst regexLexeme = expr.lexeme;\n\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regexp);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (expr.type) {\n\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\tcase TokenType.Error: { // also handle an ErrorToken in case of smth such as /(/file)/\n\t\t\t\t\t\t\tconst lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n\t\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\t\tlet followingToken = this._peek();\n\t\t\t\t\t\t\tlet parenBalance = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < expr.lexeme.length; i++) {\n\t\t\t\t\t\t\t\tif (expr.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (!this._isAtEnd() && followingToken.type !== TokenType.And && followingToken.type !== TokenType.Or) {\n\t\t\t\t\t\t\t\tswitch (followingToken.type) {\n\t\t\t\t\t\t\t\t\tcase TokenType.LParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RParen:\n\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase TokenType.RegexStr:\n\t\t\t\t\t\t\t\t\tcase TokenType.QuotedStr:\n\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < followingToken.lexeme.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\tif (followingToken.lexeme.charCodeAt(i) === CharCode.OpenParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance++;\n\t\t\t\t\t\t\t\t\t\t\t} else if (expr.lexeme.charCodeAt(i) === CharCode.CloseParen) {\n\t\t\t\t\t\t\t\t\t\t\t\tparenBalance--;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (parenBalance < 0) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlexemeReconstruction.push(Scanner.getLexeme(followingToken));\n\t\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t\tfollowingToken = this._peek();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst regexLexeme = lexemeReconstruction.join('');\n\t\t\t\t\t\t\tconst closingSlashIndex = regexLexeme.lastIndexOf('/');\n\t\t\t\t\t\t\tconst flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n\t\t\t\t\t\t\tlet regexp: RegExp | null;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tregexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn ContextKeyExpr.regex(key, regexp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase TokenType.QuotedStr: {\n\t\t\t\t\t\t\tconst serializedValue = expr.lexeme;\n\t\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\t\t// replicate old regex parsing behavior\n\n\t\t\t\t\t\t\tlet regex: RegExp | null = null;\n\n\t\t\t\t\t\t\tif (!isFalsyOrWhitespace(serializedValue)) {\n\t\t\t\t\t\t\t\tconst start = serializedValue.indexOf('/');\n\t\t\t\t\t\t\t\tconst end = serializedValue.lastIndexOf('/');\n\t\t\t\t\t\t\t\tif (start !== end && start >= 0) {\n\n\t\t\t\t\t\t\t\t\tconst value = serializedValue.slice(start + 1, end);\n\t\t\t\t\t\t\t\t\tconst caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tregex = new RegExp(value, caseIgnoreFlag);\n\t\t\t\t\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\t\t\t\t\tthrow this._errExpectedButGot(`REGEX`, expr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (regex === null) {\n\t\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', expr);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn ContextKeyRegexExpr.create(key, regex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow this._errExpectedButGot('REGEX', this._peek());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// [ 'not' 'in' value ]\n\t\t\t\tif (this._matchOne(TokenType.Not)) {\n\t\t\t\t\tthis._consume(TokenType.In, errorNoInAfterNot);\n\t\t\t\t\tconst right = this._value();\n\t\t\t\t\treturn ContextKeyExpr.notIn(key, right);\n\t\t\t\t}\n\n\t\t\t\t// [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n\t\t\t\tconst maybeOp = this._peek().type;\n\t\t\t\tswitch (maybeOp) {\n\t\t\t\t\tcase TokenType.Eq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.equals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcase TokenType.NotEq: {\n\t\t\t\t\t\tthis._advance();\n\n\t\t\t\t\t\tconst right = this._value();\n\t\t\t\t\t\tif (this._previous().type === TokenType.QuotedStr) { // same as above with \"foo != 'true'\"\n\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (right) {\n\t\t\t\t\t\t\tcase 'true':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.not(key);\n\t\t\t\t\t\t\tcase 'false':\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn ContextKeyExpr.notEquals(key, right);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n\t\t\t\t\t// consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n\t\t\t\t\tcase TokenType.Lt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.LtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeySmallerEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.Gt:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.GtEq:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyGreaterEqualsExpr.create(key, this._value());\n\n\t\t\t\t\tcase TokenType.In:\n\t\t\t\t\t\tthis._advance();\n\t\t\t\t\t\treturn ContextKeyExpr.in(key, this._value());\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn ContextKeyExpr.has(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase TokenType.EOF:\n\t\t\t\tthis._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n\t\t\t\tthrow Parser._parseError;\n\n\t\t\tdefault:\n\t\t\t\tthrow this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n\n\t\t}\n\t}\n\n\tprivate _value(): string {\n\t\tconst token = this._peek();\n\t\tswitch (token.type) {\n\t\t\tcase TokenType.Str:\n\t\t\tcase TokenType.QuotedStr:\n\t\t\t\tthis._advance();\n\t\t\t\treturn token.lexeme;\n\t\t\tcase TokenType.True:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'true';\n\t\t\tcase TokenType.False:\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'false';\n\t\t\tcase TokenType.In: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n\t\t\t\tthis._advance();\n\t\t\t\treturn 'in';\n\t\t\tdefault:\n\t\t\t\t// this allows \"when\": \"foo == \" which's used by existing extensions\n\t\t\t\t// we do not call `_advance` on purpose - we don't want to eat unintended tokens\n\t\t\t\treturn '';\n\t\t}\n\t}\n\n\tprivate _flagsGYRe = /g|y/g;\n\tprivate _removeFlagsGY(flags: string): string {\n\t\treturn flags.replaceAll(this._flagsGYRe, '');\n\t}\n\n\t// careful: this can throw if current token is the initial one (ie index = 0)\n\tprivate _previous() {\n\t\treturn this._tokens[this._current - 1];\n\t}\n\n\tprivate _matchOne(token: TokenType) {\n\t\tif (this._check(token)) {\n\t\t\tthis._advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate _advance() {\n\t\tif (!this._isAtEnd()) {\n\t\t\tthis._current++;\n\t\t}\n\t\treturn this._previous();\n\t}\n\n\tprivate _consume(type: TokenType, message: string) {\n\t\tif (this._check(type)) {\n\t\t\treturn this._advance();\n\t\t}\n\n\t\tthrow this._errExpectedButGot(message, this._peek());\n\t}\n\n\tprivate _errExpectedButGot(expected: string, got: Token, additionalInfo?: string) {\n\t\tconst message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n\t\tconst offset = got.offset;\n\t\tconst lexeme = Scanner.getLexeme(got);\n\t\tthis._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n\t\treturn Parser._parseError;\n\t}\n\n\tprivate _check(type: TokenType) {\n\t\treturn this._peek().type === type;\n\t}\n\n\tprivate _peek() {\n\t\treturn this._tokens[this._current];\n\t}\n\n\tprivate _isAtEnd() {\n\t\treturn this._peek().type === TokenType.EOF;\n\t}\n}\n\nexport abstract class ContextKeyExpr {\n\n\tpublic static false(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n\tpublic static true(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n\tpublic static has(key: string): ContextKeyExpression {\n\t\treturn ContextKeyDefinedExpr.create(key);\n\t}\n\tpublic static equals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(key, value);\n\t}\n\tpublic static notEquals(key: string, value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(key, value);\n\t}\n\tpublic static regex(key: string, value: RegExp): ContextKeyExpression {\n\t\treturn ContextKeyRegexExpr.create(key, value);\n\t}\n\tpublic static in(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyInExpr.create(key, value);\n\t}\n\tpublic static notIn(key: string, value: string): ContextKeyExpression {\n\t\treturn ContextKeyNotInExpr.create(key, value);\n\t}\n\tpublic static not(key: string): ContextKeyExpression {\n\t\treturn ContextKeyNotExpr.create(key);\n\t}\n\tpublic static and(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr.create(expr, null, true);\n\t}\n\tpublic static or(...expr: Array<ContextKeyExpression | undefined | null>): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr.create(expr, null, true);\n\t}\n\tpublic static greater(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterExpr.create(key, value);\n\t}\n\tpublic static greaterEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeyGreaterEqualsExpr.create(key, value);\n\t}\n\tpublic static smaller(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerExpr.create(key, value);\n\t}\n\tpublic static smallerEquals(key: string, value: number): ContextKeyExpression {\n\t\treturn ContextKeySmallerEqualsExpr.create(key, value);\n\t}\n\n\tprivate static _parser = new Parser({ regexParsingWithErrorRecovery: false });\n\tpublic static deserialize(serialized: string | null | undefined): ContextKeyExpression | undefined {\n\t\tif (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst expr = this._parser.parse(serialized);\n\t\treturn expr;\n\t}\n\n}\n\n\nexport function validateWhenClauses(whenClauses: string[]): any {\n\n\tconst parser = new Parser({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes\n\n\treturn whenClauses.map(whenClause => {\n\t\tparser.parse(whenClause);\n\n\t\tif (parser.lexingErrors.length > 0) {\n\t\t\treturn parser.lexingErrors.map((se: LexingError) => ({\n\t\t\t\terrorMessage: se.additionalInfo ?\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinterWithHint', \"Unexpected token. Hint: {0}\", se.additionalInfo) :\n\t\t\t\t\tlocalize('contextkey.scanner.errorForLinter', \"Unexpected token.\"),\n\t\t\t\toffset: se.offset,\n\t\t\t\tlength: se.lexeme.length,\n\t\t\t}));\n\t\t} else if (parser.parsingErrors.length > 0) {\n\t\t\treturn parser.parsingErrors.map((pe: ParsingError) => ({\n\t\t\t\terrorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n\t\t\t\toffset: pe.offset,\n\t\t\t\tlength: pe.lexeme.length,\n\t\t\t}));\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t});\n}\n\nexport function expressionsAreEqualWithConstantSubstitution(a: ContextKeyExpression | null | undefined, b: ContextKeyExpression | null | undefined): boolean {\n\tconst aExpr = a ? a.substituteConstants() : undefined;\n\tconst bExpr = b ? b.substituteConstants() : undefined;\n\tif (!aExpr && !bExpr) {\n\t\treturn true;\n\t}\n\tif (!aExpr || !bExpr) {\n\t\treturn false;\n\t}\n\treturn aExpr.equals(bExpr);\n}\n\nfunction cmp(a: ContextKeyExpression, b: ContextKeyExpression): number {\n\treturn a.cmp(b);\n}\n\nexport class ContextKeyFalseExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyFalseExpr();\n\n\tpublic readonly type = ContextKeyExprType.False;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'false';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyTrueExpr implements IContextKeyExpression {\n\tpublic static INSTANCE = new ContextKeyTrueExpr();\n\n\tpublic readonly type = ContextKeyExprType.True;\n\n\tprotected constructor() {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\treturn this.type - other.type;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\treturn (other.type === this.type);\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn true;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn 'true';\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn this;\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t}\n}\n\nexport class ContextKeyDefinedExpr implements IContextKeyExpression {\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn new ContextKeyDefinedExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Defined;\n\n\tprotected constructor(\n\t\treadonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.key;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapDefined(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\treturn (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Equals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst trueValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional ==\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) == this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} == '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyInExpr {\n\t\treturn new ContextKeyInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.In;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.valueKey, other.key, other.valueKey);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.valueKey === other.valueKey);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst source = context.getValue(this.valueKey);\n\n\t\tconst item = context.getValue(this.key);\n\n\t\tif (Array.isArray(source)) {\n\t\t\treturn source.includes(item as any);\n\t\t}\n\n\t\tif (typeof item === 'string' && typeof source === 'object' && source !== null) {\n\t\t\treturn hasOwnProperty.call(source, item);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key, this.valueKey];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr {\n\t\treturn mapFnc.mapIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotInExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, valueKey: string): ContextKeyNotInExpr {\n\t\treturn new ContextKeyNotInExpr(key, valueKey);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotIn;\n\n\tprivate readonly _negated: ContextKeyInExpr;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly valueKey: string,\n\t) {\n\t\tthis._negated = ContextKeyInExpr.create(key, valueKey);\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._negated.cmp(other._negated);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._negated.equals(other._negated);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._negated.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} not in '${this.valueKey}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._negated.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotIn(this.key, this.valueKey);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._negated;\n\t}\n}\n\nexport class ContextKeyNotEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tif (typeof value === 'boolean') {\n\t\t\tif (value) {\n\t\t\t\treturn ContextKeyNotExpr.create(key, negated);\n\t\t\t}\n\t\t\treturn ContextKeyDefinedExpr.create(key, negated);\n\t\t}\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotEqualsExpr(key, value, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: any,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\tconst falseValue = constantValue ? 'true' : 'false';\n\t\t\treturn (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\t// Intentional !=\n\t\t// eslint-disable-next-line eqeqeq\n\t\treturn (context.getValue(this.key) != this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} != '${this.value}'`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNotEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\tconst constantValue = CONSTANT_VALUES.get(key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn new ContextKeyNotExpr(key, negated);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Not;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp1(this.key, other.key);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst constantValue = CONSTANT_VALUES.get(this.key);\n\t\tif (typeof constantValue === 'boolean') {\n\t\t\treturn (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn (!context.getValue(this.key));\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!${this.key}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapNot(this.key);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyDefinedExpr.create(this.key, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nfunction withFloatOrStr<T extends ContextKeyExpression>(value: any, callback: (value: number | string) => T): T | ContextKeyFalseExpr {\n\tif (typeof value === 'string') {\n\t\tconst n = parseFloat(value);\n\t\tif (!isNaN(n)) {\n\t\t\tvalue = n;\n\t\t}\n\t}\n\tif (typeof value === 'string' || typeof value === 'number') {\n\t\treturn callback(value);\n\t}\n\treturn ContextKeyFalseExpr.INSTANCE;\n}\n\nexport class ContextKeyGreaterExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Greater;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) > this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} > ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreater(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.GreaterEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) { }\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) >= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} >= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapGreaterEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Smaller;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) < this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} < ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmaller(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeySmallerEqualsExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, _value: any, negated: ContextKeyExpression | null = null): ContextKeyExpression {\n\t\treturn withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n\t}\n\n\tpublic readonly type = ContextKeyExprType.SmallerEquals;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly value: number | string,\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn cmp2(this.key, this.value, other.key, other.value);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn (this.key === other.key && this.value === other.value);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tif (typeof this.value === 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn (parseFloat(<any>context.getValue(this.key)) <= this.value);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `${this.key} <= ${this.value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn mapFnc.mapSmallerEquals(this.key, this.value);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr {\n\t\treturn new ContextKeyRegexExpr(key, regexp);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Regex;\n\tprivate negated: ContextKeyExpression | null = null;\n\n\tprivate constructor(\n\t\tprivate readonly key: string,\n\t\tprivate readonly regexp: RegExp | null\n\t) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.key < other.key) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.key > other.key) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\tif (thisSource < otherSource) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (thisSource > otherSource) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tconst thisSource = this.regexp ? this.regexp.source : '';\n\t\t\tconst otherSource = other.regexp ? other.regexp.source : '';\n\t\t\treturn (this.key === other.key && thisSource === otherSource);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tconst value = context.getValue<any>(this.key);\n\t\treturn this.regexp ? this.regexp.test(value) : false;\n\t}\n\n\tpublic serialize(): string {\n\t\tconst value = this.regexp\n\t\t\t? `/${this.regexp.source}/${this.regexp.flags}`\n\t\t\t: '/invalid/';\n\t\treturn `${this.key} =~ ${value}`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn [this.key];\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr {\n\t\treturn mapFnc.mapRegex(this.key, this.regexp);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tthis.negated = ContextKeyNotRegexExpr.create(this);\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyNotRegexExpr implements IContextKeyExpression {\n\n\tpublic static create(actual: ContextKeyRegexExpr): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(actual);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.NotRegex;\n\n\tprivate constructor(private readonly _actual: ContextKeyRegexExpr) {\n\t\t//\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\treturn this._actual.cmp(other._actual);\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\treturn this._actual.equals(other._actual);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\treturn this;\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\treturn !this._actual.evaluate(context);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn `!(${this._actual.serialize()})`;\n\t}\n\n\tpublic keys(): string[] {\n\t\treturn this._actual.keys();\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\treturn this._actual;\n\t}\n}\n\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr: ContextKeyExpression[]): (ContextKeyExpression | undefined)[] {\n\t// Allocate array only if there is a difference\n\tlet newArr: (ContextKeyExpression | undefined)[] | null = null;\n\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\tconst newExpr = arr[i].substituteConstants();\n\n\t\tif (arr[i] !== newExpr) {\n\t\t\t// something has changed!\n\n\t\t\t// allocate array on first difference\n\t\t\tif (newArr === null) {\n\t\t\t\tnewArr = [];\n\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\tnewArr[j] = arr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newArr !== null) {\n\t\t\tnewArr[i] = newExpr;\n\t\t}\n\t}\n\n\tif (newArr === null) {\n\t\treturn arr;\n\t}\n\treturn newArr;\n}\n\nexport class ContextKeyAndExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.And;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyAndExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (!this.expr[i].evaluate(context)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tconst expr: ContextKeyExpression[] = [];\n\t\tlet hasTrue = false;\n\n\t\tfor (const e of arr) {\n\t\t\tif (!e) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t// anything && true ==> anything\n\t\t\t\thasTrue = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t// anything && false ==> false\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\tif (e.type === ContextKeyExprType.And) {\n\t\t\t\texpr.push(...e.expr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\texpr.push(e);\n\t\t}\n\n\t\tif (expr.length === 0 && hasTrue) {\n\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\texpr.sort(cmp);\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// We must distribute any OR expression because we don't support parens\n\t\t// OR extensions will be at the end (due to sorting rules)\n\t\twhile (expr.length > 1) {\n\t\t\tconst lastElement = expr[expr.length - 1];\n\t\t\tif (lastElement.type !== ContextKeyExprType.Or) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// pop the last element\n\t\t\texpr.pop();\n\n\t\t\t// pop the second to last element\n\t\t\tconst secondToLastElement = expr.pop()!;\n\n\t\t\tconst isFinished = (expr.length === 0);\n\n\t\t\t// distribute `lastElement` over `secondToLastElement`\n\t\t\tconst resultElement = ContextKeyOrExpr.create(\n\t\t\t\tlastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)),\n\t\t\t\tnull,\n\t\t\t\tisFinished\n\t\t\t);\n\n\t\t\tif (resultElement) {\n\t\t\t\texpr.push(resultElement);\n\t\t\t\texpr.sort(cmp);\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve false AND expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A && !A case\n\t\t\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyAndExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' && ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport class ContextKeyOrExpr implements IContextKeyExpression {\n\n\tpublic static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\treturn ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n\t}\n\n\tpublic readonly type = ContextKeyExprType.Or;\n\n\tprivate constructor(\n\t\tpublic readonly expr: ContextKeyExpression[],\n\t\tprivate negated: ContextKeyExpression | null\n\t) {\n\t}\n\n\tpublic cmp(other: ContextKeyExpression): number {\n\t\tif (other.type !== this.type) {\n\t\t\treturn this.type - other.type;\n\t\t}\n\t\tif (this.expr.length < other.expr.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.expr.length > other.expr.length) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tconst r = cmp(this.expr[i], other.expr[i]);\n\t\t\tif (r !== 0) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic equals(other: ContextKeyExpression): boolean {\n\t\tif (other.type === this.type) {\n\t\t\tif (this.expr.length !== other.expr.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\t\tif (!this.expr[i].equals(other.expr[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic substituteConstants(): ContextKeyExpression | undefined {\n\t\tconst exprArr = eliminateConstantsInArray(this.expr);\n\t\tif (exprArr === this.expr) {\n\t\t\t// no change\n\t\t\treturn this;\n\t\t}\n\t\treturn ContextKeyOrExpr.create(exprArr, this.negated, false);\n\t}\n\n\tpublic evaluate(context: IContext): boolean {\n\t\tfor (let i = 0, len = this.expr.length; i < len; i++) {\n\t\t\tif (this.expr[i].evaluate(context)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _normalizeArr(arr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined {\n\t\tlet expr: ContextKeyExpression[] = [];\n\t\tlet hasFalse = false;\n\n\t\tif (arr) {\n\t\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\t\tconst e = arr[i];\n\t\t\t\tif (!e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.False) {\n\t\t\t\t\t// anything || false ==> anything\n\t\t\t\t\thasFalse = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.True) {\n\t\t\t\t\t// anything || true ==> true\n\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t}\n\n\t\t\t\tif (e.type === ContextKeyExprType.Or) {\n\t\t\t\t\texpr = expr.concat(e.expr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\texpr.push(e);\n\t\t\t}\n\n\t\t\tif (expr.length === 0 && hasFalse) {\n\t\t\t\treturn ContextKeyFalseExpr.INSTANCE;\n\t\t\t}\n\n\t\t\texpr.sort(cmp);\n\t\t}\n\n\t\tif (expr.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// eliminate duplicate terms\n\t\tfor (let i = 1; i < expr.length; i++) {\n\t\t\tif (expr[i - 1].equals(expr[i])) {\n\t\t\t\texpr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (expr.length === 1) {\n\t\t\treturn expr[0];\n\t\t}\n\n\t\t// resolve true OR expressions\n\t\tif (extraRedundantCheck) {\n\t\t\tfor (let i = 0; i < expr.length; i++) {\n\t\t\t\tfor (let j = i + 1; j < expr.length; j++) {\n\t\t\t\t\tif (expr[i].negate().equals(expr[j])) {\n\t\t\t\t\t\t// A || !A case\n\t\t\t\t\t\treturn ContextKeyTrueExpr.INSTANCE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expr.length === 1) {\n\t\t\t\treturn expr[0];\n\t\t\t}\n\t\t}\n\n\t\treturn new ContextKeyOrExpr(expr, negated);\n\t}\n\n\tpublic serialize(): string {\n\t\treturn this.expr.map(e => e.serialize()).join(' || ');\n\t}\n\n\tpublic keys(): string[] {\n\t\tconst result: string[] = [];\n\t\tfor (const expr of this.expr) {\n\t\t\tresult.push(...expr.keys());\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic map(mapFnc: IContextKeyExprMapper): ContextKeyExpression {\n\t\treturn new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n\t}\n\n\tpublic negate(): ContextKeyExpression {\n\t\tif (!this.negated) {\n\t\t\tconst result: ContextKeyExpression[] = [];\n\t\t\tfor (const expr of this.expr) {\n\t\t\t\tresult.push(expr.negate());\n\t\t\t}\n\n\t\t\t// We don't support parens, so here we distribute the AND over the OR terminals\n\t\t\t// We always take the first 2 AND pairs and distribute them\n\t\t\twhile (result.length > 1) {\n\t\t\t\tconst LEFT = result.shift()!;\n\t\t\t\tconst RIGHT = result.shift()!;\n\n\t\t\t\tconst all: ContextKeyExpression[] = [];\n\t\t\t\tfor (const left of getTerminals(LEFT)) {\n\t\t\t\t\tfor (const right of getTerminals(RIGHT)) {\n\t\t\t\t\t\tall.push(ContextKeyAndExpr.create([left, right], null, false)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.unshift(ContextKeyOrExpr.create(all, null, false)!);\n\t\t\t}\n\n\t\t\tthis.negated = ContextKeyOrExpr.create(result, this, true)!;\n\t\t}\n\t\treturn this.negated;\n\t}\n}\n\nexport interface ContextKeyInfo {\n\treadonly key: string;\n\treadonly type?: string;\n\treadonly description?: string;\n}\n\nexport class RawContextKey<T extends ContextKeyValue> extends ContextKeyDefinedExpr {\n\n\tprivate static _info: ContextKeyInfo[] = [];\n\n\tstatic all(): IterableIterator<ContextKeyInfo> {\n\t\treturn RawContextKey._info.values();\n\t}\n\n\tprivate readonly _defaultValue: T | undefined;\n\n\tconstructor(key: string, defaultValue: T | undefined, metaOrHide?: string | true | { type: string; description: string }) {\n\t\tsuper(key, null);\n\t\tthis._defaultValue = defaultValue;\n\n\t\t// collect all context keys into a central place\n\t\tif (typeof metaOrHide === 'object') {\n\t\t\tRawContextKey._info.push({ ...metaOrHide, key });\n\t\t} else if (metaOrHide !== true) {\n\t\t\tRawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n\t\t}\n\t}\n\n\tpublic bindTo(target: IContextKeyService): IContextKey<T> {\n\t\treturn target.createKey(this.key, this._defaultValue);\n\t}\n\n\tpublic getValue(target: IContextKeyService): T | undefined {\n\t\treturn target.getContextKeyValue<T>(this.key);\n\t}\n\n\tpublic toNegated(): ContextKeyExpression {\n\t\treturn this.negate();\n\t}\n\n\tpublic isEqualTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyEqualsExpr.create(this.key, value);\n\t}\n\n\tpublic notEqualsTo(value: any): ContextKeyExpression {\n\t\treturn ContextKeyNotEqualsExpr.create(this.key, value);\n\t}\n}\n\nexport type ContextKeyValue = null | undefined | boolean | number | string\n\t| Array<null | undefined | boolean | number | string>\n\t| Record<string, null | undefined | boolean | number | string>;\n\nexport interface IContext {\n\tgetValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;\n}\n\nexport interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {\n\tset(value: T): void;\n\treset(): void;\n\tget(): T | undefined;\n}\n\nexport interface IContextKeyServiceTarget {\n\tparentElement: IContextKeyServiceTarget | null;\n\tsetAttribute(attr: string, value: string): void;\n\tremoveAttribute(attr: string): void;\n\thasAttribute(attr: string): boolean;\n\tgetAttribute(attr: string): string | null;\n}\n\nexport const IContextKeyService = createDecorator<IContextKeyService>('contextKeyService');\n\nexport interface IReadableSet<T> {\n\thas(value: T): boolean;\n}\n\nexport interface IContextKeyChangeEvent {\n\taffectsSome(keys: IReadableSet<string>): boolean;\n\tallKeysContainedIn(keys: IReadableSet<string>): boolean;\n}\n\nexport type IScopedContextKeyService = IContextKeyService & IDisposable;\n\nexport interface IContextKeyService {\n\treadonly _serviceBrand: undefined;\n\n\tonDidChangeContext: Event<IContextKeyChangeEvent>;\n\tbufferChangeEvents(callback: Function): void;\n\n\tcreateKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;\n\tcontextMatchesRules(rules: ContextKeyExpression | undefined): boolean;\n\tgetContextKeyValue<T>(key: string): T | undefined;\n\n\tcreateScoped(target: IContextKeyServiceTarget): IScopedContextKeyService;\n\tcreateOverlay(overlay: Iterable<[string, any]>): IContextKeyService;\n\tgetContext(target: IContextKeyServiceTarget | null): IContext;\n\n\tupdateParent(parentContextKeyService: IContextKeyService): void;\n}\n\nfunction cmp1(key1: string, key2: string): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nfunction cmp2(key1: string, value1: any, key2: string, value2: any): number {\n\tif (key1 < key2) {\n\t\treturn -1;\n\t}\n\tif (key1 > key2) {\n\t\treturn 1;\n\t}\n\tif (value1 < value2) {\n\t\treturn -1;\n\t}\n\tif (value1 > value2) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p: ContextKeyExpression, q: ContextKeyExpression): boolean {\n\n\tif (p.type === ContextKeyExprType.False || q.type === ContextKeyExprType.True) {\n\t\t// false implies anything\n\t\t// anything implies true\n\t\treturn true;\n\t}\n\n\tif (p.type === ContextKeyExprType.Or) {\n\t\tif (q.type === ContextKeyExprType.Or) {\n\t\t\t// `a || b || c` can only imply something like `a || b || c || d`\n\t\t\treturn allElementsIncluded(p.expr, q.expr);\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (q.type === ContextKeyExprType.Or) {\n\t\tfor (const element of q.expr) {\n\t\t\tif (implies(p, element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (p.type === ContextKeyExprType.And) {\n\t\tif (q.type === ContextKeyExprType.And) {\n\t\t\t// `a && b && c` implies `a && c`\n\t\t\treturn allElementsIncluded(q.expr, p.expr);\n\t\t}\n\t\tfor (const element of p.expr) {\n\t\t\tif (implies(element, q)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn p.equals(q);\n}\n\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p: ContextKeyExpression[], q: ContextKeyExpression[]): boolean {\n\tlet pIndex = 0;\n\tlet qIndex = 0;\n\twhile (pIndex < p.length && qIndex < q.length) {\n\t\tconst cmp = p[pIndex].cmp(q[qIndex]);\n\n\t\tif (cmp < 0) {\n\t\t\t// an element from `p` is missing from `q`\n\t\t\treturn false;\n\t\t} else if (cmp === 0) {\n\t\t\tpIndex++;\n\t\t\tqIndex++;\n\t\t} else {\n\t\t\tqIndex++;\n\t\t}\n\t}\n\treturn (pIndex === p.length);\n}\n\nfunction getTerminals(node: ContextKeyExpression) {\n\tif (node.type === ContextKeyExprType.Or) {\n\t\treturn node.expr;\n\t}\n\treturn [node];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { decodeBase64, encodeBase64, VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { IDiffResult } from 'vs/base/common/diff/diff';\nimport { Event } from 'vs/base/common/event';\nimport * as glob from 'vs/base/common/glob';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { Mimes } from 'vs/base/common/mime';\nimport { Schemas } from 'vs/base/common/network';\nimport { basename } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { ISplice } from 'vs/base/common/sequence';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { ILineChange } from 'vs/editor/common/diff/smartLinesDiffComputer';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport { Command, WorkspaceEditMetadata } from 'vs/editor/common/languages';\nimport { IReadonlyTextBuffer } from 'vs/editor/common/model';\nimport { IAccessibilityInformation } from 'vs/platform/accessibility/common/accessibility';\nimport { RawContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IEditorModel } from 'vs/platform/editor/common/editor';\nimport { ExtensionIdentifier } from 'vs/platform/extensions/common/extensions';\nimport { ThemeColor } from 'vs/base/common/themables';\nimport { UndoRedoGroup } from 'vs/platform/undoRedo/common/undoRedo';\nimport { IRevertOptions, ISaveOptions, IUntypedEditorInput } from 'vs/workbench/common/editor';\nimport { NotebookTextModel } from 'vs/workbench/contrib/notebook/common/model/notebookTextModel';\nimport { ICellRange } from 'vs/workbench/contrib/notebook/common/notebookRange';\nimport { IWorkingCopyBackupMeta, IWorkingCopySaveEvent } from 'vs/workbench/services/workingCopy/common/workingCopy';\nimport { IMarkdownString } from 'vs/base/common/htmlContent';\n\nexport const NOTEBOOK_EDITOR_ID = 'workbench.editor.notebook';\nexport const NOTEBOOK_DIFF_EDITOR_ID = 'workbench.editor.notebookTextDiffEditor';\nexport const INTERACTIVE_WINDOW_EDITOR_ID = 'workbench.editor.interactive';\n\n\nexport enum CellKind {\n\tMarkup = 1,\n\tCode = 2\n}\n\nexport const NOTEBOOK_DISPLAY_ORDER: readonly string[] = [\n\t'application/json',\n\t'application/javascript',\n\t'text/html',\n\t'image/svg+xml',\n\tMimes.latex,\n\tMimes.markdown,\n\t'image/png',\n\t'image/jpeg',\n\tMimes.text\n];\n\nexport const ACCESSIBLE_NOTEBOOK_DISPLAY_ORDER: readonly string[] = [\n\tMimes.latex,\n\tMimes.markdown,\n\t'application/json',\n\t'text/html',\n\t'image/svg+xml',\n\t'image/png',\n\t'image/jpeg',\n\tMimes.text,\n];\n\n/**\n * A mapping of extension IDs who contain renderers, to notebook ids who they\n * should be treated as the same in the renderer selection logic. This is used\n * to prefer the 1st party Jupyter renderers even though they're in a separate\n * extension, for instance. See #136247.\n */\nexport const RENDERER_EQUIVALENT_EXTENSIONS: ReadonlyMap<string, ReadonlySet<string>> = new Map([\n\t['ms-toolsai.jupyter', new Set(['jupyter-notebook', 'interactive'])],\n\t['ms-toolsai.jupyter-renderers', new Set(['jupyter-notebook', 'interactive'])],\n]);\n\nexport const RENDERER_NOT_AVAILABLE = '_notAvailable';\n\nexport type ContributedNotebookRendererEntrypoint = string | { readonly extends: string; readonly path: string };\n\nexport enum NotebookRunState {\n\tRunning = 1,\n\tIdle = 2\n}\n\nexport type NotebookDocumentMetadata = Record<string, unknown>;\n\nexport enum NotebookCellExecutionState {\n\tUnconfirmed = 1,\n\tPending = 2,\n\tExecuting = 3\n}\nexport enum NotebookExecutionState {\n\tUnconfirmed = 1,\n\tPending = 2,\n\tExecuting = 3\n}\n\nexport interface INotebookCellPreviousExecutionResult {\n\texecutionOrder?: number;\n\tsuccess?: boolean;\n\tduration?: number;\n}\n\nexport interface NotebookCellMetadata {\n\t/**\n\t * custom metadata\n\t */\n\t[key: string]: unknown;\n}\n\nexport interface NotebookCellInternalMetadata {\n\texecutionId?: string;\n\texecutionOrder?: number;\n\tlastRunSuccess?: boolean;\n\trunStartTime?: number;\n\trunStartTimeAdjustment?: number;\n\trunEndTime?: number;\n\trenderDuration?: { [key: string]: number };\n}\n\nexport interface NotebookCellCollapseState {\n\tinputCollapsed?: boolean;\n\toutputCollapsed?: boolean;\n}\n\nexport interface NotebookCellDefaultCollapseConfig {\n\tcodeCell?: NotebookCellCollapseState;\n\tmarkupCell?: NotebookCellCollapseState;\n}\n\nexport type InteractiveWindowCollapseCodeCells = 'always' | 'never' | 'fromEditor';\n\nexport type TransientCellMetadata = { readonly [K in keyof NotebookCellMetadata]?: boolean };\nexport type CellContentMetadata = { readonly [K in keyof NotebookCellMetadata]?: boolean };\nexport type TransientDocumentMetadata = { readonly [K in keyof NotebookDocumentMetadata]?: boolean };\n\nexport interface TransientOptions {\n\treadonly transientOutputs: boolean;\n\treadonly transientCellMetadata: TransientCellMetadata;\n\treadonly transientDocumentMetadata: TransientDocumentMetadata;\n\treadonly cellContentMetadata: CellContentMetadata;\n}\n\n/** Note: enum values are used for sorting */\nexport const enum NotebookRendererMatch {\n\t/** Renderer has a hard dependency on an available kernel */\n\tWithHardKernelDependency = 0,\n\t/** Renderer works better with an available kernel */\n\tWithOptionalKernelDependency = 1,\n\t/** Renderer is kernel-agnostic */\n\tPure = 2,\n\t/** Renderer is for a different mimeType or has a hard dependency which is unsatisfied */\n\tNever = 3,\n}\n\n/**\n * Renderer messaging requirement. While this allows for 'optional' messaging,\n * VS Code effectively treats it the same as true right now. \"Partial\n * activation\" of extensions is a very tricky problem, which could allow\n * solving this. But for now, optional is mostly only honored for aznb.\n */\nexport const enum RendererMessagingSpec {\n\tAlways = 'always',\n\tNever = 'never',\n\tOptional = 'optional',\n}\n\nexport type NotebookRendererEntrypoint = { readonly extends: string | undefined; readonly path: URI };\n\nexport interface INotebookRendererInfo {\n\treadonly id: string;\n\treadonly displayName: string;\n\treadonly entrypoint: NotebookRendererEntrypoint;\n\treadonly extensionLocation: URI;\n\treadonly extensionId: ExtensionIdentifier;\n\treadonly messaging: RendererMessagingSpec;\n\n\treadonly mimeTypes: readonly string[];\n\n\treadonly isBuiltin: boolean;\n\n\tmatchesWithoutKernel(mimeType: string): NotebookRendererMatch;\n\tmatches(mimeType: string, kernelProvides: ReadonlyArray<string>): NotebookRendererMatch;\n}\n\nexport interface INotebookStaticPreloadInfo {\n\treadonly type: string;\n\treadonly entrypoint: URI;\n\treadonly extensionLocation: URI;\n\treadonly localResourceRoots: readonly URI[];\n}\n\nexport interface IOrderedMimeType {\n\tmimeType: string;\n\trendererId: string;\n\tisTrusted: boolean;\n}\n\nexport interface IOutputItemDto {\n\treadonly mime: string;\n\treadonly data: VSBuffer;\n}\n\nexport interface IOutputDto {\n\toutputs: IOutputItemDto[];\n\toutputId: string;\n\tmetadata?: Record<string, any>;\n}\n\nexport interface ICellOutput {\n\treadonly versionId: number;\n\toutputs: IOutputItemDto[];\n\tmetadata?: Record<string, any>;\n\toutputId: string;\n\tonDidChangeData: Event<void>;\n\treplaceData(items: IOutputDto): void;\n\tappendData(items: IOutputItemDto[]): void;\n}\n\nexport interface CellInternalMetadataChangedEvent {\n\treadonly lastRunSuccessChanged?: boolean;\n}\n\nexport interface ICell {\n\treadonly uri: URI;\n\thandle: number;\n\tlanguage: string;\n\tcellKind: CellKind;\n\toutputs: ICellOutput[];\n\tmetadata: NotebookCellMetadata;\n\tinternalMetadata: NotebookCellInternalMetadata;\n\tgetHashValue(): number;\n\ttextBuffer: IReadonlyTextBuffer;\n\tonDidChangeOutputs?: Event<NotebookCellOutputsSplice>;\n\tonDidChangeOutputItems?: Event<void>;\n\tonDidChangeLanguage: Event<string>;\n\tonDidChangeMetadata: Event<void>;\n\tonDidChangeInternalMetadata: Event<CellInternalMetadataChangedEvent>;\n}\n\nexport interface INotebookTextModel {\n\treadonly viewType: string;\n\tmetadata: NotebookDocumentMetadata;\n\treadonly transientOptions: TransientOptions;\n\treadonly uri: URI;\n\treadonly versionId: number;\n\treadonly length: number;\n\treadonly cells: readonly ICell[];\n\treset(cells: ICellDto2[], metadata: NotebookDocumentMetadata, transientOptions: TransientOptions): void;\n\tapplyEdits(rawEdits: ICellEditOperation[], synchronous: boolean, beginSelectionState: ISelectionState | undefined, endSelectionsComputer: () => ISelectionState | undefined, undoRedoGroup: UndoRedoGroup | undefined, computeUndoRedo?: boolean): boolean;\n\tonDidChangeContent: Event<NotebookTextModelChangedEvent>;\n\tonWillDispose: Event<void>;\n}\n\nexport type NotebookCellTextModelSplice<T> = [\n\tstart: number,\n\tdeleteCount: number,\n\tnewItems: T[]\n];\n\nexport type NotebookCellOutputsSplice = {\n\tstart: number /* start */;\n\tdeleteCount: number /* delete count */;\n\tnewOutputs: ICellOutput[];\n};\n\nexport interface IMainCellDto {\n\thandle: number;\n\turi: UriComponents;\n\tsource: string[];\n\teol: string;\n\tlanguage: string;\n\tcellKind: CellKind;\n\toutputs: IOutputDto[];\n\tmetadata?: NotebookCellMetadata;\n\tinternalMetadata?: NotebookCellInternalMetadata;\n}\n\nexport enum NotebookCellsChangeType {\n\tModelChange = 1,\n\tMove = 2,\n\tChangeCellLanguage = 5,\n\tInitialize = 6,\n\tChangeCellMetadata = 7,\n\tOutput = 8,\n\tOutputItem = 9,\n\tChangeCellContent = 10,\n\tChangeDocumentMetadata = 11,\n\tChangeCellInternalMetadata = 12,\n\tChangeCellMime = 13,\n\tUnknown = 100\n}\n\nexport interface NotebookCellsInitializeEvent<T> {\n\treadonly kind: NotebookCellsChangeType.Initialize;\n\treadonly changes: NotebookCellTextModelSplice<T>[];\n}\n\nexport interface NotebookCellContentChangeEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellContent;\n\treadonly index: number;\n}\n\nexport interface NotebookCellsModelChangedEvent<T> {\n\treadonly kind: NotebookCellsChangeType.ModelChange;\n\treadonly changes: NotebookCellTextModelSplice<T>[];\n}\n\nexport interface NotebookCellsModelMoveEvent<T> {\n\treadonly kind: NotebookCellsChangeType.Move;\n\treadonly index: number;\n\treadonly length: number;\n\treadonly newIdx: number;\n\treadonly cells: T[];\n}\n\nexport interface NotebookOutputChangedEvent {\n\treadonly kind: NotebookCellsChangeType.Output;\n\treadonly index: number;\n\treadonly outputs: IOutputDto[];\n\treadonly append: boolean;\n}\n\nexport interface NotebookOutputItemChangedEvent {\n\treadonly kind: NotebookCellsChangeType.OutputItem;\n\treadonly index: number;\n\treadonly outputId: string;\n\treadonly outputItems: IOutputItemDto[];\n\treadonly append: boolean;\n}\n\nexport interface NotebookCellsChangeLanguageEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellLanguage;\n\treadonly index: number;\n\treadonly language: string;\n}\n\nexport interface NotebookCellsChangeMimeEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellMime;\n\treadonly index: number;\n\treadonly mime: string | undefined;\n}\n\nexport interface NotebookCellsChangeMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellMetadata;\n\treadonly index: number;\n\treadonly metadata: NotebookCellMetadata;\n}\n\nexport interface NotebookCellsChangeInternalMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeCellInternalMetadata;\n\treadonly index: number;\n\treadonly internalMetadata: NotebookCellInternalMetadata;\n}\n\nexport interface NotebookDocumentChangeMetadataEvent {\n\treadonly kind: NotebookCellsChangeType.ChangeDocumentMetadata;\n\treadonly metadata: NotebookDocumentMetadata;\n}\n\nexport interface NotebookDocumentUnknownChangeEvent {\n\treadonly kind: NotebookCellsChangeType.Unknown;\n}\n\nexport type NotebookRawContentEventDto = NotebookCellsInitializeEvent<IMainCellDto> | NotebookDocumentChangeMetadataEvent | NotebookCellContentChangeEvent | NotebookCellsModelChangedEvent<IMainCellDto> | NotebookCellsModelMoveEvent<IMainCellDto> | NotebookOutputChangedEvent | NotebookOutputItemChangedEvent | NotebookCellsChangeLanguageEvent | NotebookCellsChangeMimeEvent | NotebookCellsChangeMetadataEvent | NotebookCellsChangeInternalMetadataEvent | NotebookDocumentUnknownChangeEvent;\n\nexport type NotebookCellsChangedEventDto = {\n\treadonly rawEvents: NotebookRawContentEventDto[];\n\treadonly versionId: number;\n};\n\nexport type NotebookRawContentEvent = (NotebookCellsInitializeEvent<ICell> | NotebookDocumentChangeMetadataEvent | NotebookCellContentChangeEvent | NotebookCellsModelChangedEvent<ICell> | NotebookCellsModelMoveEvent<ICell> | NotebookOutputChangedEvent | NotebookOutputItemChangedEvent | NotebookCellsChangeLanguageEvent | NotebookCellsChangeMimeEvent | NotebookCellsChangeMetadataEvent | NotebookCellsChangeInternalMetadataEvent | NotebookDocumentUnknownChangeEvent) & { transient: boolean };\n\nexport enum SelectionStateType {\n\tHandle = 0,\n\tIndex = 1\n}\n\nexport interface ISelectionHandleState {\n\tkind: SelectionStateType.Handle;\n\tprimary: number | null;\n\tselections: number[];\n}\n\nexport interface ISelectionIndexState {\n\tkind: SelectionStateType.Index;\n\tfocus: ICellRange;\n\tselections: ICellRange[];\n}\n\nexport type ISelectionState = ISelectionHandleState | ISelectionIndexState;\n\nexport type NotebookTextModelChangedEvent = {\n\treadonly rawEvents: NotebookRawContentEvent[];\n\treadonly versionId: number;\n\treadonly synchronous: boolean | undefined;\n\treadonly endSelectionState: ISelectionState | undefined;\n};\n\nexport type NotebookTextModelWillAddRemoveEvent = {\n\treadonly rawEvent: NotebookCellsModelChangedEvent<ICell>;\n};\n\nexport const enum CellEditType {\n\tReplace = 1,\n\tOutput = 2,\n\tMetadata = 3,\n\tCellLanguage = 4,\n\tDocumentMetadata = 5,\n\tMove = 6,\n\tOutputItems = 7,\n\tPartialMetadata = 8,\n\tPartialInternalMetadata = 9,\n}\n\nexport interface ICellDto2 {\n\tsource: string;\n\tlanguage: string;\n\tmime: string | undefined;\n\tcellKind: CellKind;\n\toutputs: IOutputDto[];\n\tmetadata?: NotebookCellMetadata;\n\tinternalMetadata?: NotebookCellInternalMetadata;\n\tcollapseState?: NotebookCellCollapseState;\n}\n\nexport interface ICellReplaceEdit {\n\teditType: CellEditType.Replace;\n\tindex: number;\n\tcount: number;\n\tcells: ICellDto2[];\n}\n\nexport interface ICellOutputEdit {\n\teditType: CellEditType.Output;\n\tindex: number;\n\toutputs: IOutputDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellOutputEditByHandle {\n\teditType: CellEditType.Output;\n\thandle: number;\n\toutputs: IOutputDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellOutputItemEdit {\n\teditType: CellEditType.OutputItems;\n\toutputId: string;\n\titems: IOutputItemDto[];\n\tappend?: boolean;\n}\n\nexport interface ICellMetadataEdit {\n\teditType: CellEditType.Metadata;\n\tindex: number;\n\tmetadata: NotebookCellMetadata;\n}\n\n// These types are nullable because we need to use 'null' on the EH side so it is JSON-stringified\nexport type NullablePartialNotebookCellMetadata = {\n\t[Key in keyof Partial<NotebookCellMetadata>]: NotebookCellMetadata[Key] | null\n};\n\nexport interface ICellPartialMetadataEdit {\n\teditType: CellEditType.PartialMetadata;\n\tindex: number;\n\tmetadata: NullablePartialNotebookCellMetadata;\n}\n\nexport interface ICellPartialMetadataEditByHandle {\n\teditType: CellEditType.PartialMetadata;\n\thandle: number;\n\tmetadata: NullablePartialNotebookCellMetadata;\n}\n\nexport type NullablePartialNotebookCellInternalMetadata = {\n\t[Key in keyof Partial<NotebookCellInternalMetadata>]: NotebookCellInternalMetadata[Key] | null\n};\nexport interface ICellPartialInternalMetadataEdit {\n\teditType: CellEditType.PartialInternalMetadata;\n\tindex: number;\n\tinternalMetadata: NullablePartialNotebookCellInternalMetadata;\n}\n\nexport interface ICellPartialInternalMetadataEditByHandle {\n\teditType: CellEditType.PartialInternalMetadata;\n\thandle: number;\n\tinternalMetadata: NullablePartialNotebookCellInternalMetadata;\n}\n\nexport interface ICellLanguageEdit {\n\teditType: CellEditType.CellLanguage;\n\tindex: number;\n\tlanguage: string;\n}\n\nexport interface IDocumentMetadataEdit {\n\teditType: CellEditType.DocumentMetadata;\n\tmetadata: NotebookDocumentMetadata;\n}\n\nexport interface ICellMoveEdit {\n\teditType: CellEditType.Move;\n\tindex: number;\n\tlength: number;\n\tnewIdx: number;\n}\n\nexport type IImmediateCellEditOperation = ICellOutputEditByHandle | ICellPartialMetadataEditByHandle | ICellOutputItemEdit | ICellPartialInternalMetadataEdit | ICellPartialInternalMetadataEditByHandle | ICellPartialMetadataEdit;\nexport type ICellEditOperation = IImmediateCellEditOperation | ICellReplaceEdit | ICellOutputEdit | ICellMetadataEdit | ICellPartialMetadataEdit | ICellPartialInternalMetadataEdit | IDocumentMetadataEdit | ICellMoveEdit | ICellOutputItemEdit | ICellLanguageEdit;\n\n\nexport interface IWorkspaceNotebookCellEdit {\n\tmetadata?: WorkspaceEditMetadata;\n\tresource: URI;\n\tnotebookVersionId: number | undefined;\n\tcellEdit: ICellPartialMetadataEdit | IDocumentMetadataEdit | ICellReplaceEdit;\n}\n\nexport interface NotebookData {\n\treadonly cells: ICellDto2[];\n\treadonly metadata: NotebookDocumentMetadata;\n}\n\n\nexport interface INotebookContributionData {\n\textension?: ExtensionIdentifier;\n\tproviderDisplayName: string;\n\tdisplayName: string;\n\tfilenamePattern: (string | glob.IRelativePattern | INotebookExclusiveDocumentFilter)[];\n\texclusive: boolean;\n\t/// Editor contribution is handled elswhere e.g. interactive\n\texternalEditor?: boolean;\n}\n\n\nexport namespace CellUri {\n\n\texport const scheme = Schemas.vscodeNotebookCell;\n\n\n\tconst _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];\n\tconst _padRegexp = new RegExp(`^[${_lengths.join('')}]+`);\n\tconst _radix = 7;\n\n\texport function generate(notebook: URI, handle: number): URI {\n\n\t\tconst s = handle.toString(_radix);\n\t\tconst p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';\n\n\t\tconst fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;\n\t\treturn notebook.with({ scheme, fragment });\n\t}\n\n\texport function parse(cell: URI): { notebook: URI; handle: number } | undefined {\n\t\tif (cell.scheme !== scheme) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst idx = cell.fragment.indexOf('s');\n\t\tif (idx < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);\n\t\tconst _scheme = decodeBase64(cell.fragment.substring(idx + 1)).toString();\n\n\t\tif (isNaN(handle)) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn {\n\t\t\thandle,\n\t\t\tnotebook: cell.with({ scheme: _scheme, fragment: null })\n\t\t};\n\t}\n\n\texport function generateCellOutputUri(notebook: URI, outputId?: string) {\n\t\treturn notebook.with({\n\t\t\tscheme: Schemas.vscodeNotebookCellOutput,\n\t\t\tfragment: `op${outputId ?? ''},${notebook.scheme !== Schemas.file ? notebook.scheme : ''}`\n\t\t});\n\t}\n\n\texport function parseCellOutputUri(uri: URI): { notebook: URI; outputId?: string } | undefined {\n\t\tif (uri.scheme !== Schemas.vscodeNotebookCellOutput) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\\,(.*)$/i.exec(uri.fragment);\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst outputId = (match[1] && match[1] !== '') ? match[1] : undefined;\n\t\tconst scheme = match[2];\n\t\treturn {\n\t\t\toutputId,\n\t\t\tnotebook: uri.with({\n\t\t\t\tscheme: scheme || Schemas.file,\n\t\t\t\tfragment: null\n\t\t\t})\n\t\t};\n\t}\n\n\texport function generateCellPropertyUri(notebook: URI, handle: number, scheme: string): URI {\n\t\treturn CellUri.generate(notebook, handle).with({ scheme: scheme });\n\t}\n\n\texport function parseCellPropertyUri(uri: URI, propertyScheme: string) {\n\t\tif (uri.scheme !== propertyScheme) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn CellUri.parse(uri.with({ scheme: scheme }));\n\t}\n}\n\nconst normalizeSlashes = (str: string) => isWindows ? str.replace(/\\//g, '\\\\') : str;\n\ninterface IMimeTypeWithMatcher {\n\tpattern: string;\n\tmatches: glob.ParsedPattern;\n}\n\nexport class MimeTypeDisplayOrder {\n\tprivate readonly order: IMimeTypeWithMatcher[];\n\n\tconstructor(\n\t\tinitialValue: readonly string[] = [],\n\t\tprivate readonly defaultOrder = NOTEBOOK_DISPLAY_ORDER,\n\t) {\n\t\tthis.order = [...new Set(initialValue)].map(pattern => ({\n\t\t\tpattern,\n\t\t\tmatches: glob.parse(normalizeSlashes(pattern))\n\t\t}));\n\t}\n\n\t/**\n\t * Returns a sorted array of the input mimetypes.\n\t */\n\tpublic sort(mimetypes: Iterable<string>): string[] {\n\t\tconst remaining = new Map(Iterable.map(mimetypes, m => [m, normalizeSlashes(m)]));\n\t\tlet sorted: string[] = [];\n\n\t\tfor (const { matches } of this.order) {\n\t\t\tfor (const [original, normalized] of remaining) {\n\t\t\t\tif (matches(normalized)) {\n\t\t\t\t\tsorted.push(original);\n\t\t\t\t\tremaining.delete(original);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (remaining.size) {\n\t\t\tsorted = sorted.concat([...remaining.keys()].sort(\n\t\t\t\t(a, b) => this.defaultOrder.indexOf(a) - this.defaultOrder.indexOf(b),\n\t\t\t));\n\t\t}\n\n\t\treturn sorted;\n\t}\n\n\t/**\n\t * Records that the user selected the given mimetype over the other\n\t * possible mimetypes, prioritizing it for future reference.\n\t */\n\tpublic prioritize(chosenMimetype: string, otherMimetypes: readonly string[]) {\n\t\tconst chosenIndex = this.findIndex(chosenMimetype);\n\t\tif (chosenIndex === -1) {\n\t\t\t// always first, nothing more to do\n\t\t\tthis.order.unshift({ pattern: chosenMimetype, matches: glob.parse(normalizeSlashes(chosenMimetype)) });\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the other mimetypes that are before the chosenMimetype. Then, move\n\t\t// them after it, retaining order.\n\t\tconst uniqueIndicies = new Set(otherMimetypes.map(m => this.findIndex(m, chosenIndex)));\n\t\tuniqueIndicies.delete(-1);\n\t\tconst otherIndices = Array.from(uniqueIndicies).sort();\n\t\tthis.order.splice(chosenIndex + 1, 0, ...otherIndices.map(i => this.order[i]));\n\n\t\tfor (let oi = otherIndices.length - 1; oi >= 0; oi--) {\n\t\t\tthis.order.splice(otherIndices[oi], 1);\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of in-order mimetype preferences.\n\t */\n\tpublic toArray() {\n\t\treturn this.order.map(o => o.pattern);\n\t}\n\n\tprivate findIndex(mimeType: string, maxIndex = this.order.length) {\n\t\tconst normalized = normalizeSlashes(mimeType);\n\t\tfor (let i = 0; i < maxIndex; i++) {\n\t\t\tif (this.order[i].matches(normalized)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\nexport function diff<T>(before: T[], after: T[], contains: (a: T) => boolean, equal: (a: T, b: T) => boolean = (a: T, b: T) => a === b): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\n\t\tif (equal(beforeElement, afterElement)) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (contains(afterElement)) {\n\t\t\t// `afterElement` exists before, which means some elements before `afterElement` are deleted\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else {\n\t\t\t// `afterElement` added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport interface ICellEditorViewState {\n\tselections: editorCommon.ICursorState[];\n}\n\nexport const NOTEBOOK_EDITOR_CURSOR_BOUNDARY = new RawContextKey<'none' | 'top' | 'bottom' | 'both'>('notebookEditorCursorAtBoundary', 'none');\n\n\nexport interface INotebookLoadOptions {\n\t/**\n\t * Go to disk bypassing any cache of the model if any.\n\t */\n\tforceReadFromFile?: boolean;\n}\n\nexport interface IResolvedNotebookEditorModel extends INotebookEditorModel {\n\tnotebook: NotebookTextModel;\n}\n\nexport interface INotebookEditorModel extends IEditorModel {\n\treadonly onDidChangeDirty: Event<void>;\n\treadonly onDidSave: Event<IWorkingCopySaveEvent>;\n\treadonly onDidChangeOrphaned: Event<void>;\n\treadonly onDidChangeReadonly: Event<void>;\n\treadonly onDidRevertUntitled: Event<void>;\n\treadonly resource: URI;\n\treadonly viewType: string;\n\treadonly notebook: INotebookTextModel | undefined;\n\tisResolved(): this is IResolvedNotebookEditorModel;\n\tisDirty(): boolean;\n\tisModified(): boolean;\n\tisReadonly(): boolean | IMarkdownString;\n\tisOrphaned(): boolean;\n\thasAssociatedFilePath(): boolean;\n\tload(options?: INotebookLoadOptions): Promise<IResolvedNotebookEditorModel>;\n\tsave(options?: ISaveOptions): Promise<boolean>;\n\tsaveAs(target: URI): Promise<IUntypedEditorInput | undefined>;\n\trevert(options?: IRevertOptions): Promise<void>;\n}\n\nexport interface INotebookDiffEditorModel extends IEditorModel {\n\toriginal: IResolvedNotebookEditorModel;\n\tmodified: IResolvedNotebookEditorModel;\n}\n\nexport interface NotebookDocumentBackupData extends IWorkingCopyBackupMeta {\n\treadonly viewType: string;\n\treadonly backupId?: string;\n\treadonly mtime?: number;\n}\n\nexport enum NotebookEditorPriority {\n\tdefault = 'default',\n\toption = 'option',\n}\n\nexport interface INotebookSearchOptions {\n\tregex?: boolean;\n\twholeWord?: boolean;\n\tcaseSensitive?: boolean;\n\twordSeparators?: string;\n\tincludeMarkupInput?: boolean;\n\tincludeMarkupPreview?: boolean;\n\tincludeCodeInput?: boolean;\n\tincludeOutput?: boolean;\n}\n\nexport interface INotebookExclusiveDocumentFilter {\n\tinclude?: string | glob.IRelativePattern;\n\texclude?: string | glob.IRelativePattern;\n}\n\nexport interface INotebookDocumentFilter {\n\tviewType?: string | string[];\n\tfilenamePattern?: string | glob.IRelativePattern | INotebookExclusiveDocumentFilter;\n}\n\n//TODO@rebornix test\n\nexport function isDocumentExcludePattern(filenamePattern: string | glob.IRelativePattern | INotebookExclusiveDocumentFilter): filenamePattern is { include: string | glob.IRelativePattern; exclude: string | glob.IRelativePattern } {\n\tconst arg = filenamePattern as INotebookExclusiveDocumentFilter;\n\n\tif ((typeof arg.include === 'string' || glob.isRelativePattern(arg.include))\n\t\t&& (typeof arg.exclude === 'string' || glob.isRelativePattern(arg.exclude))) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nexport function notebookDocumentFilterMatch(filter: INotebookDocumentFilter, viewType: string, resource: URI): boolean {\n\tif (Array.isArray(filter.viewType) && filter.viewType.indexOf(viewType) >= 0) {\n\t\treturn true;\n\t}\n\n\tif (filter.viewType === viewType) {\n\t\treturn true;\n\t}\n\n\tif (filter.filenamePattern) {\n\t\tconst filenamePattern = isDocumentExcludePattern(filter.filenamePattern) ? filter.filenamePattern.include : (filter.filenamePattern as string | glob.IRelativePattern);\n\t\tconst excludeFilenamePattern = isDocumentExcludePattern(filter.filenamePattern) ? filter.filenamePattern.exclude : undefined;\n\n\t\tif (glob.match(filenamePattern, basename(resource.fsPath).toLowerCase())) {\n\t\t\tif (excludeFilenamePattern) {\n\t\t\t\tif (glob.match(excludeFilenamePattern, basename(resource.fsPath).toLowerCase())) {\n\t\t\t\t\t// should exclude\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport interface INotebookCellStatusBarItemProvider {\n\tviewType: string;\n\tonDidChangeStatusBarItems?: Event<void>;\n\tprovideCellStatusBarItems(uri: URI, index: number, token: CancellationToken): Promise<INotebookCellStatusBarItemList | undefined>;\n}\n\n\nexport interface INotebookDiffResult {\n\tcellsDiff: IDiffResult;\n\tlinesDiff?: { originalCellhandle: number; modifiedCellhandle: number; lineChanges: ILineChange[] }[];\n}\n\nexport interface INotebookCellStatusBarItem {\n\treadonly alignment: CellStatusbarAlignment;\n\treadonly priority?: number;\n\treadonly text: string;\n\treadonly color?: string | ThemeColor;\n\treadonly backgroundColor?: string | ThemeColor;\n\treadonly tooltip?: string | IMarkdownString;\n\treadonly command?: string | Command;\n\treadonly accessibilityInformation?: IAccessibilityInformation;\n\treadonly opacity?: string;\n\treadonly onlyShowWhenActive?: boolean;\n}\n\nexport interface INotebookCellStatusBarItemList {\n\titems: INotebookCellStatusBarItem[];\n\tdispose?(): void;\n}\n\nexport type ShowCellStatusBarType = 'hidden' | 'visible' | 'visibleAfterExecute';\n\nexport const NotebookSetting = {\n\tdisplayOrder: 'notebook.displayOrder',\n\tcellToolbarLocation: 'notebook.cellToolbarLocation',\n\tcellToolbarVisibility: 'notebook.cellToolbarVisibility',\n\tshowCellStatusBar: 'notebook.showCellStatusBar',\n\ttextDiffEditorPreview: 'notebook.diff.enablePreview',\n\tdiffOverviewRuler: 'notebook.diff.overviewRuler',\n\texperimentalInsertToolbarAlignment: 'notebook.experimental.insertToolbarAlignment',\n\tcompactView: 'notebook.compactView',\n\tfocusIndicator: 'notebook.cellFocusIndicator',\n\tinsertToolbarLocation: 'notebook.insertToolbarLocation',\n\tglobalToolbar: 'notebook.globalToolbar',\n\tundoRedoPerCell: 'notebook.undoRedoPerCell',\n\tconsolidatedOutputButton: 'notebook.consolidatedOutputButton',\n\tshowFoldingControls: 'notebook.showFoldingControls',\n\tdragAndDropEnabled: 'notebook.dragAndDropEnabled',\n\tcellEditorOptionsCustomizations: 'notebook.editorOptionsCustomizations',\n\tconsolidatedRunButton: 'notebook.consolidatedRunButton',\n\topenGettingStarted: 'notebook.experimental.openGettingStarted',\n\tglobalToolbarShowLabel: 'notebook.globalToolbarShowLabel',\n\tmarkupFontSize: 'notebook.markup.fontSize',\n\tinteractiveWindowCollapseCodeCells: 'interactiveWindow.collapseCellInputCode',\n\toutputScrollingDeprecated: 'notebook.experimental.outputScrolling',\n\toutputScrolling: 'notebook.output.scrolling',\n\ttextOutputLineLimit: 'notebook.output.textLineLimit',\n\tformatOnSave: 'notebook.formatOnSave.enabled',\n\tformatOnCellExecution: 'notebook.formatOnCellExecution',\n\tcodeActionsOnSave: 'notebook.codeActionsOnSave',\n\toutputWordWrap: 'notebook.output.wordWrap',\n\toutputLineHeightDeprecated: 'notebook.outputLineHeight',\n\toutputLineHeight: 'notebook.output.lineHeight',\n\toutputFontSizeDeprecated: 'notebook.outputFontSize',\n\toutputFontSize: 'notebook.output.fontSize',\n\toutputFontFamilyDeprecated: 'notebook.outputFontFamily',\n\toutputFontFamily: 'notebook.output.fontFamily',\n\tfindScope: 'notebook.find.scope',\n\tlogging: 'notebook.logging',\n\tconfirmDeleteRunningCell: 'notebook.confirmDeleteRunningCell',\n} as const;\n\nexport const enum CellStatusbarAlignment {\n\tLeft = 1,\n\tRight = 2\n}\n\nexport class NotebookWorkingCopyTypeIdentifier {\n\n\tprivate static _prefix = 'notebook/';\n\n\tstatic create(viewType: string): string {\n\t\treturn `${NotebookWorkingCopyTypeIdentifier._prefix}${viewType}`;\n\t}\n\n\tstatic parse(candidate: string): string | undefined {\n\t\tif (candidate.startsWith(NotebookWorkingCopyTypeIdentifier._prefix)) {\n\t\t\treturn candidate.substring(NotebookWorkingCopyTypeIdentifier._prefix.length);\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport interface NotebookExtensionDescription {\n\treadonly id: ExtensionIdentifier;\n\treadonly location: UriComponents | undefined;\n}\n\n/**\n * Whether the provided mime type is a text stream like `stdout`, `stderr`.\n */\nexport function isTextStreamMime(mimeType: string) {\n\treturn ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);\n}\n\n\nconst textDecoder = new TextDecoder();\n\n/**\n * Given a stream of individual stdout outputs, this function will return the compressed lines, escaping some of the common terminal escape codes.\n * E.g. some terminal escape codes would result in the previous line getting cleared, such if we had 3 lines and\n * last line contained such a code, then the result string would be just the first two lines.\n */\nexport function compressOutputItemStreams(outputs: Uint8Array[]) {\n\tconst buffers: Uint8Array[] = [];\n\tlet startAppending = false;\n\n\t// Pick the first set of outputs with the same mime type.\n\tfor (const output of outputs) {\n\t\tif ((buffers.length === 0 || startAppending)) {\n\t\t\tbuffers.push(output);\n\t\t\tstartAppending = true;\n\t\t}\n\t}\n\tcompressStreamBuffer(buffers);\n\treturn formatStreamText(VSBuffer.concat(buffers.map(buffer => VSBuffer.wrap(buffer))));\n}\nconst MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;\nconst MOVE_CURSOR_1_LINE_COMMAND_BYTES = MOVE_CURSOR_1_LINE_COMMAND.split('').map(c => c.charCodeAt(0));\nconst LINE_FEED = 10;\nfunction compressStreamBuffer(streams: Uint8Array[]) {\n\tstreams.forEach((stream, index) => {\n\t\tif (index === 0 || stream.length < MOVE_CURSOR_1_LINE_COMMAND.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst previousStream = streams[index - 1];\n\n\t\t// Remove the previous line if required.\n\t\tconst command = stream.subarray(0, MOVE_CURSOR_1_LINE_COMMAND.length);\n\t\tif (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {\n\t\t\tconst lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);\n\t\t\tif (lastIndexOfLineFeed === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstreams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);\n\t\t\tstreams[index] = stream.subarray(MOVE_CURSOR_1_LINE_COMMAND.length);\n\t\t}\n\t});\n}\n\n\n\n/**\n * Took this from jupyter/notebook\n * https://github.com/jupyter/notebook/blob/b8b66332e2023e83d2ee04f83d8814f567e01a4e/notebook/static/base/js/utils.js\n * Remove characters that are overridden by backspace characters\n */\nfunction fixBackspace(txt: string) {\n\tlet tmp = txt;\n\tdo {\n\t\ttxt = tmp;\n\t\t// Cancel out anything-but-newline followed by backspace\n\t\ttmp = txt.replace(/[^\\n]\\x08/gm, '');\n\t} while (tmp.length < txt.length);\n\treturn txt;\n}\n\n/**\n * Remove chunks that should be overridden by the effect of carriage return characters\n * From https://github.com/jupyter/notebook/blob/master/notebook/static/base/js/utils.js\n */\nfunction fixCarriageReturn(txt: string) {\n\ttxt = txt.replace(/\\r+\\n/gm, '\\n'); // \\r followed by \\n --> newline\n\twhile (txt.search(/\\r[^$]/g) > -1) {\n\t\tconst base = txt.match(/^(.*)\\r+/m)![1];\n\t\tlet insert = txt.match(/\\r+(.*)$/m)![1];\n\t\tinsert = insert + base.slice(insert.length, base.length);\n\t\ttxt = txt.replace(/\\r+.*$/m, '\\r').replace(/^.*\\r/m, insert);\n\t}\n\treturn txt;\n}\n\nconst BACKSPACE_CHARACTER = '\\b'.charCodeAt(0);\nconst CARRIAGE_RETURN_CHARACTER = '\\r'.charCodeAt(0);\nfunction formatStreamText(buffer: VSBuffer): VSBuffer {\n\t// We have special handling for backspace and carriage return characters.\n\t// Don't unnecessary decode the bytes if we don't need to perform any processing.\n\tif (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {\n\t\treturn buffer;\n\t}\n\t// Do the same thing jupyter is doing\n\treturn VSBuffer.fromString(fixCarriageReturn(fixBackspace(textDecoder.decode(buffer.buffer))));\n}\n\nexport interface INotebookKernelSourceAction {\n\treadonly label: string;\n\treadonly description?: string;\n\treadonly detail?: string;\n\treadonly command?: string | Command;\n\treadonly documentation?: UriComponents | string;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ISequence, LcsDiff } from 'vs/base/common/diff/diff';\nimport { doHash, hash, numberHash } from 'vs/base/common/hash';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport * as model from 'vs/editor/common/model';\nimport { PieceTreeTextBufferBuilder } from 'vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder';\nimport { CellKind, ICellDto2, IMainCellDto, INotebookDiffResult, IOutputDto, NotebookCellInternalMetadata, NotebookCellMetadata, NotebookCellsChangedEventDto, NotebookCellsChangeType, NotebookCellTextModelSplice, NotebookData, NotebookDocumentMetadata } from 'vs/workbench/contrib/notebook/common/notebookCommon';\nimport { Range } from 'vs/editor/common/core/range';\nimport { INotebookWorkerHost } from 'vs/workbench/contrib/notebook/common/services/notebookWorkerHost';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\nfunction bufferHash(buffer: VSBuffer): number {\n\tlet initialHashVal = numberHash(104579, 0);\n\tfor (let k = 0; k < buffer.buffer.length; k++) {\n\t\tinitialHashVal = doHash(buffer.buffer[k], initialHashVal);\n\t}\n\n\treturn initialHashVal;\n}\n\nclass MirrorCell {\n\tprivate _textBuffer!: model.IReadonlyTextBuffer;\n\n\tget textBuffer() {\n\t\tif (this._textBuffer) {\n\t\t\treturn this._textBuffer;\n\t\t}\n\n\t\tconst builder = new PieceTreeTextBufferBuilder();\n\t\tbuilder.acceptChunk(Array.isArray(this._source) ? this._source.join('\\n') : this._source);\n\t\tconst bufferFactory = builder.finish(true);\n\t\tthis._textBuffer = bufferFactory.create(model.DefaultEndOfLine.LF).textBuffer;\n\n\t\treturn this._textBuffer;\n\t}\n\n\tprivate _primaryKey?: number | null = null;\n\tprimaryKey(): number | null {\n\t\tif (this._primaryKey === undefined) {\n\t\t\tthis._primaryKey = hash(this.getValue());\n\t\t}\n\n\t\treturn this._primaryKey;\n\t}\n\n\tprivate _hash: number | null = null;\n\n\tconstructor(\n\t\treadonly handle: number,\n\t\tprivate _source: string | string[],\n\t\tpublic language: string,\n\t\tpublic cellKind: CellKind,\n\t\tpublic outputs: IOutputDto[],\n\t\tpublic metadata?: NotebookCellMetadata,\n\t\tpublic internalMetadata?: NotebookCellInternalMetadata,\n\n\t) { }\n\n\tgetFullModelRange() {\n\t\tconst lineCount = this.textBuffer.getLineCount();\n\t\treturn new Range(1, 1, lineCount, this.textBuffer.getLineLength(lineCount) + 1);\n\t}\n\n\tgetValue(): string {\n\t\tconst fullRange = this.getFullModelRange();\n\t\treturn this.textBuffer.getValueInRange(fullRange, model.EndOfLinePreference.LF);\n\t}\n\n\tgetComparisonValue(): number {\n\t\tif (this._primaryKey !== null) {\n\t\t\treturn this._primaryKey!;\n\t\t}\n\n\t\tthis._hash = hash([hash(this.language), hash(this.getValue()), this.metadata, this.internalMetadata, this.outputs.map(op => ({\n\t\t\toutputs: op.outputs.map(output => ({\n\t\t\t\tmime: output.mime,\n\t\t\t\tdata: bufferHash(output.data)\n\t\t\t})),\n\t\t\tmetadata: op.metadata\n\t\t}))]);\n\t\treturn this._hash;\n\t}\n\n\tgetHashValue() {\n\t\tif (this._hash !== null) {\n\t\t\treturn this._hash;\n\t\t}\n\n\t\tthis._hash = hash([hash(this.getValue()), this.language, this.metadata, this.internalMetadata]);\n\t\treturn this._hash;\n\t}\n}\n\nclass MirrorNotebookDocument {\n\tconstructor(\n\t\treadonly uri: URI,\n\t\tpublic cells: MirrorCell[],\n\t\tpublic metadata: NotebookDocumentMetadata,\n\t) {\n\t}\n\n\tacceptModelChanged(event: NotebookCellsChangedEventDto) {\n\t\t// note that the cell content change is not applied to the MirrorCell\n\t\t// but it's fine as if a cell content is modified after the first diff, its position will not change any more\n\t\t// TODO@rebornix, but it might lead to interesting bugs in the future.\n\t\tevent.rawEvents.forEach(e => {\n\t\t\tif (e.kind === NotebookCellsChangeType.ModelChange) {\n\t\t\t\tthis._spliceNotebookCells(e.changes);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Move) {\n\t\t\t\tconst cells = this.cells.splice(e.index, 1);\n\t\t\t\tthis.cells.splice(e.newIdx, 0, ...cells);\n\t\t\t} else if (e.kind === NotebookCellsChangeType.Output) {\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.outputs = e.outputs;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellLanguage) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.language = e.language;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.metadata = e.metadata;\n\t\t\t} else if (e.kind === NotebookCellsChangeType.ChangeCellInternalMetadata) {\n\t\t\t\tthis._assertIndex(e.index);\n\t\t\t\tconst cell = this.cells[e.index];\n\t\t\t\tcell.internalMetadata = e.internalMetadata;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _assertIndex(index: number): void {\n\t\tif (index < 0 || index >= this.cells.length) {\n\t\t\tthrow new Error(`Illegal index ${index}. Cells length: ${this.cells.length}`);\n\t\t}\n\t}\n\n\t_spliceNotebookCells(splices: NotebookCellTextModelSplice<IMainCellDto>[]) {\n\t\tsplices.reverse().forEach(splice => {\n\t\t\tconst cellDtos = splice[2];\n\t\t\tconst newCells = cellDtos.map(cell => {\n\t\t\t\treturn new MirrorCell(\n\t\t\t\t\t(cell as unknown as IMainCellDto).handle,\n\t\t\t\t\tcell.source,\n\t\t\t\t\tcell.language,\n\t\t\t\t\tcell.cellKind,\n\t\t\t\t\tcell.outputs,\n\t\t\t\t\tcell.metadata\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tthis.cells.splice(splice[0], splice[1], ...newCells);\n\t\t});\n\t}\n}\n\nclass CellSequence implements ISequence {\n\n\tconstructor(readonly textModel: MirrorNotebookDocument) {\n\t}\n\n\tgetElements(): string[] | number[] | Int32Array {\n\t\tconst hashValue = new Int32Array(this.textModel.cells.length);\n\t\tfor (let i = 0; i < this.textModel.cells.length; i++) {\n\t\t\thashValue[i] = this.textModel.cells[i].getComparisonValue();\n\t\t}\n\n\t\treturn hashValue;\n\t}\n\n\tgetCellHash(cell: ICellDto2) {\n\t\tconst source = Array.isArray(cell.source) ? cell.source.join('\\n') : cell.source;\n\t\tconst hashVal = hash([hash(source), cell.metadata]);\n\t\treturn hashVal;\n\t}\n}\n\nexport class NotebookEditorSimpleWorker implements IRequestHandler, IDisposable {\n\t_requestHandlerBrand: any;\n\n\tprivate _models: { [uri: string]: MirrorNotebookDocument };\n\n\tconstructor() {\n\t\tthis._models = Object.create(null);\n\t}\n\tdispose(): void {\n\t}\n\n\tpublic acceptNewModel(uri: string, data: NotebookData): void {\n\t\tthis._models[uri] = new MirrorNotebookDocument(URI.parse(uri), data.cells.map(dto => new MirrorCell(\n\t\t\t(dto as unknown as IMainCellDto).handle,\n\t\t\tdto.source,\n\t\t\tdto.language,\n\t\t\tdto.cellKind,\n\t\t\tdto.outputs,\n\t\t\tdto.metadata\n\t\t)), data.metadata);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, event: NotebookCellsChangedEventDto) {\n\t\tconst model = this._models[strURL];\n\t\tmodel?.acceptModelChanged(event);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\tcomputeDiff(originalUrl: string, modifiedUrl: string): INotebookDiffResult {\n\t\tconst original = this._getModel(originalUrl);\n\t\tconst modified = this._getModel(modifiedUrl);\n\n\t\tconst diff = new LcsDiff(new CellSequence(original), new CellSequence(modified));\n\t\tconst diffResult = diff.ComputeDiff(false);\n\n\t\t/* let cellLineChanges: { originalCellhandle: number, modifiedCellhandle: number, lineChanges: ILineChange[] }[] = [];\n\n\t\tdiffResult.changes.forEach(change => {\n\t\t\tif (change.modifiedLength === 0) {\n\t\t\t\t// deletion ...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (change.originalLength === 0) {\n\t\t\t\t// insertion\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0, len = Math.min(change.modifiedLength, change.originalLength); i < len; i++) {\n\t\t\t\tlet originalIndex = change.originalStart + i;\n\t\t\t\tlet modifiedIndex = change.modifiedStart + i;\n\n\t\t\t\tconst originalCell = original.cells[originalIndex];\n\t\t\t\tconst modifiedCell = modified.cells[modifiedIndex];\n\n\t\t\t\tif (originalCell.getValue() !== modifiedCell.getValue()) {\n\t\t\t\t\t// console.log(`original cell ${originalIndex} content change`);\n\t\t\t\t\tconst originalLines = originalCell.textBuffer.getLinesContent();\n\t\t\t\t\tconst modifiedLines = modifiedCell.textBuffer.getLinesContent();\n\t\t\t\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\t\t\t\tshouldComputeCharChanges: true,\n\t\t\t\t\t\tshouldPostProcessCharChanges: true,\n\t\t\t\t\t\tshouldIgnoreTrimWhitespace: false,\n\t\t\t\t\t\tshouldMakePrettyDiff: true,\n\t\t\t\t\t\tmaxComputationTime: 5000\n\t\t\t\t\t});\n\n\t\t\t\t\tconst lineChanges = diffComputer.computeDiff().changes;\n\n\t\t\t\t\tcellLineChanges.push({\n\t\t\t\t\t\toriginalCellhandle: originalCell.handle,\n\t\t\t\t\t\tmodifiedCellhandle: modifiedCell.handle,\n\t\t\t\t\t\tlineChanges\n\t\t\t\t\t});\n\n\t\t\t\t\t// console.log(lineDecorations);\n\n\t\t\t\t} else {\n\t\t\t\t\t// console.log(`original cell ${originalIndex} metadata change`);\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n */\n\t\treturn {\n\t\t\tcellsDiff: diffResult,\n\t\t\t// linesDiff: cellLineChanges\n\t\t};\n\t}\n\n\tprotected _getModel(uri: string): MirrorNotebookDocument {\n\t\treturn this._models[uri];\n\t}\n}\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: INotebookWorkerHost): IRequestHandler {\n\treturn new NotebookEditorSimpleWorker();\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","$gi","map","key","value","exports","$hi","entries","$ii","set","ResourceMapEntry","uri","$ji","mapOrKeyFn","toKey","_a","resource","clb","thisArg","_","entry","$ki","entriesOrKey","_b","callbackfn","_value","Touch","$li","_c","touch","item","state","current","iterator","newSize","currentSize","next","previous","data","$mi","limit","ratio","$ni","counter","mapExtToTextMimes","mapExtToMediaMimes","$sr","path","ext","path_1","textMime","$tr","$ur","mimeType","extension","_simplePattern","$vr","strict","match","$tb","obj","candidate","$ub","fn","$vb","$wb","reducer","options","WriteableStreamImpl","e","f","resolve","error","listener","errors_1","event","callback","listeners","index","fullDataBuffer","pendingWritePromises","pendingWritePromise","$xb","readable","chunks","chunk","$yb","maxChunks","lastReadChunk","$zb","stream","reject","$Ab","destroyed","lifecycle_1","$Bb","streamListeners","buffer","dataListener","errorListener","endListener","$Cb","t","$Db","$Eb","consumed","$Fb","transformer","target","$Gb","prefix","prefixHandled","$Hb","hasBuffer","indexOfTable","lazy_1","textEncoder","textDecoder","$Ib","byteLength","actual","source","buffers","totalLength","ret","offset","element","start","end","array","$Lb","$Mb","$Nb","$Ob","$Pb","$Qb","subarray","needle","needleLen","haystack","haystackLen","table","j","$Jb","$Kb","destination","$Rb","streams","$Sb","$Tb","$Ub","bufferedStream","$Vb","$Wb","$Xb","$Yb","$Zb","$1b","encoded","building","remainder","bufi","append","code","unpadded","base64Alphabet","base64UrlSafeAlphabet","$2b","padded","urlSafe","dictionary","output","a","b","c","$Ae","$Be","osPath","$Ce","$De","sep","firstLetter","pos","$Ie","$Ee","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","$Fe","name","isWindowsOS","invalidFileChars","$Ge","pathA","pathB","ignoreCase","identityEquals","strings_1","$He","base","parentCandidate","separator","sepOffset","char0","$Je","cwd","$Ke","pathNormalized","$Le","$Me","$Ne","$Oe","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","$Pe","parent","randomLength","suffix","pathCharsTouse","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","$Tf","$Uf","uri1","uri2","ignoreFragment","network_1","extpath","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","$cg","items","resourceAccessor","distinctParents","candidateResource","otherItem","DataUri","parseMetaData","dataUri","metadata","property","mime","$dg","localScheme","$eg","$fg","cancellation_1","thenable","promise","subscription","onfinally","$gg","token","defaultValue","ref","$hg","$ig","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","$jg","timeout","onTimeout","promiseResolve","timer","$kg","$lg","promiseFactory","onComplete","$mg","promiseTask","$ng","newPromise","timeoutDeferred","scheduled","handle","microtaskDeferred","$og","defaultDelay","task","delay","symbols_1","$pg","$qg","$rg","autoOpenTimeMs","$sg","millis","disposable","$tg","handler","$ug","promiseFactories","results","thenHandler","n","$vg","shouldStop","loop","factory","$wg","promiseList","todo","finish","$xg","maxDegreeOfParalellism","event_1","iLimitedTask","$yg","$zg","$Lg","queue","extUri","resources_1","drainer","$Ag","runner","$Bg","interval","$Cg","$Dg","$Eg","unit","units","$Fg","g","h","disposed","$Hg","executor","$Ig","retries","lastError","$Jg","taskId","onCancel","run","promiseReject","$Kg","d","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","$Mg","writer","emitter","iterables","iterable","mapFn","filterFn","values","$Ng","l","$Og","innerIterable","$8i","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","$$i","pattern","splitChar","inBraces","inBrackets","curVal","char","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","res","braceRegExp","choice","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","patternKey","parsedPattern","wrapRelativePattern","trivia1","trimForExclusions","trivia2","trivia3","trivia4and5","toRegExp","arg2","wrappedPattern","basename","extpath_1","slashBase","backslashBase","basenames","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","allPaths","all","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","regExp","$_i","hasSibling","$aj","$bj","resultPattern","parsedExpression","rp","$cj","patternOrExpression","$dj","expression","parseExpressionPattern","resultExpression","resultPromises","async_1","resultPromise","when","clausePattern","matched","basenamePatterns","patterns","aggregate","ch","aggregatedPatterns","$ej","patternsA","patternsB","arrays_1","StringEOL","$cs","text","eolCount","firstLineLength","lastLineStart","eol","chr","_utf16LE_TextDecoder","getUTF16LE_TextDecoder","_utf16BE_TextDecoder","getUTF16BE_TextDecoder","_platformTextDecoder","$Ur","$Vr","view","compatDecodeUTF16LE","resultLen","charCode","$Wr","capacity","bufferString","remainingSpace","strings","str","strLen","escapeNewLine","$Xr","oldPosition","oldText","newPosition","newText","stringBuilder_1","dest","$Yr","prevEdits","currEdits","TextChangeCompressor","prevIndex","currIndex","prevEdit","currEdit","e1","e2","mergePrev","mergeCurr","merged","prevDeltaOffset","currDeltaOffset","edit","preText","postText","edits","prev","curr","$vB","piece","color","$xB","node","$yB","NodeColor","calculateSize","calculateLF","resetSentinel","$zB","tree","x","y","$AB","$BB","z","yWasRed","$EB","newSizeLeft","newLFLeft","delta","lf_delta","$DB","w","$CB","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","r","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","$LB","readonly","rLength","$MB","$NB","bufferIndex","lineFeedCnt","length","$OB","PieceTreeSnapshot","BOM","rbTreeBase_1","PieceTreeSearchCache","nodePos","lineNumber","nodePosition","hasInvalidVal","tmp","newArr","$PB","eolNormalized","lastNode","averageBufferSize","min","max","tempChunk","tempChunkLen","newEOL","other","startPosition","endPosition","val","leftLen","accumualtedValInCurrentIndex","lfCnt","originalOffset","out","lineStartOffset","position_1","range","startOffset","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","matchingNode","targetOffset","searcher","startLineNumber","startColumn","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","m","searchText","offsetInBuffer","retStartColumn","retEndColumn","textModelSearch_1","range_1","searchRange","currentNode","lineBreakCnt","nextLineStartOffset","deltaOffset","wordSeparators","searchString","searchStringLen","textLength","lastMatchIndex","model_1","nodeStartOffset","insertPosInBuffer","nodesToDel","newRightPiece","newStart","previousPos","newPieces","tmpNode","k","pieces","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","secondNode","nPiece","newNode","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","endIndex","endColumn","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","oldLineFeedCnt","prevAccumualtedValue","newOffset","nextNode","prevNewLength","prevNewLFCnt","leftRet","prevNode","$QB","containsRTL","containsUnusualLineTerminators","pieceTreeBase_1","preserveBOM","lineEnding","eolOffsetCompensation","desiredEOL","actualEOL","fromLineNumber","toLineNumber","lineContent","fromOffset","toOffset","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","op","validatedRange","textMightContainNonBasicASCII","validText","lastLineLength","strEOL","eolCounter_1","bufferEOL","hasTouchingRanges","count","rangeEnd","nextRangeStart","reverseRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange_1","contentChanges","trimAutoWhitespaceLineNumbers","prevContent","forceMoveMarkers","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","endLineNumber","contentChangeRange","resultRange","lineCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","PieceTreeTextBufferFactory","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","pieceTreeTextBuffer_1","lengthLimit","$RB","allowEmptyStrings","normalizeEOL","lastChunk","newLineStarts","nls","TokenType","hintDidYouMean","meant","nls_1","hintDidYouForgetToOpenOrCloseQuote","hintDidYouForgetToEscapeSlash","$oi","isTripleEq","expected","type","additional","lexeme","errToken","keyword","inEscape","inCharacterClass","_util","getServiceDependencies","ctor","$lh","storeServiceDependency","id","serviceId","$mh","serviceIdentifier","CONSTANT_VALUES","$pi","hasOwnProperty","ContextKeyExprType","defaultConfig","errorEmptyString","hintEmptyString","errorNoInAfterNot","errorClosingParenthesis","errorUnexpectedToken","hintUnexpectedToken","errorUnexpectedEOF","hintUnexpectedEOF","$qi","scanner_1","input","expr","peek","additionalInfo","right","$ri","$ui","$vi","$Bi","regexLexeme","closingSlashIndex","flags","regexp","$Gi","lexemeReconstruction","followingToken","parenBalance","serializedValue","regex","caseIgnoreFlag","$Ei","$Fi","$Ci","$Di","message","got","$wi","$xi","$Ai","$yi","$zi","$Ii","$Ji","serialized","$si","whenClauses","parser","whenClause","se","pe","$ti","aExpr","bExpr","cmp","context","mapFnc","negated","constantValue","cmp1","cmp2","trueValue","valueKey","falseValue","withFloatOrStr","thisSource","otherSource","$Hi","eliminateConstantsInArray","newExpr","_expr","extraRedundantCheck","exprArr","hasTrue","lastElement","secondToLastElement","isFinished","resultElement","el","hasFalse","LEFT","RIGHT","left","getTerminals","$Ki","metaOrHide","instantiation_1","key1","key2","value1","value2","$Mi","q","allElementsIncluded","pIndex","qIndex","CellKind","mime_1","NotebookRunState","NotebookCellExecutionState","NotebookExecutionState","NotebookRendererMatch","RendererMessagingSpec","NotebookCellsChangeType","SelectionStateType","CellEditType","CellUri","_lengths","_padRegexp","_radix","generate","notebook","s","fragment","buffer_1","parse","cell","idx","_scheme","generateCellOutputUri","outputId","parseCellOutputUri","scheme","generateCellPropertyUri","parseCellPropertyUri","propertyScheme","normalizeSlashes","$aH","initialValue","glob","mimetypes","remaining","iterator_1","sorted","matches","original","normalized","chosenMimetype","otherMimetypes","chosenIndex","uniqueIndicies","otherIndices","oi","o","maxIndex","$bH","before","after","contains","equal","pushSplice","deleteCount","toInsert","latest","beforeIdx","afterIdx","beforeElement","afterElement","contextkey_1","NotebookEditorPriority","$dH","filenamePattern","arg","$eH","filter","viewType","excludeFilenamePattern","CellStatusbarAlignment","$gH","$hH","$iH","outputs","startAppending","compressStreamBuffer","formatStreamText","MOVE_CURSOR_1_LINE_COMMAND","MOVE_CURSOR_1_LINE_COMMAND_BYTES","LINE_FEED","previousStream","command","lastIndexOfLineFeed","fixBackspace","txt","fixCarriageReturn","insert","BACKSPACE_CHARACTER","CARRIAGE_RETURN_CHARACTER","bufferHash","initialHashVal","hash_1","MirrorCell","builder","pieceTreeTextBufferBuilder_1","bufferFactory","language","cellKind","internalMetadata","fullRange","MirrorNotebookDocument","cells","notebookCommon_1","splices","splice","newCells","CellSequence","textModel","hashValue","NotebookEditorSimpleWorker","dto","strURL","originalUrl","modifiedUrl","modified","diff_1","create"],"file":"notebookSimpleWorker.js"}
{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/search/worker/fake","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/map.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/getFileResults.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/ignoreFile.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/worker/localFileSearch.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new Error('Throttler is disposed');\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface INextTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithNextTask {\n\treadonly next: INextTask;\n}\n\nexport class TaskSequentializer {\n\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: INextTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending?.promise;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n\n\thasNext(): this is ITaskSequentializerWithNextTask {\n\t\treturn !!this._next;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._next?.promise ?? this._pending?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters, ltrim } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchResult } from 'vs/workbench/services/search/common/search';\nimport { TextSearchPreviewOptions } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { Range } from 'vs/editor/common/core/range';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tbeforeContext: number;\n\t\tafterContext: number;\n\t\tpreviewOptions: TextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndecies: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndecies.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndecies.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndecies) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.beforeContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.beforeContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchResult = {\n\t\t\t\tranges: fileRange,\n\t\t\t\tpreview: { text: previewText, matches: previewRange },\n\t\t\t};\n\t\t\tresults.push(match);\n\n\t\t\tif (options.afterContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.afterContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\n\n\nexport class IgnoreFile {\n\n\tprivate isPathIgnored: (path: string, isDir: boolean, parent?: IgnoreFile) => boolean;\n\n\tconstructor(\n\t\tcontents: string,\n\t\tprivate readonly location: string,\n\t\tprivate readonly parent?: IgnoreFile) {\n\t\tif (location[location.length - 1] === '\\\\') {\n\t\t\tthrow Error('Unexpected path format, do not use trailing backslashes');\n\t\t}\n\t\tif (location[location.length - 1] !== '/') {\n\t\t\tlocation += '/';\n\t\t}\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Updates the contents of the ignorefile. Preservering the location and parent\n\t * @param contents The new contents of the gitignore file\n\t */\n\tupdateContents(contents: string) {\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Returns true if a path in a traversable directory has not been ignored.\n\t *\n\t * Note: For performance reasons this does not check if the parent directories have been ignored,\n\t * so it should always be used in tandem with `shouldTraverseDir` when walking a directory.\n\t *\n\t * In cases where a path must be tested in isolation, `isArbitraryPathIncluded` should be used.\n\t */\n\tisPathIncludedInTraversal(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst ignored = this.isPathIgnored(path, isDir);\n\n\t\treturn !ignored;\n\t}\n\n\t/**\n\t * Returns true if an arbitrary path has not been ignored.\n\t * This is an expensive operation and should only be used ouside of traversals.\n\t */\n\tisArbitraryPathIgnored(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst segments = path.split('/').filter(x => x);\n\t\tlet ignored = false;\n\n\t\tlet walkingPath = '';\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst isLast = i === segments.length - 1;\n\t\t\tconst segment = segments[i];\n\n\t\t\twalkingPath = walkingPath + '/' + segment;\n\n\t\t\tif (!this.isPathIncludedInTraversal(walkingPath, isLast ? isDir : true)) {\n\t\t\t\tignored = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ignored;\n\t}\n\n\tprivate gitignoreLinesToExpression(lines: string[], dirPath: string, trimForExclusions: boolean): glob.ParsedExpression {\n\t\tconst includeLines = lines.map(line => this.gitignoreLineToGlob(line, dirPath));\n\n\t\tconst includeExpression: glob.IExpression = Object.create(null);\n\t\tfor (const line of includeLines) {\n\t\t\tincludeExpression[line] = true;\n\t\t}\n\n\t\treturn glob.parse(includeExpression, { trimForExclusions });\n\t}\n\n\n\tprivate parseIgnoreFile(ignoreContents: string, dirPath: string, parent: IgnoreFile | undefined): (path: string, isDir: boolean) => boolean {\n\t\tconst contentLines = ignoreContents\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim())\n\t\t\t.filter(line => line && line[0] !== '#');\n\n\t\t// Pull out all the lines that end with `/`, those only apply to directories\n\t\tconst fileLines = contentLines.filter(line => !line.endsWith('/'));\n\n\t\tconst fileIgnoreLines = fileLines.filter(line => !line.includes('!'));\n\t\tconst isFileIgnored = this.gitignoreLinesToExpression(fileIgnoreLines, dirPath, true);\n\n\t\t// TODO: Slight hack... this naieve approach may reintroduce too many files in cases of weirdly complex .gitignores\n\t\tconst fileIncludeLines = fileLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isFileIncluded = this.gitignoreLinesToExpression(fileIncludeLines, dirPath, false);\n\n\t\t// When checking if a dir is ignored we can use all lines\n\t\tconst dirIgnoreLines = contentLines.filter(line => !line.includes('!'));\n\t\tconst isDirIgnored = this.gitignoreLinesToExpression(dirIgnoreLines, dirPath, true);\n\n\t\t// Same hack.\n\t\tconst dirIncludeLines = contentLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isDirIncluded = this.gitignoreLinesToExpression(dirIncludeLines, dirPath, false);\n\n\t\tconst isPathIgnored = (path: string, isDir: boolean) => {\n\t\t\tif (!path.startsWith(dirPath)) { return false; }\n\t\t\tif (isDir && isDirIgnored(path) && !isDirIncluded(path)) { return true; }\n\t\t\tif (isFileIgnored(path) && !isFileIncluded(path)) { return true; }\n\n\t\t\tif (parent) { return parent.isPathIgnored(path, isDir); }\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn isPathIgnored;\n\t}\n\n\tprivate gitignoreLineToGlob(line: string, dirPath: string): string {\n\t\tconst firstSep = line.indexOf('/');\n\t\tif (firstSep === -1 || firstSep === line.length - 1) {\n\t\t\tline = '**/' + line;\n\t\t} else {\n\t\t\tif (firstSep === 0) {\n\t\t\t\tif (dirPath.slice(-1) === '/') {\n\t\t\t\t\tline = line.slice(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirPath.slice(-1) !== '/') {\n\t\t\t\t\tline = '/' + line;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = dirPath + line;\n\t\t}\n\n\t\treturn line;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\nimport { UriComponents, URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { ILocalFileSearchSimpleWorker, ILocalFileSearchSimpleWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from 'vs/workbench/services/search/common/localFileSearchWorkerTypes';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from 'vs/workbench/services/search/common/search';\nimport * as paths from 'vs/base/common/path';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { getFileResults } from 'vs/workbench/services/search/common/getFileResults';\nimport { IgnoreFile } from 'vs/workbench/services/search/common/ignoreFile';\nimport { createRegExp } from 'vs/base/common/strings';\nimport { Promises } from 'vs/base/common/async';\nimport { ExtUri } from 'vs/base/common/resources';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: ILocalFileSearchSimpleWorkerHost): IRequestHandler {\n\treturn new LocalFileSearchSimpleWorker(host);\n}\n\nexport class LocalFileSearchSimpleWorker implements ILocalFileSearchSimpleWorker, IRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(private host: ILocalFileSearchSimpleWorkerHost) { }\n\n\tcancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tafterContext: query.afterContext ?? 0,\n\t\t\t\t\tbeforeContext: query.beforeContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => any, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = glob.parse(folderQuery.excludePattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression;\n\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => any) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn {\n\t\t...folderQuery,\n\t\tfolder: URI.revive(folderQuery.folder),\n\t};\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","$gi","map","key","value","exports","$hi","entries","$ii","set","ResourceMapEntry","uri","$ji","mapOrKeyFn","toKey","_a","resource","clb","thisArg","_","entry","$ki","entriesOrKey","_b","callbackfn","_value","Touch","$li","_c","touch","item","state","current","iterator","newSize","currentSize","next","previous","data","$mi","limit","ratio","$ni","counter","$Ae","code","$Be","osPath","path_1","$Ce","$De","path","sep","firstLetter","pos","start","$Ie","$Ee","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","$Fe","name","isWindowsOS","invalidFileChars","$Ge","pathA","pathB","ignoreCase","identityEquals","strings_1","$He","base","parentCandidate","separator","sepOffset","char0","$Je","candidate","cwd","$Ke","pathNormalized","$Le","$Me","$Ne","$Oe","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","$Pe","parent","prefix","randomLength","suffix","pathCharsTouse","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","$Tf","$Uf","a","uri1","uri2","ignoreFragment","network_1","extpath","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","$cg","items","resourceAccessor","distinctParents","candidateResource","otherItem","index","DataUri","parseMetaData","dataUri","metadata","property","mime","$dg","localScheme","$eg","obj","$fg","callback","source","cancellation_1","thenable","promise","resolve","reject","subscription","errors_1","onfinally","$gg","token","defaultValue","ref","$hg","$ig","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","$jg","timeout","onTimeout","promiseResolve","timer","$kg","$lg","promiseFactory","onComplete","$mg","promiseTask","$ng","newPromise","timeoutDeferred","fn","scheduled","handle","microtaskDeferred","$og","defaultDelay","task","delay","symbols_1","$pg","$qg","c","e","$rg","autoOpenTimeMs","$sg","millis","disposable","$tg","handler","lifecycle_1","$ug","promiseFactories","results","thenHandler","n","$vg","shouldStop","t","loop","factory","$wg","promiseList","todo","finish","$xg","maxDegreeOfParalellism","event_1","iLimitedTask","$yg","$zg","$Lg","queue","extUri","resources_1","drainer","$Ag","runner","$Bg","interval","$Cg","$Dg","$Eg","unit","units","$Fg","g","h","disposed","end","$Hg","executor","$Ig","retries","lastError","error","$Jg","taskId","onCancel","run","promiseReject","$Kg","d","f","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","$Mg","writer","emitter","iterables","iterable","mapFn","filterFn","values","$Ng","l","$Og","innerIterable","$8i","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","$$i","pattern","splitChar","inBraces","inBrackets","curVal","char","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","res","braceRegExp","choice","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","parsedPattern","wrapRelativePattern","match","trivia1","trimForExclusions","trivia2","trivia3","trivia4and5","toRegExp","arg2","wrappedPattern","basename","extpath_1","slashBase","backslashBase","basenames","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","allPaths","all","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","regExp","$_i","hasSibling","$aj","$bj","resultPattern","parsedExpression","rp","$cj","patternOrExpression","$dj","expression","parseExpressionPattern","resultExpression","resultPromises","async_1","resultPromise","when","clausePattern","matched","basenamePatterns","patterns","aggregate","ch","aggregatedPatterns","$ej","patternsA","patternsB","arrays_1","b","$6cc","bytes","text","patternIndecies","patternMatch","remainingResultQuota","contextLinesNeeded","resultLines","lineRanges","readLine","lineNumber","prevLineEnd","lineEndingMatch","lineEndRegex","startLine","matchStartIndex","matchedText","endLine","contextLine","previewText","offset","matchLine","previewLine","fileRange","range_1","previewRange","$wIb","contents","isDir","x","ignored","walkingPath","isLast","lines","dirPath","includeLines","includeExpression","glob","ignoreContents","contentLines","fileLines","fileIgnoreLines","isFileIgnored","fileIncludeLines","isFileIncluded","dirIgnoreLines","isDirIgnored","dirIncludeLines","isDirIncluded","firstSep","PERF","globalStart","itrcount","time","itr","r","create","LocalFileSearchSimpleWorker","queryId","folderQuery","ignorePathCasing","revivedFolderQuery","reviveFolderQuery","limitHit","count","max","filePatternMatcher","reviveQueryProps","file","revivedQuery","createSearchRegExp","onGoingProcesses","fileCount","resultCount","processFile","fileResults","getFileResults_1","queryProps","onFile","folderExcludes","isFolderExcluded","pathExcludedInQuery","pathIncludedInQuery","prior","isFileSystemDirectoryHandle","isFileSystemFileHandle","processDirectory","directory","ignoreFile","ignoreFiles","ignoreFile_1","files","dirs","sibilings","resolveDirectory","processed","fq","fsPath","searchPath","relPath"],"file":"localFileSearch.js"}
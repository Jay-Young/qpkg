{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/search/worker/fake","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/map.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/getFileResults.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/ignoreFile.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/worker/localFileSearch.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string): string | undefined {\n\treturn hasDriveLetter(path) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tsuffix += pathChars.charAt(Math.floor(Math.random() * pathChars.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractive = 'vscode-interactive';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface INextTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithNextTask {\n\treadonly next: INextTask;\n}\n\nexport class TaskSequentializer {\n\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: INextTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending?.promise;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n\n\thasNext(): this is ITaskSequentializerWithNextTask {\n\t\treturn !!this._next;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._next?.promise ?? this._pending?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate rejected = false;\n\tprivate resolved = false;\n\n\tpublic get isRejected() {\n\t\treturn this.rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn this.rejected || this.resolved;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.resolved = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\tnew Promise<void>(resolve => {\n\t\t\tthis.errorCallback(new CancellationError());\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters, ltrim } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchResult } from 'vs/workbench/services/search/common/search';\nimport { TextSearchPreviewOptions } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { Range } from 'vs/editor/common/core/range';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tbeforeContext: number;\n\t\tafterContext: number;\n\t\tpreviewOptions: TextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndecies: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndecies.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndecies.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndecies) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.beforeContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.beforeContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchResult = {\n\t\t\t\tranges: fileRange,\n\t\t\t\tpreview: { text: previewText, matches: previewRange },\n\t\t\t};\n\t\t\tresults.push(match);\n\n\t\t\tif (options.afterContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.afterContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\n\n\nexport class IgnoreFile {\n\n\tprivate isPathIgnored: (path: string, isDir: boolean, parent?: IgnoreFile) => boolean;\n\n\tconstructor(\n\t\tcontents: string,\n\t\tprivate readonly location: string,\n\t\tprivate readonly parent?: IgnoreFile) {\n\t\tif (location[location.length - 1] === '\\\\') {\n\t\t\tthrow Error('Unexpected path format, do not use trailing backslashes');\n\t\t}\n\t\tif (location[location.length - 1] !== '/') {\n\t\t\tlocation += '/';\n\t\t}\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Updates the contents of the ignorefile. Preservering the location and parent\n\t * @param contents The new contents of the gitignore file\n\t */\n\tupdateContents(contents: string) {\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Returns true if a path in a traversable directory has not been ignored.\n\t *\n\t * Note: For performance reasons this does not check if the parent directories have been ignored,\n\t * so it should always be used in tandem with `shouldTraverseDir` when walking a directory.\n\t *\n\t * In cases where a path must be tested in isolation, `isArbitraryPathIncluded` should be used.\n\t */\n\tisPathIncludedInTraversal(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst ignored = this.isPathIgnored(path, isDir);\n\n\t\treturn !ignored;\n\t}\n\n\t/**\n\t * Returns true if an arbitrary path has not been ignored.\n\t * This is an expensive operation and should only be used ouside of traversals.\n\t */\n\tisArbitraryPathIgnored(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst segments = path.split('/').filter(x => x);\n\t\tlet ignored = false;\n\n\t\tlet walkingPath = '';\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst isLast = i === segments.length - 1;\n\t\t\tconst segment = segments[i];\n\n\t\t\twalkingPath = walkingPath + '/' + segment;\n\n\t\t\tif (!this.isPathIncludedInTraversal(walkingPath, isLast ? isDir : true)) {\n\t\t\t\tignored = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ignored;\n\t}\n\n\tprivate gitignoreLinesToExpression(lines: string[], dirPath: string, trimForExclusions: boolean): glob.ParsedExpression {\n\t\tconst includeLines = lines.map(line => this.gitignoreLineToGlob(line, dirPath));\n\n\t\tconst includeExpression: glob.IExpression = Object.create(null);\n\t\tfor (const line of includeLines) {\n\t\t\tincludeExpression[line] = true;\n\t\t}\n\n\t\treturn glob.parse(includeExpression, { trimForExclusions });\n\t}\n\n\n\tprivate parseIgnoreFile(ignoreContents: string, dirPath: string, parent: IgnoreFile | undefined): (path: string, isDir: boolean) => boolean {\n\t\tconst contentLines = ignoreContents\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim())\n\t\t\t.filter(line => line && line[0] !== '#');\n\n\t\t// Pull out all the lines that end with `/`, those only apply to directories\n\t\tconst fileLines = contentLines.filter(line => !line.endsWith('/'));\n\n\t\tconst fileIgnoreLines = fileLines.filter(line => !line.includes('!'));\n\t\tconst isFileIgnored = this.gitignoreLinesToExpression(fileIgnoreLines, dirPath, true);\n\n\t\t// TODO: Slight hack... this naieve approach may reintroduce too many files in cases of weirdly complex .gitignores\n\t\tconst fileIncludeLines = fileLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isFileIncluded = this.gitignoreLinesToExpression(fileIncludeLines, dirPath, false);\n\n\t\t// When checking if a dir is ignored we can use all lines\n\t\tconst dirIgnoreLines = contentLines.filter(line => !line.includes('!'));\n\t\tconst isDirIgnored = this.gitignoreLinesToExpression(dirIgnoreLines, dirPath, true);\n\n\t\t// Same hack.\n\t\tconst dirIncludeLines = contentLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isDirIncluded = this.gitignoreLinesToExpression(dirIncludeLines, dirPath, false);\n\n\t\tconst isPathIgnored = (path: string, isDir: boolean) => {\n\t\t\tif (!path.startsWith(dirPath)) { return false; }\n\t\t\tif (isDir && isDirIgnored(path) && !isDirIncluded(path)) { return true; }\n\t\t\tif (isFileIgnored(path) && !isFileIncluded(path)) { return true; }\n\n\t\t\tif (parent) { return parent.isPathIgnored(path, isDir); }\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn isPathIgnored;\n\t}\n\n\tprivate gitignoreLineToGlob(line: string, dirPath: string): string {\n\t\tconst firstSep = line.indexOf('/');\n\t\tif (firstSep === -1 || firstSep === line.length - 1) {\n\t\t\tline = '**/' + line;\n\t\t} else {\n\t\t\tif (firstSep === 0) {\n\t\t\t\tif (dirPath.slice(-1) === '/') {\n\t\t\t\t\tline = line.slice(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirPath.slice(-1) !== '/') {\n\t\t\t\t\tline = '/' + line;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = dirPath + line;\n\t\t}\n\n\t\treturn line;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\nimport { UriComponents, URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { ILocalFileSearchSimpleWorker, ILocalFileSearchSimpleWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from 'vs/workbench/services/search/common/localFileSearchWorkerTypes';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from 'vs/workbench/services/search/common/search';\nimport * as paths from 'vs/base/common/path';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { getFileResults } from 'vs/workbench/services/search/common/getFileResults';\nimport { IgnoreFile } from 'vs/workbench/services/search/common/ignoreFile';\nimport { createRegExp } from 'vs/base/common/strings';\nimport { Promises } from 'vs/base/common/async';\nimport { ExtUri } from 'vs/base/common/resources';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: ILocalFileSearchSimpleWorkerHost): IRequestHandler {\n\treturn new LocalFileSearchSimpleWorker(host);\n}\n\nexport class LocalFileSearchSimpleWorker implements ILocalFileSearchSimpleWorker, IRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(private host: ILocalFileSearchSimpleWorkerHost) { }\n\n\tcancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tafterContext: query.afterContext ?? 0,\n\t\t\t\t\tbeforeContext: query.beforeContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => any, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = glob.parse(folderQuery.excludePattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression;\n\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => any) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn {\n\t\t...folderQuery,\n\t\tfolder: URI.revive(folderQuery.folder),\n\t};\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","getOrSet","map","key","value","exports","mapToString","entries","setToString","set","ResourceMapEntry","uri","ResourceMap","mapOrKeyFn","toKey","_a","resource","clb","thisArg","_","entry","ResourceSet","entriesOrKey","_b","callbackfn","_value","Touch","LinkedMap","_c","touch","item","state","current","iterator","newSize","currentSize","next","previous","data","LRUCache","limit","ratio","isPathSeparator","code","toSlashes","osPath","path_1","toPosixPath","getRoot","path","sep","firstLetter","pos","start","isWindowsDriveLetter","isUNC","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isValidBasename","name","isWindowsOS","invalidFileChars","isEqual","pathA","pathB","ignoreCase","identityEquals","strings_1","isEqualOrParent","base","parentCandidate","separator","sepOffset","char0","sanitizeFilePath","candidate","cwd","isRootOrDriveLetter","pathNormalized","hasDriveLetter","getDriveLetter","indexOfPath","parseLineAndColumnAware","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","randomPath","parent","prefix","randomLength","suffix","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","originalFSPath","ExtUri","a","uri1","uri2","ignoreFragment","network_1","extpath","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","distinctParents","items","resourceAccessor","candidateResource","otherItem","index","DataUri","parseMetaData","dataUri","metadata","property","mime","toLocalResource","localScheme","isThenable","obj","createCancelablePromise","callback","source","cancellation_1","thenable","promise","resolve","reject","subscription","errors_1","onfinally","raceCancellation","token","defaultValue","ref","raceCancellationError","raceCancellablePromises","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","raceTimeout","timeout","onTimeout","promiseResolve","timer","asPromise","Throttler","promiseFactory","onComplete","Sequencer","promiseTask","SequencerByKey","newPromise","timeoutDeferred","fn","scheduled","handle","microtaskDeferred","Delayer","defaultDelay","task","delay","symbols_1","ThrottledDelayer","Barrier","c","e","AutoOpenBarrier","autoOpenTimeMs","millis","disposable","disposableTimeout","handler","lifecycle_1","sequence","promiseFactories","results","thenHandler","n","first","shouldStop","t","loop","factory","firstParallel","promiseList","todo","finish","Limiter","maxDegreeOfParalellism","event_1","iLimitedTask","Queue","ResourceQueue","DeferredPromise","queue","extUri","resources_1","drainer","TimeoutTimer","runner","IntervalTimer","interval","RunOnceScheduler","ProcessTimeRunOnceScheduler","RunOnceWorker","unit","units","ThrottledWorker","g","h","disposed","end","IdleValue","executor","retry","retries","lastError","error","TaskSequentializer","taskId","onCancel","run","promiseReject","IntervalCounter","d","f","now","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","AsyncIterableObject","writer","emitter","iterables","iterable","mapFn","filterFn","values","CancelableAsyncIterableObject","l","createCancelableAsyncIterable","innerIterable","getEmptyExpression","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","inBraces","inBrackets","curVal","char","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","res","choice","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","parsedPattern","wrapRelativePattern","match","trivia1","trimForExclusions","trivia2","trivia3","trivia4and5","toRegExp","arg2","wrappedPattern","basename","extpath_1","slashBase","backslashBase","basenames","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","allPaths","all","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","regExp","hasSibling","parse","isRelativePattern","resultPattern","parsedExpression","rp","getBasenameTerms","patternOrExpression","getPathTerms","expression","parseExpressionPattern","resultExpression","resultPromises","async_1","resultPromise","when","clausePattern","matched","basenamePatterns","patterns","aggregate","ch","aggregatedPatterns","patternsEquals","patternsA","patternsB","arrays_1","b","getFileResults","bytes","text","patternIndecies","patternMatch","remainingResultQuota","contextLinesNeeded","resultLines","lineRanges","readLine","lineNumber","prevLineEnd","lineEndingMatch","lineEndRegex","startLine","matchStartIndex","matchedText","endLine","contextLine","previewText","offset","matchLine","previewLine","fileRange","range_1","previewRange","IgnoreFile","contents","isDir","x","ignored","walkingPath","isLast","lines","dirPath","includeLines","includeExpression","glob","ignoreContents","contentLines","fileLines","fileIgnoreLines","isFileIgnored","fileIncludeLines","isFileIncluded","dirIgnoreLines","isDirIgnored","dirIncludeLines","isDirIncluded","firstSep","PERF","globalStart","itrcount","time","itr","r","create","LocalFileSearchSimpleWorker","queryId","folderQuery","ignorePathCasing","revivedFolderQuery","reviveFolderQuery","limitHit","count","max","filePatternMatcher","reviveQueryProps","file","revivedQuery","createSearchRegExp","onGoingProcesses","fileCount","resultCount","processFile","fileResults","getFileResults_1","queryProps","onFile","folderExcludes","isFolderExcluded","pathExcludedInQuery","pathIncludedInQuery","prior","isFileSystemDirectoryHandle","isFileSystemFileHandle","processDirectory","directory","ignoreFile","ignoreFiles","ignoreFile_1","files","dirs","sibilings","resolveDirectory","processed","fq","fsPath","searchPath","relPath"],"file":"localFileSearch.js"}
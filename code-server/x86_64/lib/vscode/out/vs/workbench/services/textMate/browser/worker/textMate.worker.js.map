{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/fake","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableImpl/logging.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableImpl/autorun.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableImpl/base.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableImpl/derived.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableImpl/utils.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observable.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stream.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/encodedTokenAttributes.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/fixedArray.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/languages/nullTokenize.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/lineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/worker/textMateWorkerModel.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/worker/textMate.worker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver } from 'vs/base/common/observableImpl/autorun';\nimport { IObservable, ObservableValue, TransactionImpl } from 'vs/base/common/observableImpl/base';\nimport { Derived } from 'vs/base/common/observableImpl/derived';\nimport { FromEventObservable } from 'vs/base/common/observableImpl/utils';\n\nlet globalObservableLogger: IObservableLogger | undefined;\n\nexport function setLogger(logger: IObservableLogger): void {\n\tglobalObservableLogger = logger;\n}\n\nexport function getLogger(): IObservableLogger | undefined {\n\treturn globalObservableLogger;\n}\n\ninterface IChangeInformation {\n\toldValue: unknown;\n\tnewValue: unknown;\n\tchange: unknown;\n\tdidChange: boolean;\n}\n\nexport interface IObservableLogger {\n\thandleObservableChanged(observable: ObservableValue<unknown, unknown>, info: IChangeInformation): void;\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void;\n\n\thandleAutorunCreated(autorun: AutorunObserver): void;\n\thandleAutorunTriggered(autorun: AutorunObserver): void;\n\n\thandleDerivedCreated(observable: Derived<unknown>): void;\n\thandleDerivedRecomputed(observable: Derived<unknown>, info: IChangeInformation): void;\n\n\thandleBeginTransaction(transaction: TransactionImpl): void;\n\thandleEndTransaction(): void;\n}\n\nexport class ConsoleObservableLogger implements IObservableLogger {\n\tprivate indentation = 0;\n\n\tprivate textToConsoleArgs(text: ConsoleText): unknown[] {\n\t\treturn consoleTextToArgs([\n\t\t\tnormalText(repeat('|  ', this.indentation)),\n\t\t\ttext,\n\t\t]);\n\t}\n\n\tprivate formatInfo(info: IChangeInformation): ConsoleText[] {\n\t\treturn info.didChange\n\t\t\t? [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.oldValue, 70), {\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tstrikeThrough: true,\n\t\t\t\t}),\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t]\n\t\t\t: [normalText(` (unchanged)`)];\n\t}\n\n\thandleObservableChanged(observable: IObservable<unknown, unknown>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable value changed'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\tprivate readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any, any>>>();\n\n\tformatChanges(changes: Set<IObservable<any, any>>): ConsoleText | undefined {\n\t\tif (changes.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn styled(\n\t\t\t' (changed deps: ' +\n\t\t\t[...changes].map((o) => o.debugName).join(', ') +\n\t\t\t')',\n\t\t\t{ color: 'gray' }\n\t\t);\n\t}\n\n\thandleDerivedCreated(derived: Derived<unknown>): void {\n\t\tconst existingHandleChange = derived.handleChange;\n\t\tthis.changedObservablesSets.set(derived, new Set());\n\t\tderived.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(derived)!.add(observable);\n\t\t\treturn existingHandleChange.apply(derived, [observable, change]);\n\t\t};\n\t}\n\n\thandleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(derived)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived recomputed'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\tthis.formatChanges(changedObservables)\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable from event triggered'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver): void {\n\t\tconst existingHandleChange = autorun.handleChange;\n\t\tthis.changedObservablesSets.set(autorun, new Set());\n\t\tautorun.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(autorun)!.add(observable);\n\t\t\treturn existingHandleChange.apply(autorun, [observable, change]);\n\t\t};\n\t}\n\n\thandleAutorunTriggered(autorun: AutorunObserver): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(autorun)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('autorun'),\n\t\t\tstyled(autorun.debugName, { color: 'BlueViolet' }),\n\t\t\tthis.formatChanges(changedObservables)\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tlet transactionName = transaction.getDebugName();\n\t\tif (transactionName === undefined) {\n\t\t\ttransactionName = '';\n\t\t}\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('transaction'),\n\t\t\tstyled(transactionName, { color: 'BlueViolet' }),\n\t\t]));\n\t\tthis.indentation++;\n\t}\n\n\thandleEndTransaction(): void {\n\t\tthis.indentation--;\n\t}\n}\n\ntype ConsoleText =\n\t| (ConsoleText | undefined)[]\n\t| { text: string; style: string; data?: Record<string, unknown> }\n\t| { data: Record<string, unknown> };\n\nfunction consoleTextToArgs(text: ConsoleText): unknown[] {\n\tconst styles = new Array<any>();\n\tconst initial = {};\n\tconst data = initial;\n\tlet firstArg = '';\n\n\tfunction process(t: ConsoleText): void {\n\t\tif ('length' in t) {\n\t\t\tfor (const item of t) {\n\t\t\t\tif (item) {\n\t\t\t\t\tprocess(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('text' in t) {\n\t\t\tfirstArg += `%c${t.text}`;\n\t\t\tstyles.push(t.style);\n\t\t\tif (t.data) {\n\t\t\t\tObject.assign(data, t.data);\n\t\t\t}\n\t\t} else if ('data' in t) {\n\t\t\tObject.assign(data, t.data);\n\t\t}\n\t}\n\n\tprocess(text);\n\n\tconst result = [firstArg, ...styles];\n\tif (Object.keys(data).length > 0) {\n\t\tresult.push(data);\n\t}\n\n\treturn result;\n}\n\nfunction normalText(text: string): ConsoleText {\n\treturn styled(text, { color: 'black' });\n}\n\nfunction formatKind(kind: string): ConsoleText {\n\treturn styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\n\nfunction styled(\n\ttext: string,\n\toptions: { color: string; strikeThrough?: boolean; bold?: boolean } = {\n\t\tcolor: 'black',\n\t}\n): ConsoleText {\n\tfunction objToCss(styleObj: Record<string, string>): string {\n\t\treturn Object.entries(styleObj).reduce(\n\t\t\t(styleString, [propName, propValue]) => {\n\t\t\t\treturn `${styleString}${propName}:${propValue};`;\n\t\t\t},\n\t\t\t''\n\t\t);\n\t}\n\n\tconst style: Record<string, string> = {\n\t\tcolor: options.color,\n\t};\n\tif (options.strikeThrough) {\n\t\tstyle['text-decoration'] = 'line-through';\n\t}\n\tif (options.bold) {\n\t\tstyle['font-weight'] = 'bold';\n\t}\n\n\treturn {\n\t\ttext,\n\t\tstyle: objToCss(style),\n\t};\n}\n\nfunction formatValue(value: unknown, availableLen: number): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\treturn '' + value;\n\t\tcase 'string':\n\t\t\tif (value.length + 2 <= availableLen) {\n\t\t\t\treturn `\"${value}\"`;\n\t\t\t}\n\t\t\treturn `\"${value.substr(0, availableLen - 7)}\"+...`;\n\n\t\tcase 'boolean':\n\t\t\treturn value ? 'true' : 'false';\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'object':\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn formatArray(value, availableLen);\n\t\t\t}\n\t\t\treturn formatObject(value, availableLen);\n\t\tcase 'symbol':\n\t\t\treturn value.toString();\n\t\tcase 'function':\n\t\t\treturn `[[Function${value.name ? ' ' + value.name : ''}]]`;\n\t\tdefault:\n\t\t\treturn '' + value;\n\t}\n}\n\nfunction formatArray(value: unknown[], availableLen: number): string {\n\tlet result = '[ ';\n\tlet first = true;\n\tfor (const val of value) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' ]';\n\treturn result;\n}\n\nfunction formatObject(value: object, availableLen: number): string {\n\tlet result = '{ ';\n\tlet first = true;\n\tfor (const [key, val] of Object.entries(value)) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${key}: ${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' }';\n\treturn result;\n}\n\nfunction repeat(str: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 1; i <= count; i++) {\n\t\tresult += str;\n\t}\n\treturn result;\n}\n\nfunction padStr(str: string, length: number): string {\n\twhile (str.length < length) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, IObserver, IChangeContext } from 'vs/base/common/observableImpl/base';\nimport { getLogger } from 'vs/base/common/observableImpl/logging';\n\nexport function autorun(debugName: string, fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(debugName, fn, undefined, undefined);\n}\n\nexport function autorunHandleChanges<TChangeSummary>(\n\tdebugName: string,\n\toptions: {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void\n): IDisposable {\n\treturn new AutorunObserver(debugName, fn, options.createEmptyChangeSummary, options.handleChange);\n}\n\n// TODO@hediet rename to autorunWithStore\nexport function autorunWithStore2(\n\tdebugName: string,\n\tfn: (reader: IReader, store: DisposableStore) => void,\n): IDisposable {\n\treturn autorunWithStore(fn, debugName);\n}\n\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\tdebugName: string,\n\toptions: {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\tdebugName,\n\t\t{\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n// TODO@hediet deprecate, rename to autorunWithStoreEx\nexport function autorunWithStore(\n\tfn: (reader: IReader, store: DisposableStore) => void,\n\tdebugName: string\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorun(\n\t\tdebugName,\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nconst enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly runFn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\tgetLogger()?.handleAutorunTriggered(this);\n\n\t\ttry {\n\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\tthis.runFn(this, changeSummary);\n\t\t} finally {\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\tif (this.updateCount === 1) {\n\t\t\tdo {\n\t\t\t\tif (this.state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\tif (this.state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._runIfNeeded();\n\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t}\n\t\tthis.updateCount--;\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this.state === AutorunState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tif (shouldReact) {\n\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\nexport function autorunDelta<T>(\n\tname: string,\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorun(name, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport type { derived } from 'vs/base/common/observableImpl/derived';\nimport { getLogger } from 'vs/base/common/observableImpl/logging';\n\n/**\n * Represents an observable value.\n * @template T The type of the value.\n * @template TChange The type of delta information (usually `void` and only used in advanced scenarios).\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for and report changes.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes to this observable.\n\t *\n\t * Just calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read}).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map}).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not call into other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable changed.\n\t *\n\t * Implementations must not call into other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservable<any, any>): void;\n}\n\nlet _derived: typeof derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerived(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservable<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew> {\n\t\treturn _derived(\n\t\t\t() => {\n\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\treturn name !== undefined ? name : `${this.debugName} (mapped)`;\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader)\n\t\t);\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n}\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tgetLogger()?.handleBeginTransaction(tx);\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(private readonly fn: Function, private readonly _getDebugName?: () => string) { }\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this.fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tfor (const { observer, observable } of updatingObservers) {\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t}\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n\nexport interface ISettableObservable<T, TChange = void> extends IObservable<T, TChange>, ISettable<T, TChange> {\n}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n */\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange> {\n\treturn new ObservableValue(name, initialValue);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange>\n{\n\tprotected _value: T;\n\n\tconstructor(public readonly debugName: string, initialValue: T) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this._value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true });\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange> & IDisposable {\n\treturn new DisposableObservableValue(name, initialValue);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\tdidChange<T, TChange>(observable: IObservable<T, TChange>): this is { change: TChange };\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Can record the changes to just process deltas.\n\t*/\n\thandleChange(context: IChangeContext): boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from 'vs/base/common/errors';\nimport { DisposableStore } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, BaseObservable, IObserver, _setDerived, IChangeContext } from 'vs/base/common/observableImpl/base';\nimport { getLogger } from 'vs/base/common/observableImpl/logging';\n\nexport function derived<T>(debugName: string | (() => string), computeFn: (reader: IReader) => T): IObservable<T> {\n\treturn new Derived(debugName, computeFn, undefined, undefined, undefined);\n}\n\nexport function derivedHandleChanges<T, TChangeSummary>(\n\tdebugName: string | (() => string),\n\toptions: {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T): IObservable<T> {\n\treturn new Derived(debugName, computeFn, options.createEmptyChangeSummary, options.handleChange, undefined);\n}\n\nexport function derivedWithStore<T>(name: string, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T> {\n\tconst store = new DisposableStore();\n\treturn new Derived(name, r => {\n\t\tstore.clear();\n\t\treturn computeFn(r, store);\n\t}, undefined, undefined, () => store.dispose());\n}\n\n_setDerived(derived);\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn typeof this._debugName === 'function' ? this._debugName() : this._debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | (() => string),\n\t\tprivate readonly computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this.computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tconst changeSummary = this.changeSummary!;\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\ttry {\n\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\tthis.value = this.computeFn(this, changeSummary);\n\t\t} finally {\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\n\t\tconst didChange = hadValue && oldValue !== this.value;\n\n\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\toldValue,\n\t\t\tnewValue: this.value,\n\t\t\tchange: undefined,\n\t\t\tdidChange\n\t\t});\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tif (this.updateCount < 0) {\n\t\t\tthrow new BugIndicatingError();\n\t\t}\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { autorun } from 'vs/base/common/observableImpl/autorun';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, getFunctionName, observableValue, transaction } from 'vs/base/common/observableImpl/base';\nimport { derived } from 'vs/base/common/observableImpl/derived';\nimport { getLogger } from 'vs/base/common/observableImpl/logging';\n\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean): Promise<T> {\n\treturn new Promise(resolve => {\n\t\tlet didRun = false;\n\t\tlet shouldDispose = false;\n\t\tconst d = autorun('waitForState', reader => {\n\t\t\tconst currentState = observable.read(reader);\n\t\t\tif (predicate(currentState)) {\n\t\t\t\tif (!didRun) {\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tresolve(currentState);\n\t\t\t}\n\t\t});\n\t\tdidRun = true;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T\n): IObservable<T> {\n\treturn new FromEventObservable(event, getValue);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly event: Event<TArgs>,\n\t\tprivate readonly getValue: (args: TArgs | undefined) => T\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn getFunctionName(this.getValue);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this.getValue(args);\n\n\t\tconst didChange = !this.hasValue || this.value !== newValue;\n\n\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue: this.value, newValue, change: undefined, didChange });\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\ttransaction(\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\treturn this.getValue(undefined);\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n */\nexport function observableSignal<TDelta = void>(\n\tdebugName: string\n): IObservableSignal<TDelta> {\n\treturn new ObservableSignal<TDelta>(debugName);\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tconstructor(\n\t\tpublic readonly debugName: string\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun('debounce', reader => {\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This ensures the observable is being observed.\n * Observed observables (such as {@link derived}s) can maintain a cache, as they receive invalidation events.\n * Unobserved observables are forced to recompute their value from scratch every time they are read.\n *\n * @param observable the observable to keep alive\n * @param forceRecompute if true, the observable will be eagerly recomputed after it changed.\n * Use this if recomputing the observables causes side-effects.\n*/\nexport function keepAlive(observable: IObservable<any>, forceRecompute?: boolean): IDisposable {\n\tconst o = new KeepAliveObserver(forceRecompute ?? false);\n\tobservable.addObserver(o);\n\tif (forceRecompute) {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\nclass KeepAliveObserver implements IObserver {\n\tprivate counter = 0;\n\n\tconstructor(private readonly forceRecompute: boolean) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis.counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis.counter--;\n\t\tif (this.counter === 0 && this.forceRecompute) {\n\t\t\tobservable.reportChanges();\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(name: string, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derived(name, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(name: string, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & { clearCache(transaction: ITransaction): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst counter = observableValue('derivedObservableWithWritableCache.counter', 0);\n\tconst observable = derived(name, reader => {\n\t\tcounter.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (transaction: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tcounter.set(counter.get() + 1, transaction);\n\t\t},\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport {\n\tIObservable,\n\tIObserver,\n\tIReader,\n\tISettable,\n\tISettableObservable,\n\tITransaction,\n\tobservableValue,\n\ttransaction,\n} from 'vs/base/common/observableImpl/base';\nexport { derived } from 'vs/base/common/observableImpl/derived';\nexport {\n\tautorun,\n\tautorunDelta,\n\tautorunHandleChanges,\n\tautorunWithStore,\n} from 'vs/base/common/observableImpl/autorun';\nexport * from 'vs/base/common/observableImpl/utils';\n\nimport { ConsoleObservableLogger, setLogger } from 'vs/base/common/observableImpl/logging';\n\nconst enableLogging = false;\nif (enableLogging) {\n\tsetLogger(new ConsoleObservableLogger());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable {\n\tlet destroyed = false;\n\n\tstream.on('error', error => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n\n\treturn toDisposable(() => destroyed = true);\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from 'vs/base/common/lazy';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array) {\n\t\tconst needle = subarray instanceof VSBuffer ? subarray.buffer : subarray;\n\t\tconst needleLen = needle.byteLength;\n\t\tconst haystack = this.buffer;\n\t\tconst haystackLen = haystack.byteLength;\n\n\t\tif (needleLen === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (needleLen === 1) {\n\t\t\treturn haystack.indexOf(needle[0]);\n\t\t}\n\n\t\tif (needleLen > haystackLen) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// find index of the subarray using boyer-moore-horspool algorithm\n\t\tconst table = indexOfTable.value;\n\t\ttable.fill(needle.length);\n\t\tfor (let i = 0; i < needle.length; i++) {\n\t\t\ttable[needle[i]] = needle.length - i - 1;\n\t\t}\n\n\t\tlet i = needle.length - 1;\n\t\tlet j = i;\n\t\tlet result = -1;\n\t\twhile (i < haystackLen) {\n\t\t\tif (haystack[i] === needle[j]) {\n\t\t\t\tif (j === 0) {\n\t\t\t\t\tresult = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\t\tj = needle.length - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new Error('Throttler is disposed');\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface INextTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithNextTask {\n\treadonly next: INextTask;\n}\n\nexport class TaskSequentializer {\n\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: INextTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending?.promise;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n\n\thasNext(): this is ITaskSequentializerWithNextTask {\n\t\treturn !!this._next;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._next?.promise ?? this._pending?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Open ended enum at runtime\n */\nexport const enum LanguageId {\n\tNull = 0,\n\tPlainText = 1\n}\n\n/**\n * A font style. Values are 2^x such that a bit mask can be used.\n */\nexport const enum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n\tStrikethrough = 8,\n}\n\n/**\n * Open ended enum at runtime\n */\nexport const enum ColorId {\n\tNone = 0,\n\tDefaultForeground = 1,\n\tDefaultBackground = 2\n}\n\n/**\n * A standard token type.\n */\nexport const enum StandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 3\n}\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb ffff ffff fFFF FBTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (2 bits)\n *  - B = Balanced bracket (1 bit)\n *  - F = FontStyle (4 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n *\n */\nexport const enum MetadataConsts {\n\tLANGUAGEID_MASK = 0b00000000000000000000000011111111,\n\tTOKEN_TYPE_MASK = 0b00000000000000000000001100000000,\n\tBALANCED_BRACKETS_MASK = 0b00000000000000000000010000000000,\n\tFONT_STYLE_MASK = 0b00000000000000000111100000000000,\n\tFOREGROUND_MASK = 0b00000000111111111000000000000000,\n\tBACKGROUND_MASK = 0b11111111000000000000000000000000,\n\n\tITALIC_MASK = 0b00000000000000000000100000000000,\n\tBOLD_MASK = 0b00000000000000000001000000000000,\n\tUNDERLINE_MASK = 0b00000000000000000010000000000000,\n\tSTRIKETHROUGH_MASK = 0b00000000000000000100000000000000,\n\n\t// Semantic tokens cannot set the language id, so we can\n\t// use the first 8 bits for control purposes\n\tSEMANTIC_USE_ITALIC = 0b00000000000000000000000000000001,\n\tSEMANTIC_USE_BOLD = 0b00000000000000000000000000000010,\n\tSEMANTIC_USE_UNDERLINE = 0b00000000000000000000000000000100,\n\tSEMANTIC_USE_STRIKETHROUGH = 0b00000000000000000000000000001000,\n\tSEMANTIC_USE_FOREGROUND = 0b00000000000000000000000000010000,\n\tSEMANTIC_USE_BACKGROUND = 0b00000000000000000000000000100000,\n\n\tLANGUAGEID_OFFSET = 0,\n\tTOKEN_TYPE_OFFSET = 8,\n\tBALANCED_BRACKETS_OFFSET = 10,\n\tFONT_STYLE_OFFSET = 11,\n\tFOREGROUND_OFFSET = 15,\n\tBACKGROUND_OFFSET = 24\n}\n\n/**\n */\nexport class TokenMetadata {\n\n\tpublic static getLanguageId(metadata: number): LanguageId {\n\t\treturn (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n\t}\n\n\tpublic static getTokenType(metadata: number): StandardTokenType {\n\t\treturn (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n\t}\n\n\tpublic static containsBalancedBrackets(metadata: number): boolean {\n\t\treturn (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n\t}\n\n\tpublic static getFontStyle(metadata: number): FontStyle {\n\t\treturn (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n\t}\n\n\tpublic static getForeground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n\t}\n\n\tpublic static getBackground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n\t}\n\n\tpublic static getClassNameFromMetadata(metadata: number): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tlet className = 'mtk' + foreground;\n\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tclassName += ' mtki';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tclassName += ' mtkb';\n\t\t}\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\tclassName += ' mtku';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\tclassName += ' mtks';\n\t\t}\n\n\t\treturn className;\n\t}\n\n\tpublic static getInlineStyleFromMetadata(metadata: number, colorMap: string[]): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\tlet result = `color: ${colorMap[foreground]};`;\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tresult += 'font-style: italic;';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tresult += 'font-weight: bold;';\n\t\t}\n\t\tlet textDecoration = '';\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\ttextDecoration += ' underline';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\ttextDecoration += ' line-through';\n\t\t}\n\t\tif (textDecoration) {\n\t\t\tresult += `text-decoration:${textDecoration};`;\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static getPresentationFromMetadata(metadata: number): ITokenPresentation {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\treturn {\n\t\t\tforeground: foreground,\n\t\t\titalic: Boolean(fontStyle & FontStyle.Italic),\n\t\t\tbold: Boolean(fontStyle & FontStyle.Bold),\n\t\t\tunderline: Boolean(fontStyle & FontStyle.Underline),\n\t\t\tstrikethrough: Boolean(fontStyle & FontStyle.Strikethrough),\n\t\t};\n\t}\n}\n\n/**\n */\nexport interface ITokenPresentation {\n\tforeground: ColorId;\n\titalic: boolean;\n\tbold: boolean;\n\tunderline: boolean;\n\tstrikethrough: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from 'vs/base/common/arrays';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Token, TokenizationResult, EncodedTokenizationResult, IState } from 'vs/editor/common/languages';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts } from 'vs/editor/common/encodedTokenAttributes';\n\nexport const NullState: IState = new class implements IState {\n\tpublic clone(): IState {\n\t\treturn this;\n\t}\n\tpublic equals(other: IState): boolean {\n\t\treturn (this === other);\n\t}\n};\n\nexport function nullTokenize(languageId: string, state: IState): TokenizationResult {\n\treturn new TokenizationResult([new Token(0, '', languageId)], state);\n}\n\nexport function nullTokenizeEncoded(languageId: LanguageId, state: IState | null): EncodedTokenizationResult {\n\tconst tokens = new Uint32Array(2);\n\ttokens[0] = 0;\n\ttokens[1] = (\n\t\t(languageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\treturn new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata, ITokenPresentation } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IViewLineTokens {\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata = (\n\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\tpublic static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = (this._tokens.length >>> 1);\n\t\tthis._text = text;\n\t\tthis._languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = (sliceFromTokenIndex << 1);\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this._languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\tpublic static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void {\n\t\tconst tokenCount = (tokens.length >>> 1);\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[(mid << 1)];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t*/\n\tpublic withInserted(insertTokens: { offset: number; text: string; tokenMetadata: number }[]): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = '';\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n\t\t\tconst nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n\t\t\tif (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(originalEndOffset, nextInsertToken.offset);\n\t\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tconstructor(source: LineTokens, startOffset: number, endOffset: number, deltaOffset: number) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\n\t\tthis._tokensCount = 0;\n\t\tfor (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source.getLineContent().substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset\n\t\t\t\t&& this._endOffset === other._endOffset\n\t\t\t\t&& this._deltaOffset === other._deltaOffset\n\t\t\t\t&& this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\t\treturn Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nexport class ContiguousTokensEditing {\n\n\tpublic static deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\treturn ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n\t}\n\n\tpublic static deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\treturn ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n\t}\n\n\tpublic static delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\treturn tmp.buffer;\n\t}\n\n\tpublic static append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn _otherTokens;\n\t\t}\n\t\tif (lineTokens === null) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\treturn null;\n\t\t}\n\t\tconst myTokens = toUint32Array(lineTokens);\n\t\tconst otherTokens = toUint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tconst result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\treturn result.buffer;\n\t}\n\n\tpublic static insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\t// nothing to do\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t\treturn lineTokens;\n\t}\n}\n\nexport function toUint32Array(arr: Uint32Array | ArrayBuffer): Uint32Array {\n\tif (arr instanceof Uint32Array) {\n\t\treturn arr;\n\t} else {\n\t\treturn new Uint32Array(arr);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { ContiguousTokensEditing } from 'vs/editor/common/tokens/contiguousTokensEditing';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\n\n/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n\tpublic static deserialize(buff: Uint8Array, offset: number, result: ContiguousMultilineTokens[]): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset); offset += 4;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset); offset += 4;\n\t\t\ttokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new ContiguousMultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\t/**\n\t * The start line number for this block of tokens.\n\t */\n\tprivate _startLineNumber: number;\n\n\t/**\n\t * The tokens are stored in a binary format. There is an element for each line,\n\t * so `tokens[index]` contains all tokens on line `startLineNumber + index`.\n\t *\n\t * On a specific line, each token occupies two array indices. For token i:\n\t *  - at offset 2*i => endOffset\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\tprivate _tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._startLineNumber + this._tokens.length - 1;\n\t}\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t}\n\n\tgetLineRange(): LineRange {\n\t\treturn new LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length);\n\t}\n\n\t/**\n\t * @see {@link _tokens}\n\t */\n\tpublic getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null {\n\t\treturn this._tokens[lineNumber - this._startLineNumber];\n\t}\n\n\tpublic appendLineTokens(lineTokens: Uint32Array): void {\n\t\tthis._tokens.push(lineTokens);\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this._startLineNumber, offset); offset += 4;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset); offset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset); offset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);\n\n\t\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis._tokens = this._tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t// Delete lines\n\t\t\tthis._tokens = this._tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { ContiguousMultilineTokens } from 'vs/editor/common/tokens/contiguousMultilineTokens';\n\nexport class ContiguousMultilineTokensBuilder {\n\n\tpublic static deserialize(buff: Uint8Array): ContiguousMultilineTokens[] {\n\t\tlet offset = 0;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst result: ContiguousMultilineTokens[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffset = ContiguousMultilineTokens.deserialize(buff, offset, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate readonly _tokens: ContiguousMultilineTokens[];\n\n\tconstructor() {\n\t\tthis._tokens = [];\n\t}\n\n\tpublic add(lineNumber: number, lineTokens: Uint32Array): void {\n\t\tif (this._tokens.length > 0) {\n\t\t\tconst last = this._tokens[this._tokens.length - 1];\n\t\t\tif (last.endLineNumber + 1 === lineNumber) {\n\t\t\t\t// append\n\t\t\t\tlast.appendLineTokens(lineTokens);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n\t}\n\n\tpublic finalize(): ContiguousMultilineTokens[] {\n\t\treturn this._tokens;\n\t}\n\n\tpublic serialize(): Uint8Array {\n\t\tconst size = this._serializeSize();\n\t\tconst result = new Uint8Array(size);\n\t\tthis._serialize(result);\n\t\treturn result;\n\t}\n\n\tprivate _serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tresult += this._tokens[i].serializeSize();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _serialize(destination: Uint8Array): void {\n\t\tlet offset = 0;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\toffset = this._tokens[i].serialize(destination, offset);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenIdle } from 'vs/base/common/async';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Position } from 'vs/editor/common/core/position';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { FixedArray } from 'vs/editor/common/model/fixedArray';\nimport { IModelContentChange } from 'vs/editor/common/textModelEvents';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState = this.tokenizationSupport.getInitialState();\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\tif (lineNumber === 1) {\n\t\t\treturn this.initialState as TState;\n\t\t}\n\t\treturn this.store.getEndState(lineNumber - 1);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst nextLineNumber = this.store.getFirstInvalidEndStateLineNumber();\n\t\t\tif (!nextLineNumber || nextLineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(nextLineNumber);\n\t\t\tconst lineStartState = this.getStartState(nextLineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState!);\n\t\t\tbuilder.add(nextLineNumber, r.tokens);\n\t\t\tthis!.store.setEndState(nextLineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(position: Position, length: number, newText: string): LineTokens | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst column = position.column;\n\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = curLineContent.substring(0, column - 1)\n\t\t\t+ newText + curLineContent.substring(column - 1 + length);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tconst lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn lineTokens;\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this.tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\twhile (true) {\n\t\t\tconst min = this._invalidEndStatesLineNumbers.min;\n\t\t\tif (min !== null && min <= lineNumber) {\n\t\t\t\tthis._invalidEndStatesLineNumbers.removeMin();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst r = this.tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis.tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null {\n\t\treturn this._invalidEndStatesLineNumbers.min;\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this._invalidEndStatesLineNumbers.min || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic isTokenizationComplete(): boolean {\n\t\treturn this._invalidEndStatesLineNumbers.min === null;\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.isTokenizationComplete();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tif (!this._tokenizerWithStateStore || !this._hasLinesToTokenize()) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tconst lineNumber = this._tokenizerWithStateStore.store.getFirstInvalidEndStateLineNumber()!;\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, lineNumber);\n\t\treturn lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.isTokenizationComplete()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { LanguageId, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { ITextModel } from 'vs/editor/common/model';\nimport type { IGrammar, StateStack } from 'vscode-textmate';\n\nexport class TextMateTokenizationSupport extends Disposable implements ITokenizationSupport {\n\tprivate readonly _seenLanguages: boolean[] = [];\n\tprivate readonly _onDidEncounterLanguage: Emitter<LanguageId> = this._register(new Emitter<LanguageId>());\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tconstructor(\n\t\tprivate readonly _grammar: IGrammar,\n\t\tprivate readonly _initialState: StateStack,\n\t\tprivate readonly _containsEmbeddedLanguages: boolean,\n\t\tprivate readonly _createBackgroundTokenizer?: (textModel: ITextModel, tokenStore: IBackgroundTokenizationStore) => IBackgroundTokenizer | undefined,\n\t\tprivate readonly _backgroundTokenizerShouldOnlyVerifyTokens: () => boolean = () => false,\n\t\tprivate readonly _reportTokenizationTime?: (timeMs: number, lineLength: number) => void,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic get backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._backgroundTokenizerShouldOnlyVerifyTokens();\n\t}\n\n\tpublic getInitialState(): IState {\n\t\treturn this._initialState;\n\t}\n\n\tpublic tokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\tpublic createBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._createBackgroundTokenizer) {\n\t\t\treturn this._createBackgroundTokenizer(textModel, store);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic tokenizeEncoded(line: string, hasEOL: boolean, state: StateStack): EncodedTokenizationResult {\n\t\tconst shouldMeasure = this._reportTokenizationTime && (Math.random() * 10_000 < 1);\n\t\tconst sw = shouldMeasure ? new StopWatch(true) : undefined;\n\t\tconst textMateResult = this._grammar.tokenizeLine2(line, state, 500);\n\t\tif (shouldMeasure) {\n\t\t\tconst timeMS = sw!.elapsed();\n\t\t\tthis._reportTokenizationTime!(timeMS, line.length);\n\t\t}\n\n\t\tif (textMateResult.stoppedEarly) {\n\t\t\tconsole.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);\n\t\t\t// return the state at the beginning of the line\n\t\t\treturn new EncodedTokenizationResult(textMateResult.tokens, state);\n\t\t}\n\n\t\tif (this._containsEmbeddedLanguages) {\n\t\t\tconst seenLanguages = this._seenLanguages;\n\t\t\tconst tokens = textMateResult.tokens;\n\n\t\t\t// Must check if any of the embedded languages was hit\n\t\t\tfor (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n\t\t\t\tconst metadata = tokens[(i << 1) + 1];\n\t\t\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\n\t\t\t\tif (!seenLanguages[languageId]) {\n\t\t\t\t\tseenLanguages[languageId] = true;\n\t\t\t\t\tthis._onDidEncounterLanguage.fire(languageId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet endState: StateStack;\n\t\t// try to save an object if possible\n\t\tif (state.equals(textMateResult.ruleStack)) {\n\t\t\tendState = state;\n\t\t} else {\n\t\t\tendState = textMateResult.ruleStack;\n\t\t}\n\n\t\treturn new EncodedTokenizationResult(textMateResult.tokens, endState);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IObservable, keepAlive } from 'vs/base/common/observable';\n\nexport class TokenizationSupportWithLineLimit extends Disposable implements ITokenizationSupport {\n\tget backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._actual.backgroundTokenizerShouldOnlyVerifyTokens;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _encodedLanguageId: LanguageId,\n\t\tprivate readonly _actual: ITokenizationSupport,\n\t\tprivate readonly _maxTokenizationLineLength: IObservable<number>,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(keepAlive(this._maxTokenizationLineLength));\n\t}\n\n\tgetInitialState(): IState {\n\t\treturn this._actual.getInitialState();\n\t}\n\n\ttokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\ttokenizeEncoded(line: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\t\t// Do not attempt to tokenize if a line is too long\n\t\tif (line.length >= this._maxTokenizationLineLength.get()) {\n\t\t\treturn nullTokenizeEncoded(this._encodedLanguageId, state);\n\t\t}\n\n\t\treturn this._actual.tokenizeEncoded(line, hasEOL, state);\n\t}\n\n\tcreateBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._actual.createBackgroundTokenizer) {\n\t\t\treturn this._actual.createBackgroundTokenizer(textModel, store);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageId, StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IValidGrammarDefinition {\n\tlocation: URI;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport interface IValidTokenTypeMap {\n\t[selector: string]: StandardTokenType;\n}\n\nexport interface IValidEmbeddedLanguagesMap {\n\t[scopeName: string]: LanguageId;\n}\n\nexport class TMScopeRegistry {\n\n\tprivate _scopeNameToLanguageRegistration: { [scopeName: string]: IValidGrammarDefinition };\n\n\tconstructor() {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic reset(): void {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic register(def: IValidGrammarDefinition): void {\n\t\tif (this._scopeNameToLanguageRegistration[def.scopeName]) {\n\t\t\tconst existingRegistration = this._scopeNameToLanguageRegistration[def.scopeName];\n\t\t\tif (!resources.isEqual(existingRegistration.location, def.location)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Overwriting grammar scope name to file mapping for scope ${def.scopeName}.\\n` +\n\t\t\t\t\t`Old grammar file: ${existingRegistration.location.toString()}.\\n` +\n\t\t\t\t\t`New grammar file: ${def.location.toString()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._scopeNameToLanguageRegistration[def.scopeName] = def;\n\t}\n\n\tpublic getGrammarDefinition(scopeName: string): IValidGrammarDefinition | null {\n\t\treturn this._scopeNameToLanguageRegistration[scopeName] || null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, TMScopeRegistry } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport type { IGrammar, IOnigLib, IRawTheme, Registry, StateStack } from 'vscode-textmate';\n\ninterface ITMGrammarFactoryHost {\n\tlogTrace(msg: string): void;\n\tlogError(msg: string, err: any): void;\n\treadFile(resource: URI): Promise<string>;\n}\n\nexport interface ICreateGrammarResult {\n\tlanguageId: string;\n\tgrammar: IGrammar | null;\n\tinitialState: StateStack;\n\tcontainsEmbeddedLanguages: boolean;\n\tsourceExtensionId?: string;\n}\n\nexport const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';\n\nexport class TMGrammarFactory extends Disposable {\n\n\tprivate readonly _host: ITMGrammarFactoryHost;\n\tprivate readonly _initialState: StateStack;\n\tprivate readonly _scopeRegistry: TMScopeRegistry;\n\tprivate readonly _injections: { [scopeName: string]: string[] };\n\tprivate readonly _injectedEmbeddedLanguages: { [scopeName: string]: IValidEmbeddedLanguagesMap[] };\n\tprivate readonly _languageToScope: Map<string, string>;\n\tprivate readonly _grammarRegistry: Registry;\n\n\tconstructor(host: ITMGrammarFactoryHost, grammarDefinitions: IValidGrammarDefinition[], vscodeTextmate: typeof import('vscode-textmate'), onigLib: Promise<IOnigLib>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._initialState = vscodeTextmate.INITIAL;\n\t\tthis._scopeRegistry = new TMScopeRegistry();\n\t\tthis._injections = {};\n\t\tthis._injectedEmbeddedLanguages = {};\n\t\tthis._languageToScope = new Map<string, string>();\n\t\tthis._grammarRegistry = this._register(new vscodeTextmate.Registry({\n\t\t\tonigLib: onigLib,\n\t\t\tloadGrammar: async (scopeName: string) => {\n\t\t\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\t\t\tif (!grammarDefinition) {\n\t\t\t\t\tthis._host.logTrace(`No grammar found for scope ${scopeName}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst location = grammarDefinition.location;\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this._host.readFile(location);\n\t\t\t\t\treturn vscodeTextmate.parseRawGrammar(content, location.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetInjections: (scopeName: string) => {\n\t\t\t\tconst scopeParts = scopeName.split('.');\n\t\t\t\tlet injections: string[] = [];\n\t\t\t\tfor (let i = 1; i <= scopeParts.length; i++) {\n\t\t\t\t\tconst subScopeName = scopeParts.slice(0, i).join('.');\n\t\t\t\t\tinjections = [...injections, ...(this._injections[subScopeName] || [])];\n\t\t\t\t}\n\t\t\t\treturn injections;\n\t\t\t}\n\t\t}));\n\n\t\tfor (const validGrammar of grammarDefinitions) {\n\t\t\tthis._scopeRegistry.register(validGrammar);\n\n\t\t\tif (validGrammar.injectTo) {\n\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\tlet injections = this._injections[injectScope];\n\t\t\t\t\tif (!injections) {\n\t\t\t\t\t\tthis._injections[injectScope] = injections = [];\n\t\t\t\t\t}\n\t\t\t\t\tinjections.push(validGrammar.scopeName);\n\t\t\t\t}\n\n\t\t\t\tif (validGrammar.embeddedLanguages) {\n\t\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\t\tlet injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n\t\t\t\t\t\tif (!injectedEmbeddedLanguages) {\n\t\t\t\t\t\t\tthis._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinjectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validGrammar.language) {\n\t\t\t\tthis._languageToScope.set(validGrammar.language, validGrammar.scopeName);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic has(languageId: string): boolean {\n\t\treturn this._languageToScope.has(languageId);\n\t}\n\n\tpublic setTheme(theme: IRawTheme, colorMap: string[]): void {\n\t\tthis._grammarRegistry.setTheme(theme, colorMap);\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._grammarRegistry.getColorMap();\n\t}\n\n\tpublic async createGrammar(languageId: string, encodedLanguageId: number): Promise<ICreateGrammarResult> {\n\t\tconst scopeName = this._languageToScope.get(languageId);\n\t\tif (typeof scopeName !== 'string') {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\tif (!grammarDefinition) {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst embeddedLanguages = grammarDefinition.embeddedLanguages;\n\t\tif (this._injectedEmbeddedLanguages[scopeName]) {\n\t\t\tconst injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n\t\t\tfor (const injected of injectedEmbeddedLanguages) {\n\t\t\t\tfor (const scope of Object.keys(injected)) {\n\t\t\t\t\tembeddedLanguages[scope] = injected[scope];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n\n\t\tlet grammar: IGrammar | null;\n\n\t\ttry {\n\t\t\tgrammar = await this._grammarRegistry.loadGrammarWithConfiguration(\n\t\t\t\tscopeName,\n\t\t\t\tencodedLanguageId,\n\t\t\t\t{\n\t\t\t\t\tembeddedLanguages,\n\t\t\t\t\ttokenTypes: <any>grammarDefinition.tokenTypes,\n\t\t\t\t\tbalancedBracketSelectors: grammarDefinition.balancedBracketSelectors,\n\t\t\t\t\tunbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (err.message && err.message.startsWith('No grammar provided for')) {\n\t\t\t\t// No TM grammar defined\n\t\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn {\n\t\t\tlanguageId: languageId,\n\t\t\tgrammar: grammar,\n\t\t\tinitialState: this._initialState,\n\t\t\tcontainsEmbeddedLanguages: containsEmbeddedLanguages,\n\t\t\tsourceExtensionId: grammarDefinition.sourceExtensionId,\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { observableValue } from 'vs/base/common/observable';\nimport { URI } from 'vs/base/common/uri';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent, MirrorTextModel } from 'vs/editor/common/model/mirrorTextModel';\nimport { TokenizerWithStateStore } from 'vs/editor/common/model/textModelTokens';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { TextMateTokenizationSupport } from 'vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport';\nimport { TokenizationSupportWithLineLimit } from 'vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit';\nimport { StateDeltas } from 'vs/workbench/services/textMate/browser/workerHost/textMateWorkerHost';\nimport { StackDiff, StateStack, diffStateStacksRefEq } from 'vscode-textmate';\nimport { TextMateTokenizationWorker } from './textMate.worker';\n\nexport class TextMateWorkerModel extends MirrorTextModel {\n\tprivate _tokenizationStateStore: TokenizerWithStateStore<StateStack> | null = null;\n\tprivate _isDisposed: boolean = false;\n\tprivate readonly _maxTokenizationLineLength = observableValue(\n\t\t'_maxTokenizationLineLength',\n\t\t-1\n\t);\n\n\tconstructor(\n\t\turi: URI,\n\t\tlines: string[],\n\t\teol: string,\n\t\tversionId: number,\n\t\tprivate readonly _worker: TextMateTokenizationWorker,\n\t\tprivate _languageId: string,\n\t\tprivate _encodedLanguageId: LanguageId,\n\t\tmaxTokenizationLineLength: number,\n\t) {\n\t\tsuper(uri, lines, eol, versionId);\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t\tthis._resetTokenization();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic onLanguageId(languageId: string, encodedLanguageId: LanguageId): void {\n\t\tthis._languageId = languageId;\n\t\tthis._encodedLanguageId = encodedLanguageId;\n\t\tthis._resetTokenization();\n\t}\n\n\tprivate readonly tokenizeDebouncer = new RunOnceScheduler(\n\t\t() => this._tokenize(),\n\t\t10\n\t);\n\n\toverride onEvents(e: IModelChangedEvent): void {\n\t\tsuper.onEvents(e);\n\n\t\tif (this._tokenizationStateStore) {\n\t\t\tthis._tokenizationStateStore.store.acceptChanges(e.changes);\n\t\t}\n\t\tthis.tokenizeDebouncer.schedule();\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(maxTokenizationLineLength: number): void {\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t}\n\n\tpublic retokenize(startLineNumber: number, endLineNumberExclusive: number) {\n\t\tif (this._tokenizationStateStore) {\n\t\t\tthis._tokenizationStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t\t\tthis.tokenizeDebouncer.schedule();\n\t\t}\n\t}\n\n\tprivate _resetTokenization(): void {\n\t\tthis._tokenizationStateStore = null;\n\n\t\tconst languageId = this._languageId;\n\t\tconst encodedLanguageId = this._encodedLanguageId;\n\t\tthis._worker.getOrCreateGrammar(languageId, encodedLanguageId).then((r) => {\n\t\t\tif (\n\t\t\t\tthis._isDisposed ||\n\t\t\t\tlanguageId !== this._languageId ||\n\t\t\t\tencodedLanguageId !== this._encodedLanguageId ||\n\t\t\t\t!r\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (r.grammar) {\n\t\t\t\tconst tokenizationSupport = new TokenizationSupportWithLineLimit(\n\t\t\t\t\tthis._encodedLanguageId,\n\t\t\t\t\tnew TextMateTokenizationSupport(r.grammar, r.initialState, false, undefined, undefined,\n\t\t\t\t\t\t(timeMs, lineLength) => { this._worker.reportTokenizationTime(timeMs, languageId, r.sourceExtensionId, lineLength); }),\n\t\t\t\t\tthis._maxTokenizationLineLength\n\t\t\t\t);\n\t\t\t\tthis._tokenizationStateStore = new TokenizerWithStateStore(this._lines.length, tokenizationSupport);\n\t\t\t} else {\n\t\t\t\tthis._tokenizationStateStore = null;\n\t\t\t}\n\t\t\tthis._tokenize();\n\t\t});\n\t}\n\n\tprivate _tokenize(): void {\n\t\tif (this._isDisposed || !this._tokenizationStateStore) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startTime = new Date().getTime();\n\n\t\twhile (true) {\n\t\t\tlet tokenizedLines = 0;\n\t\t\tconst tokenBuilder = new ContiguousMultilineTokensBuilder();\n\t\t\tconst stateDeltaBuilder = new StateDeltaBuilder();\n\n\t\t\twhile (true) {\n\t\t\t\tconst lineNumberToTokenize = this._tokenizationStateStore.store.getFirstInvalidEndStateLineNumber();\n\t\t\t\tif (lineNumberToTokenize === null || tokenizedLines > 200) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttokenizedLines++;\n\n\t\t\t\tconst text = this._lines[lineNumberToTokenize - 1];\n\t\t\t\tconst lineStartState = this._tokenizationStateStore.getStartState(lineNumberToTokenize)!;\n\t\t\t\tconst r = this._tokenizationStateStore.tokenizationSupport.tokenizeEncoded(text, true, lineStartState);\n\t\t\t\tif (this._tokenizationStateStore.store.setEndState(lineNumberToTokenize, r.endState as StateStack)) {\n\t\t\t\t\tconst delta = diffStateStacksRefEq(lineStartState, r.endState as StateStack);\n\t\t\t\t\tstateDeltaBuilder.setState(lineNumberToTokenize, delta);\n\t\t\t\t} else {\n\t\t\t\t\tstateDeltaBuilder.setState(lineNumberToTokenize, null);\n\t\t\t\t}\n\n\t\t\t\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\t\t\t\ttokenBuilder.add(lineNumberToTokenize, r.tokens);\n\n\t\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\t\tif (deltaMs > 20) {\n\t\t\t\t\t// yield to check for changes\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenizedLines === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst stateDeltas = stateDeltaBuilder.getStateDeltas();\n\t\t\tthis._worker.setTokensAndStates(\n\t\t\t\tthis._uri,\n\t\t\t\tthis._versionId,\n\t\t\t\ttokenBuilder.serialize(),\n\t\t\t\tstateDeltas\n\t\t\t);\n\n\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\tif (deltaMs > 20) {\n\t\t\t\t// yield to check for changes\n\t\t\t\tsetTimeout(() => this._tokenize(), 3);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass StateDeltaBuilder {\n\tprivate _lastStartLineNumber: number = -1;\n\tprivate _stateDeltas: StateDeltas[] = [];\n\n\tpublic setState(lineNumber: number, stackDiff: StackDiff | null): void {\n\t\tif (lineNumber === this._lastStartLineNumber + 1) {\n\t\t\tthis._stateDeltas[this._stateDeltas.length - 1].stateDeltas.push(stackDiff);\n\t\t} else {\n\t\t\tthis._stateDeltas.push({ startLineNumber: lineNumber, stateDeltas: [stackDiff] });\n\t\t}\n\t\tthis._lastStartLineNumber = lineNumber;\n\t}\n\n\tpublic getStateDeltas(): StateDeltas[] {\n\t\treturn this._stateDeltas;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent } from 'vs/editor/common/model/mirrorTextModel';\nimport { IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport type { StateDeltas, TextMateWorkerHost } from 'vs/workbench/services/textMate/browser/workerHost/textMateWorkerHost';\nimport { ICreateGrammarResult, TMGrammarFactory } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, IValidTokenTypeMap } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport { IOnigLib, IRawTheme } from 'vscode-textmate';\nimport { TextMateWorkerModel } from './textMateWorkerModel';\n\nexport interface ICreateData {\n\tgrammarDefinitions: IValidGrammarDefinitionDTO[];\n\ttextmateMainUri: string;\n\tonigurumaMainUri: string;\n\tonigurumaWASMUri: string;\n}\n\nexport interface IValidGrammarDefinitionDTO {\n\tlocation: UriComponents;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport class TextMateTokenizationWorker {\n\n\tprivate readonly _host: TextMateWorkerHost;\n\tprivate readonly _models: { [uri: string]: TextMateWorkerModel } = Object.create(null);\n\tprivate readonly _grammarCache: Promise<ICreateGrammarResult>[] = [];\n\tprivate readonly _grammarFactory: Promise<TMGrammarFactory | null>;\n\n\tconstructor(ctx: IWorkerContext<TextMateWorkerHost>, private readonly createData: ICreateData) {\n\t\tthis._host = ctx.host;\n\t\tconst grammarDefinitions = createData.grammarDefinitions.map<IValidGrammarDefinition>((def) => {\n\t\t\treturn {\n\t\t\t\tlocation: URI.revive(def.location),\n\t\t\t\tlanguage: def.language,\n\t\t\t\tscopeName: def.scopeName,\n\t\t\t\tembeddedLanguages: def.embeddedLanguages,\n\t\t\t\ttokenTypes: def.tokenTypes,\n\t\t\t\tinjectTo: def.injectTo,\n\t\t\t\tbalancedBracketSelectors: def.balancedBracketSelectors,\n\t\t\t\tunbalancedBracketSelectors: def.unbalancedBracketSelectors,\n\t\t\t\tsourceExtensionId: def.sourceExtensionId,\n\t\t\t};\n\t\t});\n\t\tthis._grammarFactory = this._loadTMGrammarFactory(grammarDefinitions);\n\t}\n\n\tprivate async _loadTMGrammarFactory(grammarDefinitions: IValidGrammarDefinition[]): Promise<TMGrammarFactory> {\n\t\tconst uri = this.createData.textmateMainUri;\n\t\tconst vscodeTextmate = await import(uri);\n\t\tconst vscodeOniguruma = await import(this.createData.onigurumaMainUri);\n\t\tconst response = await fetch(this.createData.onigurumaWASMUri);\n\n\t\t// Using the response directly only works if the server sets the MIME type 'application/wasm'.\n\t\t// Otherwise, a TypeError is thrown when using the streaming compiler.\n\t\t// We therefore use the non-streaming compiler :(.\n\t\tconst bytes = await response.arrayBuffer();\n\t\tawait vscodeOniguruma.loadWASM(bytes);\n\n\t\tconst onigLib: Promise<IOnigLib> = Promise.resolve({\n\t\t\tcreateOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),\n\t\t\tcreateOnigString: (str) => vscodeOniguruma.createOnigString(str)\n\t\t});\n\n\t\treturn new TMGrammarFactory({\n\t\t\tlogTrace: (msg: string) => {/* console.log(msg) */ },\n\t\t\tlogError: (msg: string, err: any) => console.error(msg, err),\n\t\t\treadFile: (resource: URI) => this._host.readFile(resource)\n\t\t}, grammarDefinitions, vscodeTextmate, onigLib);\n\t}\n\n\t// #region called by renderer\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tconst uri = URI.revive(data.uri);\n\t\tconst key = uri.toString();\n\t\tthis._models[key] = new TextMateWorkerModel(uri, data.lines, data.EOL, data.versionId, this, data.languageId, data.encodedLanguageId, data.maxTokenizationLineLength);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, e: IModelChangedEvent): void {\n\t\tthis._models[strURL].onEvents(e);\n\t}\n\n\tpublic retokenize(strURL: string, startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._models[strURL].retokenize(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic acceptModelLanguageChanged(strURL: string, newLanguageId: string, newEncodedLanguageId: LanguageId): void {\n\t\tthis._models[strURL].onLanguageId(newLanguageId, newEncodedLanguageId);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (this._models[strURL]) {\n\t\t\tthis._models[strURL].dispose();\n\t\t\tdelete this._models[strURL];\n\t\t}\n\t}\n\n\tpublic async acceptTheme(theme: IRawTheme, colorMap: string[]): Promise<void> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tgrammarFactory?.setTheme(theme, colorMap);\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(strURL: string, value: number): void {\n\t\tthis._models[strURL].acceptMaxTokenizationLineLength(value);\n\t}\n\n\t// #endregion\n\n\t// #region called by worker model\n\n\tpublic async getOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tif (!grammarFactory) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\t\tif (!this._grammarCache[encodedLanguageId]) {\n\t\t\tthis._grammarCache[encodedLanguageId] = grammarFactory.createGrammar(languageId, encodedLanguageId);\n\t\t}\n\t\treturn this._grammarCache[encodedLanguageId];\n\t}\n\n\tpublic setTokensAndStates(resource: URI, versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void {\n\t\tthis._host.setTokensAndStates(resource, versionId, tokens, stateDeltas);\n\t}\n\n\tpublic reportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number): void {\n\t\tthis._host.reportTokenizationTime(timeMs, languageId, sourceExtensionId, lineLength);\n\t}\n\n\t// #endregion\n}\n\nexport interface IRawModelData {\n\turi: UriComponents;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n\tlanguageId: string;\n\tencodedLanguageId: LanguageId;\n\tmaxTokenizationLineLength: number;\n}\n\nexport function create(ctx: IWorkerContext<TextMateWorkerHost>, createData: ICreateData): TextMateTokenizationWorker {\n\treturn new TextMateTokenizationWorker(ctx, createData);\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","globalObservableLogger","$Ic","logger","exports","$Jc","$Kc","text","consoleTextToArgs","normalText","repeat","info","styled","formatValue","observable","formatKind","changes","o","derived","existingHandleChange","change","changedObservables","autorun","transaction","transactionName","styles","data","firstArg","process","t","item","kind","padStr","options","objToCss","styleObj","styleString","propName","propValue","style","value","availableLen","formatArray","formatObject","first","val","key","str","count","length","$pc","debugName","fn","$uc","$qc","$rc","$tc","$sc","store","lifecycle_1","disposable","reader","changeSummary","AutorunState","h","j","logging_1","emptySet","d","assert_1","$vc","name","handler","_lastValue","newValue","lastValue","_derived","$Pc","$Qc","$Vc","$Rc","observer","$Sc","getDebugName","tx","$Uc","$Tc","b","c","updatingObservers","fnSrc","match","$Wc","initialValue","$Xc","_tx","oldValue","$Yc","$Zc","$Lc","computeFn","$Oc","$Mc","$Nc","r","base_1","DerivedState","k","l","m","n","p","hadValue","didChange","_observable","propagateBeginUpdate","observers","errors_1","shouldReact","wasUpToDate","shouldCallBeginUpdate","shouldCallEndUpdate","$wc","ConstObservable","a","$xc","promise","$yc","predicate","resolve","didRun","shouldDispose","autorun_1","currentState","$zc","event","getValue","$Ac","args","$Bc","FromEventObservableSignal","f","$Cc","ObservableSignal","$Dc","debounceMs","disposableStore","debouncedObservable","timeout","$Ec","timeoutMs","$Fc","forceRecompute","KeepAliveObserver","$Gc","derived_1","$Hc","counter","__exportStar","utils_1","$tb","obj","candidate","$ub","$vb","$wb","reducer","WriteableStreamImpl","e","error","listener","callback","listeners","index","fullDataBuffer","pendingWritePromises","pendingWritePromise","$xb","readable","chunks","chunk","$yb","maxChunks","lastReadChunk","$zb","stream","reject","$Ab","destroyed","$Bb","streamListeners","buffer","dataListener","errorListener","endListener","$Cb","$Db","$Eb","consumed","$Fb","transformer","target","$Gb","prefix","prefixHandled","$Hb","hasBuffer","indexOfTable","lazy_1","textEncoder","textDecoder","$Ib","byteLength","actual","source","buffers","totalLength","ret","offset","element","start","end","array","$Lb","$Mb","$Nb","$Ob","$Pb","$Qb","subarray","needle","needleLen","haystack","haystackLen","table","$Jb","$Kb","destination","$Rb","streams","$Sb","$Tb","$Ub","bufferedStream","$Vb","$Wb","$Xb","$Yb","$Zb","$1b","encoded","building","remainder","bufi","append","code","unpadded","base64Alphabet","base64UrlSafeAlphabet","$2b","padded","urlSafe","dictionary","output","$Ae","$Be","osPath","path_1","$Ce","$De","path","sep","firstLetter","pos","$Ie","$Ee","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","$Fe","isWindowsOS","invalidFileChars","$Ge","pathA","pathB","ignoreCase","identityEquals","strings_1","$He","base","parentCandidate","separator","sepOffset","char0","$Je","cwd","$Ke","pathNormalized","$Le","$Me","$Ne","$Oe","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","$Pe","parent","randomLength","suffix","pathCharsTouse","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","uri","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","$Tf","$Uf","uri1","uri2","ignoreFragment","network_1","extpath","resource","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","isRootSep","_","$cg","items","resourceAccessor","distinctParents","candidateResource","otherItem","DataUri","parseMetaData","dataUri","metadata","property","mime","$dg","localScheme","$eg","$fg","cancellation_1","thenable","subscription","onfinally","$gg","token","defaultValue","ref","$hg","$ig","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","$jg","onTimeout","promiseResolve","timer","$kg","$lg","promiseFactory","onComplete","$mg","promiseTask","$ng","newPromise","timeoutDeferred","scheduled","handle","microtaskDeferred","$og","defaultDelay","task","delay","symbols_1","$pg","$qg","$rg","autoOpenTimeMs","$sg","millis","$tg","$ug","promiseFactories","results","next","thenHandler","$vg","shouldStop","loop","factory","$wg","promiseList","todo","finish","$xg","maxDegreeOfParalellism","event_1","iLimitedTask","$yg","$zg","$Lg","queue","extUri","resources_1","drainer","$Ag","runner","$Bg","interval","$Cg","$Dg","$Eg","unit","units","$Fg","g","disposed","$Hg","executor","$Ig","retries","lastError","$Jg","taskId","onCancel","run","promiseReject","$Kg","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","$Mg","writer","emitter","iterables","iterable","mapFn","filterFn","values","$Ng","$Og","innerIterable","StringEOL","$cs","eolCount","firstLineLength","lastLineStart","eol","chr","LanguageId","FontStyle","ColorId","StandardTokenType","MetadataConsts","$as","className","fontStyle","colorMap","foreground","textDecoration","$WB","oldLength","newLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arr","arrays_1","other","$UB","languageId","state","languages_1","$VB","tokens","$ds","lineContent","decoder","defaultMetadata","sliceFromTokenIndex","sliceTokenCount","tokenIndex","encodedTokenAttributes_1","startOffset","endOffset","deltaOffset","SliceLineTokens","lineTextLength","lastTokenIndex","desiredIndex","low","high","mid","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenEndOffset","$fs","lineTokens","toChIndex","fromChIndex","$gs","tokensCount","fromTokenIndex","lineTokens_1","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tmp","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","$hs","buff","view32","startLineNumber","buffer_1","byteCount","lineRange_1","lineNumber","range","eolCounter_1","position_1","firstLineIndex","lastLineIndex","deletedLinesCount","contiguousTokensEditing_1","lastLineTokens","deletedBefore","position","lineIndex","arrays","$XB","contiguousMultilineTokens_1","last","size","Constants","$YB","lineCount","tokenizationSupport","$1B","$ZB","_textModel","_languageIdCodec","builder","nextLineNumber","lineStartState","safeTokenize","character","newText","curLineContent","newLineContent","firstInvalidLineNumber","endLineNumber","nonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","$2B","$3B","offsetRange_1","min","newLineCount","fixedArray_1","oldState","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","nullTokenize_1","$4B","async_1","deadline","endTime","execute","contiguousMultilineTokensBuilder_1","sw","stopwatch_1","endLineNumberExclusive","$oyb","textModel","shouldMeasure","textMateResult","timeMS","seenLanguages","endState","$pyb","observable_1","$ryb","def","existingRegistration","resources","scopeName","$tyb","grammarDefinitions","vscodeTextmate","onigLib","TMScopeRegistry_1","grammarDefinition","location","content","scopeParts","injections","subScopeName","validGrammar","injectScope","injectedEmbeddedLanguages","theme","encodedLanguageId","embeddedLanguages","injected","scope","containsEmbeddedLanguages","grammar","$uyb","mirrorTextModel_1","lines","versionId","q","s","maxTokenizationLineLength","tokenizationSupportWithLineLimit_1","textMateTokenizationSupport_1","timeMs","lineLength","textModelTokens_1","startTime","tokenizedLines","tokenBuilder","stateDeltaBuilder","StateDeltaBuilder","lineNumberToTokenize","vscode_textmate_1","stateDeltas","stackDiff","TextMateTokenizationWorker","ctx","resolve_1","reject_1","vscodeOniguruma","resolve_2","reject_2","bytes","sources","TMGrammarFactory_1","msg","textMateWorkerModel_1","strURL","newLanguageId","newEncodedLanguageId","grammarFactory","sourceExtensionId","create","createData"],"file":"textMate.worker.js"}
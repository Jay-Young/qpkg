{"version":3,"sources":["out-vscode-reh-web/vs/platform/profiling/electron-sandbox/fake","out-vscode-reh-web/vs/platform/profiling/electron-sandbox/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/ternarySearchTree.ts","out-vscode-reh-web/vs/platform/profiling/electron-sandbox/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/instantiation/common/instantiation.ts","out-vscode-reh-web/vs/platform/profiling/electron-sandbox/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/profiling/common/profiling.ts","out-vscode-reh-web/vs/platform/profiling/electron-sandbox/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/profiling/common/profilingModel.ts","out-vscode-reh-web/vs/platform/profiling/electron-sandbox/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/profiling/electron-sandbox/profileAnalysisWorker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { shuffle } from 'vs/base/common/arrays';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class ConfigKeysIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Period) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _valueLen!: number;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\tthis._value = key;\n\t\tthis._valueLen = key.length;\n\t\tfor (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n\t\t\tconst ch = this._value.charCodeAt(pos);\n\t\t\tif (!(ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._valueLen;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._valueLen; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _ignorePathCasing: (uri: URI) => boolean,\n\t\tprivate readonly _ignoreQueryAndFragment: (uri: URI) => boolean) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (!this._ignoreQueryAndFragment(key)) {\n\t\t\tif (this._value.query) {\n\t\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t\t}\n\t\t\tif (this._value.fragment) {\n\t\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t\t}\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\nclass TernarySearchTreeNode<K, V> {\n\theight: number = 1;\n\tsegment!: string;\n\tvalue: V | undefined;\n\tkey: K | undefined;\n\tleft: TernarySearchTreeNode<K, V> | undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n\n\trotateLeft() {\n\t\tconst tmp = this.right!;\n\t\tthis.right = tmp.left;\n\t\ttmp.left = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\trotateRight() {\n\t\tconst tmp = this.left!;\n\t\tthis.left = tmp.right;\n\t\ttmp.right = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\tupdateHeight() {\n\t\tthis.height = 1 + Math.max(this.heightLeft, this.heightRight);\n\t}\n\n\tbalanceFactor() {\n\t\treturn this.heightRight - this.heightLeft;\n\t}\n\n\tget heightLeft() {\n\t\treturn this.left?.height ?? 0;\n\t}\n\n\tget heightRight() {\n\t\treturn this.right?.height ?? 0;\n\t}\n}\n\nconst enum Dir {\n\tLeft = -1,\n\tMid = 0,\n\tRight = 1\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing: (key: URI) => boolean = () => false, ignoreQueryAndFragment: (key: URI) => boolean = () => false): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n\t}\n\n\tstatic forPaths<E>(ignorePathCasing = false): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator(undefined, !ignorePathCasing));\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tstatic forConfigKeys<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new ConfigKeysIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\t/**\n\t * Fill the tree with the same value of the given keys\n\t */\n\tfill(element: V, keys: readonly K[]): void;\n\t/**\n\t * Fill the tree with given [key,value]-tuples\n\t */\n\tfill(values: readonly [K, V][]): void;\n\tfill(values: readonly [K, V][] | V, keys?: readonly K[]): void {\n\t\tif (keys) {\n\t\t\tconst arr = keys.slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const k of arr) {\n\t\t\t\tthis.set(k, (<V>values));\n\t\t\t}\n\t\t} else {\n\t\t\tconst arr = (<[K, V][]>values).slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const entry of arr) {\n\t\t\t\tthis.set(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\n\t\t// find insert_node\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// set value\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\n\t\t// balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\t// needs rotate\n\t\t\t\tconst d1 = stack[i][0];\n\t\t\t\tconst d2 = stack[i + 1][0];\n\n\t\t\t\tif (d1 === Dir.Right && d2 === Dir.Right) {\n\t\t\t\t\t//right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Left) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else if (d1 === Dir.Right && d2 === Dir.Left) {\n\t\t\t\t\t// right, left -> double rotate right, left\n\t\t\t\t\tnode.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Right) {\n\t\t\t\t\t// left, right -> double rotate left, right\n\t\t\t\t\tnode.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// patch path to parent\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = stack[0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._getNode(key)?.value;\n\t}\n\n\tprivate _getNode(key: K) {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\thas(key: K): boolean {\n\t\tconst node = this._getNode(key);\n\t\treturn !(node?.value === undefined && node?.mid === undefined);\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\t// node not found\n\t\t\treturn;\n\t\t}\n\n\t\tif (superStr) {\n\t\t\t// removing children, reset height\n\t\t\tnode.left = undefined;\n\t\t\tnode.mid = undefined;\n\t\t\tnode.right = undefined;\n\t\t\tnode.height = 1;\n\t\t} else {\n\t\t\t// removing element\n\t\t\tnode.key = undefined;\n\t\t\tnode.value = undefined;\n\t\t}\n\n\t\t// BST node removal\n\t\tif (!node.mid && !node.value) {\n\t\t\tif (node.left && node.right) {\n\t\t\t\t// full node\n\t\t\t\t// replace deleted-node with the min-node of the right branch.\n\t\t\t\t// If there is no true min-node leave things as they are\n\t\t\t\tconst min = this._min(node.right);\n\t\t\t\tif (min.key) {\n\t\t\t\t\tconst { key, value, segment } = min;\n\t\t\t\t\tthis._delete(min.key!, false);\n\t\t\t\t\tnode.key = key;\n\t\t\t\t\tnode.value = value;\n\t\t\t\t\tnode.segment = segment;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// empty or half empty\n\t\t\t\tconst newChild = node.left ?? node.right;\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild; break;\n\t\t\t\t\t\tcase Dir.Right: parent.right = newChild; break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = newChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// AVL balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf > 1) {\n\t\t\t\t// right heavy\n\t\t\t\tif (node.right!.balanceFactor() >= 0) {\n\t\t\t\t\t// right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t} else {\n\t\t\t\t\t// right, left -> double rotate\n\t\t\t\t\tnode.right = node.right!.rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t}\n\n\t\t\t} else if (bf < -1) {\n\t\t\t\t// left heavy\n\t\t\t\tif (node.left!.balanceFactor() <= 0) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t} else {\n\t\t\t\t\t// left, right -> double rotate\n\t\t\t\t\tnode.left = node.left!.rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch path to parent\n\t\t\tif (i > 0) {\n\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._root = stack[0][1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _min(node: TernarySearchTreeNode<K, V>): TernarySearchTreeNode<K, V> {\n\t\twhile (node.left) {\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: K): IterableIterator<[K, V]> | undefined {\n\t\treturn this._findSuperstrOrElement(key, false);\n\t}\n\n\tprivate _findSuperstrOrElement(key: K, allowValue: true): IterableIterator<[K, V]> | V | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: false): IterableIterator<[K, V]> | undefined;\n\tprivate _findSuperstrOrElement(key: K, allowValue: boolean): IterableIterator<[K, V]> | V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tif (allowValue) {\n\t\t\t\t\t\treturn node.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn this._entries(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\thasElementOrSubtree(key: K): boolean {\n\t\treturn this._findSuperstrOrElement(key, true) !== undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => any): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate _entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tconst result: [K, V][] = [];\n\t\tthis._dfsEntries(node, result);\n\t\treturn result[Symbol.iterator]();\n\t}\n\n\tprivate _dfsEntries(node: TernarySearchTreeNode<K, V> | undefined, bucket: [K, V][]) {\n\t\t// DFS\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left) {\n\t\t\tthis._dfsEntries(node.left, bucket);\n\t\t}\n\t\tif (node.value) {\n\t\t\tbucket.push([node.key!, node.value]);\n\t\t}\n\t\tif (node.mid) {\n\t\t\tthis._dfsEntries(node.mid, bucket);\n\t\t}\n\t\tif (node.right) {\n\t\t\tthis._dfsEntries(node.right, bucket);\n\t\t}\n\t}\n\n\t// for debug/testing\n\t_isBalanced(): boolean {\n\t\tconst nodeIsBalanced = (node: TernarySearchTreeNode<any, any> | undefined): boolean => {\n\t\t\tif (!node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n\t\t};\n\t\treturn nodeIsBalanced(this._root);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as descriptors from './descriptors';\nimport { ServiceCollection } from './serviceCollection';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\nexport type GetLeadingNonServiceArgs<TArgs extends any[]> =\n\tTArgs extends [] ? []\n\t: TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst>\n\t: TArgs;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { basename, isAbsolute, join } from 'vs/base/common/path';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\nexport interface IV8Profile {\n\tnodes: IV8ProfileNode[];\n\tsamples?: number[];\n\ttimeDeltas?: number[];\n\tstartTime: number;\n\tendTime: number;\n}\n\nexport interface IV8ProfileNode {\n\tid: number;\n\thitCount?: number;\n\tchildren?: number[];\n\tcallFrame: IV8CallFrame;\n\tdeoptReason?: string;\n\tpositionTicks?: { line: number; ticks: number }[];\n}\n\nexport interface IV8CallFrame {\n\turl: string;\n\tscriptId: string;\n\tfunctionName: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport const IV8InspectProfilingService = createDecorator<IV8InspectProfilingService>('IV8InspectProfilingService');\n\nexport interface IV8InspectProfilingService {\n\n\t_serviceBrand: undefined;\n\n\tstartProfiling(options: { port: number }): Promise<string>;\n\n\tstopProfiling(sessionId: string): Promise<IV8Profile>;\n}\n\n\nexport namespace Utils {\n\n\texport function isValidProfile(profile: IV8Profile): profile is Required<IV8Profile> {\n\t\treturn Boolean(profile.samples && profile.timeDeltas);\n\t}\n\n\texport function rewriteAbsolutePaths(profile: IV8Profile, replace: string = 'noAbsolutePaths') {\n\t\tfor (const node of profile.nodes) {\n\t\t\tif (node.callFrame && node.callFrame.url) {\n\t\t\t\tif (isAbsolute(node.callFrame.url) || /^\\w[\\w\\d+.-]*:\\/\\/\\/?/.test(node.callFrame.url)) {\n\t\t\t\t\tnode.callFrame.url = join(replace, basename(node.callFrame.url));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn profile;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport type { IV8Profile, IV8ProfileNode } from 'vs/platform/profiling/common/profiling';\n\n// #region\n// https://github.com/microsoft/vscode-js-profile-visualizer/blob/6e7401128ee860be113a916f80fcfe20ac99418e/packages/vscode-js-profile-core/src/cpu/model.ts#L4\n\nexport interface IProfileModel {\n\tnodes: ReadonlyArray<IComputedNode>;\n\tlocations: ReadonlyArray<ILocation>;\n\tsamples: ReadonlyArray<number>;\n\ttimeDeltas: ReadonlyArray<number>;\n\trootPath?: string;\n\tduration: number;\n}\n\nexport interface IComputedNode {\n\tid: number;\n\tselfTime: number;\n\taggregateTime: number;\n\tchildren: number[];\n\tparent?: number;\n\tlocationId: number;\n}\n\nexport interface ISourceLocation {\n\tlineNumber: number;\n\tcolumnNumber: number;\n\t//   source: Dap.Source;\n\trelativePath?: string;\n}\n\nexport interface CdpCallFrame {\n\tfunctionName: string;\n\tscriptId: string;\n\turl: string;\n\tlineNumber: number;\n\tcolumnNumber: number;\n}\n\nexport interface CdpPositionTickInfo {\n\tline: number;\n\tticks: number;\n}\n\nexport interface INode {\n\tid: number;\n\t//   category: Category;\n\tcallFrame: CdpCallFrame;\n\tsrc?: ISourceLocation;\n}\n\nexport interface ILocation extends INode {\n\tselfTime: number;\n\taggregateTime: number;\n\tticks: number;\n}\n\nexport interface IAnnotationLocation {\n\tcallFrame: CdpCallFrame;\n\tlocations: ISourceLocation[];\n}\n\nexport interface IProfileNode extends IV8ProfileNode {\n\tlocationId?: number;\n\tpositionTicks?: (CdpPositionTickInfo & {\n\t\tstartLocationId?: number;\n\t\tendLocationId?: number;\n\t})[];\n}\n\nexport interface ICpuProfileRaw extends IV8Profile {\n\t//   $vscode?: IJsDebugAnnotations;\n\tnodes: IProfileNode[];\n}\n\n\n/**\n * Recursive function that computes and caches the aggregate time for the\n * children of the computed now.\n */\nconst computeAggregateTime = (index: number, nodes: IComputedNode[]): number => {\n\tconst row = nodes[index];\n\tif (row.aggregateTime) {\n\t\treturn row.aggregateTime;\n\t}\n\n\tlet total = row.selfTime;\n\tfor (const child of row.children) {\n\t\ttotal += computeAggregateTime(child, nodes);\n\t}\n\n\treturn (row.aggregateTime = total);\n};\n\nconst ensureSourceLocations = (profile: ICpuProfileRaw): ReadonlyArray<IAnnotationLocation> => {\n\n\tlet locationIdCounter = 0;\n\tconst locationsByRef = new Map<string, { id: number; callFrame: CdpCallFrame; location: ISourceLocation }>();\n\n\tconst getLocationIdFor = (callFrame: CdpCallFrame) => {\n\t\tconst ref = [\n\t\t\tcallFrame.functionName,\n\t\t\tcallFrame.url,\n\t\t\tcallFrame.scriptId,\n\t\t\tcallFrame.lineNumber,\n\t\t\tcallFrame.columnNumber,\n\t\t].join(':');\n\n\t\tconst existing = locationsByRef.get(ref);\n\t\tif (existing) {\n\t\t\treturn existing.id;\n\t\t}\n\t\tconst id = locationIdCounter++;\n\t\tlocationsByRef.set(ref, {\n\t\t\tid,\n\t\t\tcallFrame,\n\t\t\tlocation: {\n\t\t\t\tlineNumber: callFrame.lineNumber + 1,\n\t\t\t\tcolumnNumber: callFrame.columnNumber + 1,\n\t\t\t\t// source: {\n\t\t\t\t// \tname: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tpath: maybeFileUrlToPath(callFrame.url),\n\t\t\t\t// \tsourceReference: 0,\n\t\t\t\t// },\n\t\t\t},\n\t\t});\n\n\t\treturn id;\n\t};\n\n\tfor (const node of profile.nodes) {\n\t\tnode.locationId = getLocationIdFor(node.callFrame);\n\t\tnode.positionTicks = node.positionTicks?.map(tick => ({\n\t\t\t...tick,\n\t\t\t// weirdly, line numbers here are 1-based, not 0-based. The position tick\n\t\t\t// only gives line-level granularity, so 'mark' the entire range of source\n\t\t\t// code the tick refers to\n\t\t\tstartLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line - 1,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t\tendLocationId: getLocationIdFor({\n\t\t\t\t...node.callFrame,\n\t\t\t\tlineNumber: tick.line,\n\t\t\t\tcolumnNumber: 0,\n\t\t\t}),\n\t\t}));\n\t}\n\n\treturn [...locationsByRef.values()]\n\t\t.sort((a, b) => a.id - b.id)\n\t\t.map(l => ({ locations: [l.location], callFrame: l.callFrame }));\n};\n\n/**\n * Computes the model for the given profile.\n */\nexport const buildModel = (profile: ICpuProfileRaw): IProfileModel => {\n\tif (!profile.timeDeltas || !profile.samples) {\n\t\treturn {\n\t\t\tnodes: [],\n\t\t\tlocations: [],\n\t\t\tsamples: profile.samples || [],\n\t\t\ttimeDeltas: profile.timeDeltas || [],\n\t\t\t// rootPath: profile.$vscode?.rootPath,\n\t\t\tduration: profile.endTime - profile.startTime,\n\t\t};\n\t}\n\n\tconst { samples, timeDeltas } = profile;\n\tconst sourceLocations = ensureSourceLocations(profile);\n\tconst locations: ILocation[] = sourceLocations.map((l, id) => {\n\t\tconst src = l.locations[0]; //getBestLocation(profile, l.locations);\n\n\t\treturn {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\t// category: categorize(l.callFrame, src),\n\t\t\tcallFrame: l.callFrame,\n\t\t\tsrc,\n\t\t};\n\t});\n\n\tconst idMap = new Map<number /* id in profile */, number /* incrementing ID */>();\n\tconst mapId = (nodeId: number) => {\n\t\tlet id = idMap.get(nodeId);\n\t\tif (id === undefined) {\n\t\t\tid = idMap.size;\n\t\t\tidMap.set(nodeId, id);\n\t\t}\n\n\t\treturn id;\n\t};\n\n\t// 1. Created a sorted list of nodes. It seems that the profile always has\n\t// incrementing IDs, although they are just not initially sorted.\n\tconst nodes = new Array<IComputedNode>(profile.nodes.length);\n\tfor (let i = 0; i < profile.nodes.length; i++) {\n\t\tconst node = profile.nodes[i];\n\n\t\t// make them 0-based:\n\t\tconst id = mapId(node.id);\n\t\tnodes[id] = {\n\t\t\tid,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tlocationId: node.locationId as number,\n\t\t\tchildren: node.children?.map(mapId) || [],\n\t\t};\n\n\t\tfor (const child of node.positionTicks || []) {\n\t\t\tif (child.startLocationId) {\n\t\t\t\tlocations[child.startLocationId].ticks += child.ticks;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const node of nodes) {\n\t\tfor (const child of node.children) {\n\t\t\tnodes[child].parent = node.id;\n\t\t}\n\t}\n\n\t// 2. The profile samples are the 'bottom-most' node, the currently running\n\t// code. Sum of these in the self time.\n\tconst duration = profile.endTime - profile.startTime;\n\tlet lastNodeTime = duration - timeDeltas[0];\n\tfor (let i = 0; i < timeDeltas.length - 1; i++) {\n\t\tconst d = timeDeltas[i + 1];\n\t\tnodes[mapId(samples[i])].selfTime += d;\n\t\tlastNodeTime -= d;\n\t}\n\n\t// Add in an extra time delta for the last sample. `timeDeltas[0]` is the\n\t// time before the first sample, and the time of the last sample is only\n\t// derived (approximately) by the missing time in the sum of deltas. Save\n\t// some work by calculating it here.\n\tif (nodes.length) {\n\t\tnodes[mapId(samples[timeDeltas.length - 1])].selfTime += lastNodeTime;\n\t\ttimeDeltas.push(lastNodeTime);\n\t}\n\n\t// 3. Add the aggregate times for all node children and locations\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst node = nodes[i];\n\t\tconst location = locations[node.locationId];\n\t\tlocation.aggregateTime += computeAggregateTime(i, nodes);\n\t\tlocation.selfTime += node.selfTime;\n\t}\n\n\treturn {\n\t\tnodes,\n\t\tlocations,\n\t\tsamples: samples.map(mapId),\n\t\ttimeDeltas,\n\t\t// rootPath: profile.$vscode?.rootPath,\n\t\tduration,\n\t};\n};\n\nexport class BottomUpNode {\n\tpublic static root() {\n\t\treturn new BottomUpNode({\n\t\t\tid: -1,\n\t\t\tselfTime: 0,\n\t\t\taggregateTime: 0,\n\t\t\tticks: 0,\n\t\t\tcallFrame: {\n\t\t\t\tfunctionName: '(root)',\n\t\t\t\tlineNumber: -1,\n\t\t\t\tcolumnNumber: -1,\n\t\t\t\tscriptId: '0',\n\t\t\t\turl: '',\n\t\t\t},\n\t\t});\n\t}\n\n\tpublic children: { [id: number]: BottomUpNode } = {};\n\tpublic aggregateTime = 0;\n\tpublic selfTime = 0;\n\tpublic ticks = 0;\n\tpublic childrenSize = 0;\n\n\tpublic get id() {\n\t\treturn this.location.id;\n\t}\n\n\tpublic get callFrame() {\n\t\treturn this.location.callFrame;\n\t}\n\n\tpublic get src() {\n\t\treturn this.location.src;\n\t}\n\n\tconstructor(public readonly location: ILocation, public readonly parent?: BottomUpNode) { }\n\n\tpublic addNode(node: IComputedNode) {\n\t\tthis.selfTime += node.selfTime;\n\t\tthis.aggregateTime += node.aggregateTime;\n\t}\n\n}\n\nexport const processNode = (aggregate: BottomUpNode, node: IComputedNode, model: IProfileModel, initialNode = node) => {\n\tlet child = aggregate.children[node.locationId];\n\tif (!child) {\n\t\tchild = new BottomUpNode(model.locations[node.locationId], aggregate);\n\t\taggregate.childrenSize++;\n\t\taggregate.children[node.locationId] = child;\n\t}\n\n\tchild.addNode(initialNode);\n\n\tif (node.parent) {\n\t\tprocessNode(child, model.nodes[node.parent], model, initialNode);\n\t}\n};\n\n//#endregion\n\n\nexport interface BottomUpSample {\n\tselfTime: number;\n\ttotalTime: number;\n\tlocation: string;\n\tabsLocation: string;\n\turl: string;\n\tcaller: { percentage: number; absLocation: string; location: string }[];\n\tpercentage: number;\n\tisSpecial: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { basename } from 'vs/base/common/path';\nimport { TernarySearchTree } from 'vs/base/common/ternarySearchTree';\nimport { URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { IV8Profile, Utils } from 'vs/platform/profiling/common/profiling';\nimport { IProfileModel, BottomUpSample, buildModel, BottomUpNode, processNode, CdpCallFrame } from 'vs/platform/profiling/common/profilingModel';\nimport { BottomUpAnalysis, IProfileAnalysisWorker, ProfilingOutput } from 'vs/platform/profiling/electron-sandbox/profileAnalysisWorkerService';\n\nexport function create(): IRequestHandler {\n\treturn new ProfileAnalysisWorker();\n}\n\nclass ProfileAnalysisWorker implements IRequestHandler, IProfileAnalysisWorker {\n\n\t_requestHandlerBrand: any;\n\n\tanalyseBottomUp(profile: IV8Profile): BottomUpAnalysis {\n\t\tif (!Utils.isValidProfile(profile)) {\n\t\t\treturn { kind: ProfilingOutput.Irrelevant, samples: [] };\n\t\t}\n\n\t\tconst model = buildModel(profile);\n\t\tconst samples = bottomUp(model, 5)\n\t\t\t.filter(s => !s.isSpecial);\n\n\t\tif (samples.length === 0 || samples[0].percentage < 10) {\n\t\t\t// ignore this profile because 90% of the time is spent inside \"special\" frames\n\t\t\t// like idle, GC, or program\n\t\t\treturn { kind: ProfilingOutput.Irrelevant, samples: [] };\n\t\t}\n\n\t\treturn { kind: ProfilingOutput.Interesting, samples };\n\t}\n\n\tanalyseByUrlCategory(profile: IV8Profile, categories: [url: URI, category: string][]): [category: string, aggregated: number][] {\n\n\t\t// build search tree\n\t\tconst searchTree = TernarySearchTree.forUris<string>();\n\t\tsearchTree.fill(categories);\n\n\t\t// cost by categories\n\t\tconst model = buildModel(profile);\n\t\tconst aggegrateByCategory = new Map<string, number>();\n\n\t\tfor (const node of model.nodes) {\n\t\t\tconst loc = model.locations[node.locationId];\n\t\t\tlet category: string | undefined;\n\t\t\ttry {\n\t\t\t\tcategory = searchTree.findSubstr(URI.parse(loc.callFrame.url));\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\tif (!category) {\n\t\t\t\tcategory = printCallFrameShort(loc.callFrame);\n\t\t\t}\n\t\t\tconst value = aggegrateByCategory.get(category) ?? 0;\n\t\t\tconst newValue = value + node.selfTime;\n\t\t\taggegrateByCategory.set(category, newValue);\n\t\t}\n\n\t\tconst result: [string, number][] = [];\n\t\tfor (const [key, value] of aggegrateByCategory) {\n\t\t\tresult.push([key, value]);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction isSpecial(call: CdpCallFrame): boolean {\n\treturn call.functionName.startsWith('(') && call.functionName.endsWith(')');\n}\n\nfunction printCallFrameShort(frame: CdpCallFrame): string {\n\tlet result = frame.functionName || '(anonymous)';\n\tif (frame.url) {\n\t\tresult += '#';\n\t\tresult += basename(frame.url);\n\t\tif (frame.lineNumber >= 0) {\n\t\t\tresult += ':';\n\t\t\tresult += frame.lineNumber + 1;\n\t\t}\n\t\tif (frame.columnNumber >= 0) {\n\t\t\tresult += ':';\n\t\t\tresult += frame.columnNumber + 1;\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction printCallFrameStackLike(frame: CdpCallFrame): string {\n\tlet result = frame.functionName || '(anonymous)';\n\tif (frame.url) {\n\t\tresult += ' (';\n\t\tresult += frame.url;\n\t\tif (frame.lineNumber >= 0) {\n\t\t\tresult += ':';\n\t\t\tresult += frame.lineNumber + 1;\n\t\t}\n\t\tif (frame.columnNumber >= 0) {\n\t\t\tresult += ':';\n\t\t\tresult += frame.columnNumber + 1;\n\t\t}\n\t\tresult += ')';\n\t}\n\treturn result;\n}\n\nfunction getHeaviestLocationIds(model: IProfileModel, topN: number) {\n\tconst stackSelfTime: { [locationId: number]: number } = {};\n\tfor (const node of model.nodes) {\n\t\tstackSelfTime[node.locationId] = (stackSelfTime[node.locationId] || 0) + node.selfTime;\n\t}\n\n\tconst locationIds = Object.entries(stackSelfTime)\n\t\t.sort(([, a], [, b]) => b - a)\n\t\t.slice(0, topN)\n\t\t.map(([locationId]) => Number(locationId));\n\n\treturn new Set(locationIds);\n}\n\nfunction bottomUp(model: IProfileModel, topN: number) {\n\tconst root = BottomUpNode.root();\n\tconst locationIds = getHeaviestLocationIds(model, topN);\n\n\tfor (const node of model.nodes) {\n\t\tif (locationIds.has(node.locationId)) {\n\t\t\tprocessNode(root, node, model);\n\t\t\troot.addNode(node);\n\t\t}\n\t}\n\n\tconst result = Object.values(root.children)\n\t\t.sort((a, b) => b.selfTime - a.selfTime)\n\t\t.slice(0, topN);\n\n\tconst samples: BottomUpSample[] = [];\n\n\tfor (const node of result) {\n\n\t\tconst sample: BottomUpSample = {\n\t\t\tselfTime: Math.round(node.selfTime / 1000),\n\t\t\ttotalTime: Math.round(node.aggregateTime / 1000),\n\t\t\tlocation: printCallFrameShort(node.callFrame),\n\t\t\tabsLocation: printCallFrameStackLike(node.callFrame),\n\t\t\turl: node.callFrame.url,\n\t\t\tcaller: [],\n\t\t\tpercentage: Math.round(node.selfTime / (model.duration / 100)),\n\t\t\tisSpecial: isSpecial(node.callFrame)\n\t\t};\n\n\t\t// follow the heaviest caller paths\n\t\tconst stack = [node];\n\t\twhile (stack.length) {\n\t\t\tconst node = stack.pop()!;\n\t\t\tlet top: BottomUpNode | undefined;\n\t\t\tfor (const candidate of Object.values(node.children)) {\n\t\t\t\tif (!top || top.selfTime < candidate.selfTime) {\n\t\t\t\t\ttop = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tconst percentage = Math.round(top.selfTime / (node.selfTime / 100));\n\t\t\t\tsample.caller.push({\n\t\t\t\t\tpercentage,\n\t\t\t\t\tlocation: printCallFrameShort(top.callFrame),\n\t\t\t\t\tabsLocation: printCallFrameStackLike(top.callFrame),\n\t\t\t\t});\n\t\t\t\tstack.push(top);\n\t\t\t}\n\t\t}\n\n\t\tsamples.push(sample);\n\t}\n\n\treturn samples;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","$nh","key","a","aCode","thisCode","exports","$oh","justSeps","strings_1","$ph","f","g","pos","ch","UriIteratorState","$qh","TernarySearchTreeNode","tmp","Dir","$rh","ignorePathCasing","ignoreQueryAndFragment","segments","values","keys","arr","arrays_1","k","entry","element","iter","node","stack","val","oldElement","bf","d1","d2","superStr","min","value","segment","newChild","dir","parent","candidate","allowValue","callback","bucket","nodeIsBalanced","_util","getServiceDependencies","ctor","$lh","storeServiceDependency","id","target","index","serviceId","$mh","serviceIdentifier","instantiation_1","Utils","isValidProfile","profile","rewriteAbsolutePaths","replace","path_1","computeAggregateTime","nodes","row","total","child","ensureSourceLocations","locationIdCounter","locationsByRef","getLocationIdFor","callFrame","ref","existing","tick","b","l","$v8b","samples","timeDeltas","locations","src","idMap","mapId","nodeId","duration","lastNodeTime","d","location","$w8b","$x8b","aggregate","model","initialNode","create","ProfileAnalysisWorker","profiling_1","profilingModel_1","bottomUp","s","categories","searchTree","ternarySearchTree_1","aggegrateByCategory","loc","category","uri_1","printCallFrameShort","newValue","isSpecial","call","frame","printCallFrameStackLike","getHeaviestLocationIds","topN","stackSelfTime","locationIds","locationId","root","sample","top","percentage"],"file":"profileAnalysisWorker.js"}
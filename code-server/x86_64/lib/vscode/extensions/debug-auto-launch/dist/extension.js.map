{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://debug-auto-launch/external commonjs \"vscode\"","webpack://debug-auto-launch/external node-commonjs \"fs\"","webpack://debug-auto-launch/external node-commonjs \"net\"","webpack://debug-auto-launch/external node-commonjs \"path\"","webpack://debug-auto-launch/webpack/bootstrap","webpack://debug-auto-launch/./src/extension.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promises as fs } from 'fs';\nimport { createServer, Server } from 'net';\nimport { dirname } from 'path';\nimport * as vscode from 'vscode';\n\nconst enum State {\n\tDisabled = 'disabled',\n\tOnlyWithFlag = 'onlyWithFlag',\n\tSmart = 'smart',\n\tAlways = 'always',\n}\nconst TEXT_STATUSBAR_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Auto Attach: Disabled'),\n\t[State.Always]: vscode.l10n.t('Auto Attach: Always'),\n\t[State.Smart]: vscode.l10n.t('Auto Attach: Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Auto Attach: With Flag'),\n};\n\nconst TEXT_STATE_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Disabled'),\n\t[State.Always]: vscode.l10n.t('Always'),\n\t[State.Smart]: vscode.l10n.t('Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only With Flag'),\n};\nconst TEXT_STATE_DESCRIPTION = {\n\t[State.Disabled]: vscode.l10n.t('Auto attach is disabled and not shown in status bar'),\n\t[State.Always]: vscode.l10n.t('Auto attach to every Node.js process launched in the terminal'),\n\t[State.Smart]: vscode.l10n.t(\"Auto attach when running scripts that aren't in a node_modules folder\"),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only auto attach when the `--inspect` flag is given')\n};\nconst TEXT_TOGGLE_WORKSPACE = vscode.l10n.t('Toggle auto attach in this workspace');\nconst TEXT_TOGGLE_GLOBAL = vscode.l10n.t('Toggle auto attach on this machine');\nconst TEXT_TEMP_DISABLE = vscode.l10n.t('Temporarily disable auto attach in this session');\nconst TEXT_TEMP_ENABLE = vscode.l10n.t('Re-enable auto attach');\nconst TEXT_TEMP_DISABLE_LABEL = vscode.l10n.t('Auto Attach: Disabled');\n\nconst TOGGLE_COMMAND = 'extension.node-debug.toggleAutoAttach';\nconst STORAGE_IPC = 'jsDebugIpcState';\n\nconst SETTING_SECTION = 'debug.javascript';\nconst SETTING_STATE = 'autoAttachFilter';\n\n/**\n * settings that, when changed, should cause us to refresh the state vars\n */\nconst SETTINGS_CAUSE_REFRESH = new Set(\n\t['autoAttachSmartPattern', SETTING_STATE].map(s => `${SETTING_SECTION}.${s}`),\n);\n\n\nlet currentState: Promise<{ context: vscode.ExtensionContext; state: State | null }>;\nlet statusItem: vscode.StatusBarItem | undefined; // and there is no status bar item\nlet server: Promise<Server | undefined> | undefined; // auto attach server\nlet isTemporarilyDisabled = false; // whether the auto attach server is disabled temporarily, reset whenever the state changes\n\nexport function activate(context: vscode.ExtensionContext): void {\n\tcurrentState = Promise.resolve({ context, state: null });\n\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand(TOGGLE_COMMAND, toggleAutoAttachSetting.bind(null, context)),\n\t);\n\n\tcontext.subscriptions.push(\n\t\tvscode.workspace.onDidChangeConfiguration(e => {\n\t\t\t// Whenever a setting is changed, disable auto attach, and re-enable\n\t\t\t// it (if necessary) to refresh variables.\n\t\t\tif (\n\t\t\t\te.affectsConfiguration(`${SETTING_SECTION}.${SETTING_STATE}`) ||\n\t\t\t\t[...SETTINGS_CAUSE_REFRESH].some(setting => e.affectsConfiguration(setting))\n\t\t\t) {\n\t\t\t\trefreshAutoAttachVars();\n\t\t\t}\n\t\t}),\n\t);\n\n\tupdateAutoAttach(readCurrentState());\n}\n\nexport async function deactivate(): Promise<void> {\n\tawait destroyAttachServer();\n}\n\nfunction refreshAutoAttachVars() {\n\tupdateAutoAttach(State.Disabled);\n\tupdateAutoAttach(readCurrentState());\n}\n\nfunction getDefaultScope(info: ReturnType<vscode.WorkspaceConfiguration['inspect']>) {\n\tif (!info) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t} else if (info.workspaceFolderValue) {\n\t\treturn vscode.ConfigurationTarget.WorkspaceFolder;\n\t} else if (info.workspaceValue) {\n\t\treturn vscode.ConfigurationTarget.Workspace;\n\t} else if (info.globalValue) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t}\n\n\treturn vscode.ConfigurationTarget.Global;\n}\n\ntype PickResult = { state: State } | { setTempDisabled: boolean } | { scope: vscode.ConfigurationTarget } | undefined;\ntype PickItem = vscode.QuickPickItem & ({ state: State } | { setTempDisabled: boolean });\n\nasync function toggleAutoAttachSetting(context: vscode.ExtensionContext, scope?: vscode.ConfigurationTarget): Promise<void> {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tscope = scope || getDefaultScope(section.inspect(SETTING_STATE));\n\n\tconst isGlobalScope = scope === vscode.ConfigurationTarget.Global;\n\tconst quickPick = vscode.window.createQuickPick<PickItem>();\n\tconst current = readCurrentState();\n\n\tconst items: PickItem[] = [State.Always, State.Smart, State.OnlyWithFlag, State.Disabled].map(state => ({\n\t\tstate,\n\t\tlabel: TEXT_STATE_LABEL[state],\n\t\tdescription: TEXT_STATE_DESCRIPTION[state],\n\t\talwaysShow: true,\n\t}));\n\n\tif (current !== State.Disabled) {\n\t\titems.unshift({\n\t\t\tsetTempDisabled: !isTemporarilyDisabled,\n\t\t\tlabel: isTemporarilyDisabled ? TEXT_TEMP_ENABLE : TEXT_TEMP_DISABLE,\n\t\t\talwaysShow: true,\n\t\t});\n\t}\n\n\tquickPick.items = items;\n\tquickPick.activeItems = isTemporarilyDisabled\n\t\t? [items[0]]\n\t\t: quickPick.items.filter(i => 'state' in i && i.state === current);\n\tquickPick.title = isGlobalScope ? TEXT_TOGGLE_GLOBAL : TEXT_TOGGLE_WORKSPACE;\n\tquickPick.buttons = [\n\t\t{\n\t\t\ticonPath: new vscode.ThemeIcon(isGlobalScope ? 'folder' : 'globe'),\n\t\t\ttooltip: isGlobalScope ? TEXT_TOGGLE_WORKSPACE : TEXT_TOGGLE_GLOBAL,\n\t\t},\n\t];\n\n\tquickPick.show();\n\n\tlet result = await new Promise<PickResult>(resolve => {\n\t\tquickPick.onDidAccept(() => resolve(quickPick.selectedItems[0]));\n\t\tquickPick.onDidHide(() => resolve(undefined));\n\t\tquickPick.onDidTriggerButton(() => {\n\t\t\tresolve({\n\t\t\t\tscope: isGlobalScope\n\t\t\t\t\t? vscode.ConfigurationTarget.Workspace\n\t\t\t\t\t: vscode.ConfigurationTarget.Global,\n\t\t\t});\n\t\t});\n\t});\n\n\tquickPick.dispose();\n\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tif ('scope' in result) {\n\t\treturn await toggleAutoAttachSetting(context, result.scope);\n\t}\n\n\tif ('state' in result) {\n\t\tif (result.state !== current) {\n\t\t\tsection.update(SETTING_STATE, result.state, scope);\n\t\t} else if (isTemporarilyDisabled) {\n\t\t\tresult = { setTempDisabled: false };\n\t\t}\n\t}\n\n\tif ('setTempDisabled' in result) {\n\t\tupdateStatusBar(context, current, true);\n\t\tisTemporarilyDisabled = result.setTempDisabled;\n\t\tif (result.setTempDisabled) {\n\t\t\tawait destroyAttachServer();\n\t\t} else {\n\t\t\tawait createAttachServer(context); // unsets temp disabled var internally\n\t\t}\n\t\tupdateStatusBar(context, current, false);\n\t}\n}\n\nfunction readCurrentState(): State {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\treturn section.get<State>(SETTING_STATE) ?? State.Disabled;\n}\n\nasync function clearJsDebugAttachState(context: vscode.ExtensionContext) {\n\tif (server || await context.workspaceState.get(STORAGE_IPC)) {\n\t\tawait context.workspaceState.update(STORAGE_IPC, undefined);\n\t\tawait vscode.commands.executeCommand('extension.js-debug.clearAutoAttachVariables');\n\t\tawait destroyAttachServer();\n\t}\n}\n\n/**\n * Turns auto attach on, and returns the server auto attach is listening on\n * if it's successful.\n */\nasync function createAttachServer(context: vscode.ExtensionContext) {\n\tconst ipcAddress = await getIpcAddress(context);\n\tif (!ipcAddress) {\n\t\treturn undefined;\n\t}\n\n\tserver = createServerInner(ipcAddress).catch(async err => {\n\t\tconsole.error('[debug-auto-launch] Error creating auto attach server: ', err);\n\n\t\tif (process.platform !== 'win32') {\n\t\t\t// On macOS, and perhaps some Linux distros, the temporary directory can\n\t\t\t// sometimes change. If it looks like that's the cause of a listener\n\t\t\t// error, automatically refresh the auto attach vars.\n\t\t\ttry {\n\t\t\t\tawait fs.access(dirname(ipcAddress));\n\t\t\t} catch {\n\t\t\t\tconsole.error('[debug-auto-launch] Refreshing variables from error');\n\t\t\t\trefreshAutoAttachVars();\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t});\n\n\treturn await server;\n}\n\nconst createServerInner = async (ipcAddress: string) => {\n\ttry {\n\t\treturn await createServerInstance(ipcAddress);\n\t} catch (e) {\n\t\t// On unix/linux, the file can 'leak' if the process exits unexpectedly.\n\t\t// If we see this, try to delete the file and then listen again.\n\t\tawait fs.unlink(ipcAddress).catch(() => undefined);\n\t\treturn await createServerInstance(ipcAddress);\n\t}\n};\n\nconst createServerInstance = (ipcAddress: string) =>\n\tnew Promise<Server>((resolve, reject) => {\n\t\tconst s = createServer(socket => {\n\t\t\tconst data: Buffer[] = [];\n\t\t\tsocket.on('data', async chunk => {\n\t\t\t\tif (chunk[chunk.length - 1] !== 0) {\n\t\t\t\t\t// terminated with NUL byte\n\t\t\t\t\tdata.push(chunk);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata.push(chunk.slice(0, -1));\n\n\t\t\t\ttry {\n\t\t\t\t\tawait vscode.commands.executeCommand(\n\t\t\t\t\t\t'extension.js-debug.autoAttachToProcess',\n\t\t\t\t\t\tJSON.parse(Buffer.concat(data).toString()),\n\t\t\t\t\t);\n\t\t\t\t\tsocket.write(Buffer.from([0]));\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsocket.write(Buffer.from([1]));\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t})\n\t\t\t.on('error', reject)\n\t\t\t.listen(ipcAddress, () => resolve(s));\n\t});\n\n/**\n * Destroys the auto-attach server, if it's running.\n */\nasync function destroyAttachServer() {\n\tconst instance = await server;\n\tif (instance) {\n\t\tawait new Promise(r => instance.close(r));\n\t}\n}\n\ninterface CachedIpcState {\n\tipcAddress: string;\n\tjsDebugPath: string;\n\tsettingsValue: string;\n}\n\n/**\n * Map of logic that happens when auto attach states are entered and exited.\n * All state transitions are queued and run in order; promises are awaited.\n */\nconst transitions: { [S in State]: (context: vscode.ExtensionContext) => Promise<void> } = {\n\tasync [State.Disabled](context) {\n\t\tawait clearJsDebugAttachState(context);\n\t},\n\n\tasync [State.OnlyWithFlag](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Smart](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Always](context) {\n\t\tawait createAttachServer(context);\n\t},\n};\n\n/**\n * Ensures the status bar text reflects the current state.\n */\nfunction updateStatusBar(context: vscode.ExtensionContext, state: State, busy = false) {\n\tif (state === State.Disabled && !busy) {\n\t\tstatusItem?.hide();\n\t\treturn;\n\t}\n\n\tif (!statusItem) {\n\t\tstatusItem = vscode.window.createStatusBarItem('status.debug.autoAttach', vscode.StatusBarAlignment.Left);\n\t\tstatusItem.name = vscode.l10n.t(\"Debug Auto Attach\");\n\t\tstatusItem.command = TOGGLE_COMMAND;\n\t\tstatusItem.tooltip = vscode.l10n.t(\"Automatically attach to node.js processes in debug mode\");\n\t\tcontext.subscriptions.push(statusItem);\n\t}\n\n\tlet text = busy ? '$(loading) ' : '';\n\ttext += isTemporarilyDisabled ? TEXT_TEMP_DISABLE_LABEL : TEXT_STATUSBAR_LABEL[state];\n\tstatusItem.text = text;\n\tstatusItem.show();\n}\n\n/**\n * Updates the auto attach feature based on the user or workspace setting\n */\nfunction updateAutoAttach(newState: State) {\n\tcurrentState = currentState.then(async ({ context, state: oldState }) => {\n\t\tif (newState === oldState) {\n\t\t\treturn { context, state: oldState };\n\t\t}\n\n\t\tif (oldState !== null) {\n\t\t\tupdateStatusBar(context, oldState, true);\n\t\t}\n\n\t\tawait transitions[newState](context);\n\t\tisTemporarilyDisabled = false;\n\t\tupdateStatusBar(context, newState, false);\n\t\treturn { context, state: newState };\n\t});\n}\n\n/**\n * Gets the IPC address for the server to listen on for js-debug sessions. This\n * is cached such that we can reuse the address of previous activations.\n */\nasync function getIpcAddress(context: vscode.ExtensionContext) {\n\t// Iff the `cachedData` is present, the js-debug registered environment\n\t// variables for this workspace--cachedData is set after successfully\n\t// invoking the attachment command.\n\tconst cachedIpc = context.workspaceState.get<CachedIpcState>(STORAGE_IPC);\n\n\t// We invalidate the IPC data if the js-debug path changes, since that\n\t// indicates the extension was updated or reinstalled and the\n\t// environment variables will have been lost.\n\t// todo: make a way in the API to read environment data directly without activating js-debug?\n\tconst jsDebugPath =\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug-nightly')?.extensionPath ||\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug')?.extensionPath;\n\n\tconst settingsValue = getJsDebugSettingKey();\n\tif (cachedIpc?.jsDebugPath === jsDebugPath && cachedIpc?.settingsValue === settingsValue) {\n\t\treturn cachedIpc.ipcAddress;\n\t}\n\n\tconst result = await vscode.commands.executeCommand<{ ipcAddress: string }>(\n\t\t'extension.js-debug.setAutoAttachVariables',\n\t\tcachedIpc?.ipcAddress,\n\t);\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tconst ipcAddress = result.ipcAddress;\n\tawait context.workspaceState.update(STORAGE_IPC, {\n\t\tipcAddress,\n\t\tjsDebugPath,\n\t\tsettingsValue,\n\t} as CachedIpcState);\n\n\treturn ipcAddress;\n}\n\nfunction getJsDebugSettingKey() {\n\tconst o: { [key: string]: unknown } = {};\n\tconst config = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tfor (const setting of SETTINGS_CAUSE_REFRESH) {\n\t\to[setting] = config.get(setting);\n\t}\n\n\treturn JSON.stringify(o);\n}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","TEXT_STATUSBAR_LABEL","vscode","l10n","t","TEXT_STATE_LABEL","TEXT_STATE_DESCRIPTION","TEXT_TOGGLE_WORKSPACE","TEXT_TOGGLE_GLOBAL","TEXT_TEMP_DISABLE","TEXT_TEMP_ENABLE","TEXT_TEMP_DISABLE_LABEL","TOGGLE_COMMAND","STORAGE_IPC","SETTING_SECTION","SETTING_STATE","SETTINGS_CAUSE_REFRESH","Set","map","s","currentState","statusItem","server","isTemporarilyDisabled","refreshAutoAttachVars","updateAutoAttach","readCurrentState","async","toggleAutoAttachSetting","context","scope","section","workspace","getConfiguration","info","isGlobalScope","inspect","workspaceFolderValue","ConfigurationTarget","WorkspaceFolder","workspaceValue","Workspace","globalValue","Global","quickPick","window","createQuickPick","current","items","state","label","description","alwaysShow","unshift","setTempDisabled","activeItems","filter","i","title","buttons","iconPath","ThemeIcon","tooltip","show","result","Promise","resolve","onDidAccept","selectedItems","onDidHide","onDidTriggerButton","dispose","update","updateStatusBar","destroyAttachServer","createAttachServer","get","ipcAddress","cachedIpc","workspaceState","jsDebugPath","extensions","getExtension","extensionPath","settingsValue","o","config","setting","JSON","stringify","getJsDebugSettingKey","commands","executeCommand","getIpcAddress","createServerInner","catch","err","console","error","process","platform","access","dirname","subscriptions","push","registerCommand","bind","onDidChangeConfiguration","e","affectsConfiguration","some","createServerInstance","unlink","reject","createServer","socket","data","on","chunk","length","slice","parse","Buffer","concat","toString","write","from","listen","instance","r","close","transitions","clearJsDebugAttachState","busy","hide","createStatusBarItem","StatusBarAlignment","Left","name","command","text","newState","then","oldState"],"sourceRoot":""}
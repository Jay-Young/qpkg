{"version":3,"sources":["webpack://debug-auto-launch/external \"fs\"","webpack://debug-auto-launch/external \"net\"","webpack://debug-auto-launch/external \"vscode\"","webpack://debug-auto-launch/webpack/bootstrap","webpack://debug-auto-launch/./src/extension.ts"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","TEXT_STATUSBAR_LABEL","vscode","l10n","t","TEXT_STATE_LABEL","TEXT_STATE_DESCRIPTION","TEXT_TOGGLE_WORKSPACE","TEXT_TOGGLE_GLOBAL","TEXT_TEMP_DISABLE","TEXT_TEMP_ENABLE","TEXT_TEMP_DISABLE_LABEL","TOGGLE_COMMAND","STORAGE_IPC","SETTING_SECTION","SETTING_STATE","SETTINGS_CAUSE_REFRESH","Set","map","s","currentState","statusItem","server","isTemporarilyDisabled","async","toggleAutoAttachSetting","context","scope","section","workspace","getConfiguration","info","isGlobalScope","inspect","workspaceFolderValue","ConfigurationTarget","WorkspaceFolder","workspaceValue","Workspace","globalValue","Global","quickPick","window","createQuickPick","current","readCurrentState","items","state","label","description","alwaysShow","unshift","setTempDisabled","activeItems","filter","i","title","buttons","iconPath","ThemeIcon","tooltip","show","result","Promise","resolve","onDidAccept","selectedItems","onDidHide","onDidTriggerButton","dispose","update","updateStatusBar","destroyAttachServer","createAttachServer","get","ipcAddress","cachedIpc","workspaceState","jsDebugPath","extensions","getExtension","extensionPath","settingsValue","o","config","setting","JSON","stringify","getJsDebugSettingKey","commands","executeCommand","getIpcAddress","createServerInner","catch","err","console","error","subscriptions","push","registerCommand","bind","onDidChangeConfiguration","e","affectsConfiguration","some","updateAutoAttach","createServerInstance","unlink","reject","createServer","socket","data","on","chunk","length","slice","parse","Buffer","concat","toString","write","from","listen","instance","r","close","transitions","clearJsDebugAttachState","busy","hide","createStatusBarItem","StatusBarAlignment","Left","name","command","text","newState","then","oldState"],"mappings":"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","file":"extension.js","sourcesContent":["module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promises as fs } from 'fs';\nimport { createServer, Server } from 'net';\nimport * as vscode from 'vscode';\n\nconst enum State {\n\tDisabled = 'disabled',\n\tOnlyWithFlag = 'onlyWithFlag',\n\tSmart = 'smart',\n\tAlways = 'always',\n}\nconst TEXT_STATUSBAR_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Auto Attach: Disabled'),\n\t[State.Always]: vscode.l10n.t('Auto Attach: Always'),\n\t[State.Smart]: vscode.l10n.t('Auto Attach: Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Auto Attach: With Flag'),\n};\n\nconst TEXT_STATE_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Disabled'),\n\t[State.Always]: vscode.l10n.t('Always'),\n\t[State.Smart]: vscode.l10n.t('Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only With Flag'),\n};\nconst TEXT_STATE_DESCRIPTION = {\n\t[State.Disabled]: vscode.l10n.t('Auto attach is disabled and not shown in status bar'),\n\t[State.Always]: vscode.l10n.t('Auto attach to every Node.js process launched in the terminal'),\n\t[State.Smart]: vscode.l10n.t(\"Auto attach when running scripts that aren't in a node_modules folder\"),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only auto attach when the `--inspect` flag is given')\n};\nconst TEXT_TOGGLE_WORKSPACE = vscode.l10n.t('Toggle auto attach in this workspace');\nconst TEXT_TOGGLE_GLOBAL = vscode.l10n.t('Toggle auto attach on this machine');\nconst TEXT_TEMP_DISABLE = vscode.l10n.t('Temporarily disable auto attach in this session');\nconst TEXT_TEMP_ENABLE = vscode.l10n.t('Re-enable auto attach');\nconst TEXT_TEMP_DISABLE_LABEL = vscode.l10n.t('Auto Attach: Disabled');\n\nconst TOGGLE_COMMAND = 'extension.node-debug.toggleAutoAttach';\nconst STORAGE_IPC = 'jsDebugIpcState';\n\nconst SETTING_SECTION = 'debug.javascript';\nconst SETTING_STATE = 'autoAttachFilter';\n\n/**\n * settings that, when changed, should cause us to refresh the state vars\n */\nconst SETTINGS_CAUSE_REFRESH = new Set(\n\t['autoAttachSmartPattern', SETTING_STATE].map(s => `${SETTING_SECTION}.${s}`),\n);\n\n\nlet currentState: Promise<{ context: vscode.ExtensionContext; state: State | null }>;\nlet statusItem: vscode.StatusBarItem | undefined; // and there is no status bar item\nlet server: Promise<Server | undefined> | undefined; // auto attach server\nlet isTemporarilyDisabled = false; // whether the auto attach server is disabled temporarily, reset whenever the state changes\n\nexport function activate(context: vscode.ExtensionContext): void {\n\tcurrentState = Promise.resolve({ context, state: null });\n\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand(TOGGLE_COMMAND, toggleAutoAttachSetting.bind(null, context)),\n\t);\n\n\tcontext.subscriptions.push(\n\t\tvscode.workspace.onDidChangeConfiguration(e => {\n\t\t\t// Whenever a setting is changed, disable auto attach, and re-enable\n\t\t\t// it (if necessary) to refresh variables.\n\t\t\tif (\n\t\t\t\te.affectsConfiguration(`${SETTING_SECTION}.${SETTING_STATE}`) ||\n\t\t\t\t[...SETTINGS_CAUSE_REFRESH].some(setting => e.affectsConfiguration(setting))\n\t\t\t) {\n\t\t\t\tupdateAutoAttach(State.Disabled);\n\t\t\t\tupdateAutoAttach(readCurrentState());\n\t\t\t}\n\t\t}),\n\t);\n\n\tupdateAutoAttach(readCurrentState());\n}\n\nexport async function deactivate(): Promise<void> {\n\tawait destroyAttachServer();\n}\n\nfunction getDefaultScope(info: ReturnType<vscode.WorkspaceConfiguration['inspect']>) {\n\tif (!info) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t} else if (info.workspaceFolderValue) {\n\t\treturn vscode.ConfigurationTarget.WorkspaceFolder;\n\t} else if (info.workspaceValue) {\n\t\treturn vscode.ConfigurationTarget.Workspace;\n\t} else if (info.globalValue) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t}\n\n\treturn vscode.ConfigurationTarget.Global;\n}\n\ntype PickResult = { state: State } | { setTempDisabled: boolean } | { scope: vscode.ConfigurationTarget } | undefined;\ntype PickItem = vscode.QuickPickItem & ({ state: State } | { setTempDisabled: boolean });\n\nasync function toggleAutoAttachSetting(context: vscode.ExtensionContext, scope?: vscode.ConfigurationTarget): Promise<void> {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tscope = scope || getDefaultScope(section.inspect(SETTING_STATE));\n\n\tconst isGlobalScope = scope === vscode.ConfigurationTarget.Global;\n\tconst quickPick = vscode.window.createQuickPick<PickItem>();\n\tconst current = readCurrentState();\n\n\tconst items: PickItem[] = [State.Always, State.Smart, State.OnlyWithFlag, State.Disabled].map(state => ({\n\t\tstate,\n\t\tlabel: TEXT_STATE_LABEL[state],\n\t\tdescription: TEXT_STATE_DESCRIPTION[state],\n\t\talwaysShow: true,\n\t}));\n\n\tif (current !== State.Disabled) {\n\t\titems.unshift({\n\t\t\tsetTempDisabled: !isTemporarilyDisabled,\n\t\t\tlabel: isTemporarilyDisabled ? TEXT_TEMP_ENABLE : TEXT_TEMP_DISABLE,\n\t\t\talwaysShow: true,\n\t\t});\n\t}\n\n\tquickPick.items = items;\n\tquickPick.activeItems = isTemporarilyDisabled\n\t\t? [items[0]]\n\t\t: quickPick.items.filter(i => 'state' in i && i.state === current);\n\tquickPick.title = isGlobalScope ? TEXT_TOGGLE_GLOBAL : TEXT_TOGGLE_WORKSPACE;\n\tquickPick.buttons = [\n\t\t{\n\t\t\ticonPath: new vscode.ThemeIcon(isGlobalScope ? 'folder' : 'globe'),\n\t\t\ttooltip: isGlobalScope ? TEXT_TOGGLE_WORKSPACE : TEXT_TOGGLE_GLOBAL,\n\t\t},\n\t];\n\n\tquickPick.show();\n\n\tlet result = await new Promise<PickResult>(resolve => {\n\t\tquickPick.onDidAccept(() => resolve(quickPick.selectedItems[0]));\n\t\tquickPick.onDidHide(() => resolve(undefined));\n\t\tquickPick.onDidTriggerButton(() => {\n\t\t\tresolve({\n\t\t\t\tscope: isGlobalScope\n\t\t\t\t\t? vscode.ConfigurationTarget.Workspace\n\t\t\t\t\t: vscode.ConfigurationTarget.Global,\n\t\t\t});\n\t\t});\n\t});\n\n\tquickPick.dispose();\n\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tif ('scope' in result) {\n\t\treturn await toggleAutoAttachSetting(context, result.scope);\n\t}\n\n\tif ('state' in result) {\n\t\tif (result.state !== current) {\n\t\t\tsection.update(SETTING_STATE, result.state, scope);\n\t\t} else if (isTemporarilyDisabled) {\n\t\t\tresult = { setTempDisabled: false };\n\t\t}\n\t}\n\n\tif ('setTempDisabled' in result) {\n\t\tupdateStatusBar(context, current, true);\n\t\tisTemporarilyDisabled = result.setTempDisabled;\n\t\tif (result.setTempDisabled) {\n\t\t\tawait destroyAttachServer();\n\t\t} else {\n\t\t\tawait createAttachServer(context); // unsets temp disabled var internally\n\t\t}\n\t\tupdateStatusBar(context, current, false);\n\t}\n}\n\nfunction readCurrentState(): State {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\treturn section.get<State>(SETTING_STATE) ?? State.Disabled;\n}\n\nasync function clearJsDebugAttachState(context: vscode.ExtensionContext) {\n\tif (server || await context.workspaceState.get(STORAGE_IPC)) {\n\t\tawait context.workspaceState.update(STORAGE_IPC, undefined);\n\t\tawait vscode.commands.executeCommand('extension.js-debug.clearAutoAttachVariables');\n\t\tawait destroyAttachServer();\n\t}\n}\n\n/**\n * Turns auto attach on, and returns the server auto attach is listening on\n * if it's successful.\n */\nasync function createAttachServer(context: vscode.ExtensionContext) {\n\tconst ipcAddress = await getIpcAddress(context);\n\tif (!ipcAddress) {\n\t\treturn undefined;\n\t}\n\n\tserver = createServerInner(ipcAddress).catch(err => {\n\t\tconsole.error(err);\n\t\treturn undefined;\n\t});\n\n\treturn await server;\n}\n\nconst createServerInner = async (ipcAddress: string) => {\n\ttry {\n\t\treturn await createServerInstance(ipcAddress);\n\t} catch (e) {\n\t\t// On unix/linux, the file can 'leak' if the process exits unexpectedly.\n\t\t// If we see this, try to delete the file and then listen again.\n\t\tawait fs.unlink(ipcAddress).catch(() => undefined);\n\t\treturn await createServerInstance(ipcAddress);\n\t}\n};\n\nconst createServerInstance = (ipcAddress: string) =>\n\tnew Promise<Server>((resolve, reject) => {\n\t\tconst s = createServer(socket => {\n\t\t\tconst data: Buffer[] = [];\n\t\t\tsocket.on('data', async chunk => {\n\t\t\t\tif (chunk[chunk.length - 1] !== 0) {\n\t\t\t\t\t// terminated with NUL byte\n\t\t\t\t\tdata.push(chunk);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata.push(chunk.slice(0, -1));\n\n\t\t\t\ttry {\n\t\t\t\t\tawait vscode.commands.executeCommand(\n\t\t\t\t\t\t'extension.js-debug.autoAttachToProcess',\n\t\t\t\t\t\tJSON.parse(Buffer.concat(data).toString()),\n\t\t\t\t\t);\n\t\t\t\t\tsocket.write(Buffer.from([0]));\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsocket.write(Buffer.from([1]));\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t})\n\t\t\t.on('error', reject)\n\t\t\t.listen(ipcAddress, () => resolve(s));\n\t});\n\n/**\n * Destroys the auto-attach server, if it's running.\n */\nasync function destroyAttachServer() {\n\tconst instance = await server;\n\tif (instance) {\n\t\tawait new Promise(r => instance.close(r));\n\t}\n}\n\ninterface CachedIpcState {\n\tipcAddress: string;\n\tjsDebugPath: string;\n\tsettingsValue: string;\n}\n\n/**\n * Map of logic that happens when auto attach states are entered and exited.\n * All state transitions are queued and run in order; promises are awaited.\n */\nconst transitions: { [S in State]: (context: vscode.ExtensionContext) => Promise<void> } = {\n\tasync [State.Disabled](context) {\n\t\tawait clearJsDebugAttachState(context);\n\t},\n\n\tasync [State.OnlyWithFlag](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Smart](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Always](context) {\n\t\tawait createAttachServer(context);\n\t},\n};\n\n/**\n * Ensures the status bar text reflects the current state.\n */\nfunction updateStatusBar(context: vscode.ExtensionContext, state: State, busy = false) {\n\tif (state === State.Disabled && !busy) {\n\t\tstatusItem?.hide();\n\t\treturn;\n\t}\n\n\tif (!statusItem) {\n\t\tstatusItem = vscode.window.createStatusBarItem('status.debug.autoAttach', vscode.StatusBarAlignment.Left);\n\t\tstatusItem.name = vscode.l10n.t(\"Debug Auto Attach\");\n\t\tstatusItem.command = TOGGLE_COMMAND;\n\t\tstatusItem.tooltip = vscode.l10n.t(\"Automatically attach to node.js processes in debug mode\");\n\t\tcontext.subscriptions.push(statusItem);\n\t}\n\n\tlet text = busy ? '$(loading) ' : '';\n\ttext += isTemporarilyDisabled ? TEXT_TEMP_DISABLE_LABEL : TEXT_STATUSBAR_LABEL[state];\n\tstatusItem.text = text;\n\tstatusItem.show();\n}\n\n/**\n * Updates the auto attach feature based on the user or workspace setting\n */\nfunction updateAutoAttach(newState: State) {\n\tcurrentState = currentState.then(async ({ context, state: oldState }) => {\n\t\tif (newState === oldState) {\n\t\t\treturn { context, state: oldState };\n\t\t}\n\n\t\tif (oldState !== null) {\n\t\t\tupdateStatusBar(context, oldState, true);\n\t\t}\n\n\t\tawait transitions[newState](context);\n\t\tisTemporarilyDisabled = false;\n\t\tupdateStatusBar(context, newState, false);\n\t\treturn { context, state: newState };\n\t});\n}\n\n/**\n * Gets the IPC address for the server to listen on for js-debug sessions. This\n * is cached such that we can reuse the address of previous activations.\n */\nasync function getIpcAddress(context: vscode.ExtensionContext) {\n\t// Iff the `cachedData` is present, the js-debug registered environment\n\t// variables for this workspace--cachedData is set after successfully\n\t// invoking the attachment command.\n\tconst cachedIpc = context.workspaceState.get<CachedIpcState>(STORAGE_IPC);\n\n\t// We invalidate the IPC data if the js-debug path changes, since that\n\t// indicates the extension was updated or reinstalled and the\n\t// environment variables will have been lost.\n\t// todo: make a way in the API to read environment data directly without activating js-debug?\n\tconst jsDebugPath =\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug-nightly')?.extensionPath ||\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug')?.extensionPath;\n\n\tconst settingsValue = getJsDebugSettingKey();\n\tif (cachedIpc?.jsDebugPath === jsDebugPath && cachedIpc?.settingsValue === settingsValue) {\n\t\treturn cachedIpc.ipcAddress;\n\t}\n\n\tconst result = await vscode.commands.executeCommand<{ ipcAddress: string }>(\n\t\t'extension.js-debug.setAutoAttachVariables',\n\t\tcachedIpc?.ipcAddress,\n\t);\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tconst ipcAddress = result.ipcAddress;\n\tawait context.workspaceState.update(STORAGE_IPC, {\n\t\tipcAddress,\n\t\tjsDebugPath,\n\t\tsettingsValue,\n\t} as CachedIpcState);\n\n\treturn ipcAddress;\n}\n\nfunction getJsDebugSettingKey() {\n\tconst o: { [key: string]: unknown } = {};\n\tconst config = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tfor (const setting of SETTINGS_CAUSE_REFRESH) {\n\t\to[setting] = config.get(setting);\n\t}\n\n\treturn JSON.stringify(o);\n}\n"],"sourceRoot":""}
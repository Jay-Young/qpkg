{"version":3,"sources":["webpack://grunt/external \"child_process\"","webpack://grunt/external \"fs\"","webpack://grunt/external \"path\"","webpack://grunt/external \"vscode\"","webpack://grunt/webpack/bootstrap","webpack://grunt/./src/main.ts"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","exists","file","Promise","resolve","_reject","fs","value","buildNames","isBuildTask","name","buildName","indexOf","testNames","isTestTask","testName","_channel","detector","getOutputChannel","vscode","window","createOutputChannel","showError","showWarningMessage","l10n","t","then","show","async","findGruntCommand","rootPath","command","platform","process","path","join","FolderDetector","constructor","c","d","this","isEnabled","workspace","getConfiguration","uri","get","start","pattern","fsPath","a","createFileSystemWatcher","onDidChange","b","onDidCreate","onDidDelete","e","_task","taskDefinition","definition","gruntTask","task","options","cwd","workspaceFolder","source","Task","ShellExecution","args","scheme","emptyTasks","commandLine","stdout","stderr","reject","cp","exec","error","appendLine","result","lines","split","tasksStart","tasksEnd","line","length","matches","kind","type","push","lowerCaseTaskName","toLowerCase","group","TaskGroup","Build","Test","err","channel","dispose","TaskDetector","Map","folders","workspaceFolders","onDidChangeWorkspaceFolders","event","added","removed","onDidChangeConfiguration","clear","remove","toString","delete","add","set","values","folder","has","size","thisCapture","tasks","registerTaskProvider","provideTasks","getTasks","resolveTask","getTask","f","next","promises","all","scope","TaskScope","Workspace","Global","_context"],"mappings":"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","file":"main.js","sourcesContent":["module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as vscode from 'vscode';\n\ntype AutoDetect = 'on' | 'off';\n\nfunction exists(file: string): Promise<boolean> {\n\treturn new Promise<boolean>((resolve, _reject) => {\n\t\tfs.exists(file, (value) => {\n\t\t\tresolve(value);\n\t\t});\n\t});\n}\n\nfunction exec(command: string, options: cp.ExecOptions): Promise<{ stdout: string; stderr: string }> {\n\treturn new Promise<{ stdout: string; stderr: string }>((resolve, reject) => {\n\t\tcp.exec(command, options, (error, stdout, stderr) => {\n\t\t\tif (error) {\n\t\t\t\treject({ error, stdout, stderr });\n\t\t\t}\n\t\t\tresolve({ stdout, stderr });\n\t\t});\n\t});\n}\n\nconst buildNames: string[] = ['build', 'compile', 'watch'];\nfunction isBuildTask(name: string): boolean {\n\tfor (const buildName of buildNames) {\n\t\tif (name.indexOf(buildName) !== -1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nconst testNames: string[] = ['test'];\nfunction isTestTask(name: string): boolean {\n\tfor (const testName of testNames) {\n\t\tif (name.indexOf(testName) !== -1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nlet _channel: vscode.OutputChannel;\nfunction getOutputChannel(): vscode.OutputChannel {\n\tif (!_channel) {\n\t\t_channel = vscode.window.createOutputChannel('Grunt Auto Detection');\n\t}\n\treturn _channel;\n}\n\nfunction showError() {\n\tvscode.window.showWarningMessage(vscode.l10n.t(\"Problem finding grunt tasks. See the output for more information.\"),\n\t\tvscode.l10n.t(\"Go to output\")).then(() => {\n\t\t\tgetOutputChannel().show(true);\n\t\t});\n}\ninterface GruntTaskDefinition extends vscode.TaskDefinition {\n\ttask: string;\n\targs?: string[];\n\tfile?: string;\n}\n\nasync function findGruntCommand(rootPath: string): Promise<string> {\n\tlet command: string;\n\tconst platform = process.platform;\n\tif (platform === 'win32' && await exists(path.join(rootPath!, 'node_modules', '.bin', 'grunt.cmd'))) {\n\t\tcommand = path.join('.', 'node_modules', '.bin', 'grunt.cmd');\n\t} else if ((platform === 'linux' || platform === 'darwin') && await exists(path.join(rootPath!, 'node_modules', '.bin', 'grunt'))) {\n\t\tcommand = path.join('.', 'node_modules', '.bin', 'grunt');\n\t} else {\n\t\tcommand = 'grunt';\n\t}\n\treturn command;\n}\n\nclass FolderDetector {\n\n\tprivate a: vscode.FileSystemWatcher | undefined;\n\tprivate b: Thenable<vscode.Task[]> | undefined;\n\n\tconstructor(\n\t\tprivate c: vscode.WorkspaceFolder,\n\t\tprivate d: Promise<string>) {\n\t}\n\n\tpublic get workspaceFolder(): vscode.WorkspaceFolder {\n\t\treturn this.c;\n\t}\n\n\tpublic isEnabled(): boolean {\n\t\treturn vscode.workspace.getConfiguration('grunt', this.c.uri).get<AutoDetect>('autoDetect') === 'on';\n\t}\n\n\tpublic start(): void {\n\t\tconst pattern = path.join(this.c.uri.fsPath, '{node_modules,[Gg]runtfile.js}');\n\t\tthis.a = vscode.workspace.createFileSystemWatcher(pattern);\n\t\tthis.a.onDidChange(() => this.b = undefined);\n\t\tthis.a.onDidCreate(() => this.b = undefined);\n\t\tthis.a.onDidDelete(() => this.b = undefined);\n\t}\n\n\tpublic async getTasks(): Promise<vscode.Task[]> {\n\t\tif (this.isEnabled()) {\n\t\t\tif (!this.b) {\n\t\t\t\tthis.b = this.e();\n\t\t\t}\n\t\t\treturn this.b;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tpublic async getTask(_task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\tconst taskDefinition = <any>_task.definition;\n\t\tconst gruntTask = taskDefinition.task;\n\t\tif (gruntTask) {\n\t\t\tconst options: vscode.ShellExecutionOptions = { cwd: this.workspaceFolder.uri.fsPath };\n\t\t\tconst source = 'grunt';\n\t\t\tconst task = gruntTask.indexOf(' ') === -1\n\t\t\t\t? new vscode.Task(taskDefinition, this.workspaceFolder, gruntTask, source, new vscode.ShellExecution(`${await this.d}`, [gruntTask, ...taskDefinition.args], options))\n\t\t\t\t: new vscode.Task(taskDefinition, this.workspaceFolder, gruntTask, source, new vscode.ShellExecution(`${await this.d}`, [`\"${gruntTask}\"`, ...taskDefinition.args], options));\n\t\t\treturn task;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate async e(): Promise<vscode.Task[]> {\n\t\tconst rootPath = this.c.uri.scheme === 'file' ? this.c.uri.fsPath : undefined;\n\t\tconst emptyTasks: vscode.Task[] = [];\n\t\tif (!rootPath) {\n\t\t\treturn emptyTasks;\n\t\t}\n\t\tif (!await exists(path.join(rootPath, 'gruntfile.js')) && !await exists(path.join(rootPath, 'Gruntfile.js'))) {\n\t\t\treturn emptyTasks;\n\t\t}\n\n\t\tconst commandLine = `${await this.d} --help --no-color`;\n\t\ttry {\n\t\t\tconst { stdout, stderr } = await exec(commandLine, { cwd: rootPath });\n\t\t\tif (stderr) {\n\t\t\t\tgetOutputChannel().appendLine(stderr);\n\t\t\t\tshowError();\n\t\t\t}\n\t\t\tconst result: vscode.Task[] = [];\n\t\t\tif (stdout) {\n\t\t\t\t// grunt lists tasks as follows (description is wrapped into a new line if too long):\n\t\t\t\t// ...\n\t\t\t\t// Available tasks\n\t\t\t\t//         uglify  Minify files with UglifyJS. *\n\t\t\t\t//         jshint  Validate files with JSHint. *\n\t\t\t\t//           test  Alias for \"jshint\", \"qunit\" tasks.\n\t\t\t\t//        default  Alias for \"jshint\", \"qunit\", \"concat\", \"uglify\" tasks.\n\t\t\t\t//           long  Alias for \"eslint\", \"qunit\", \"browserify\", \"sass\",\n\t\t\t\t//                 \"autoprefixer\", \"uglify\", tasks.\n\t\t\t\t//\n\t\t\t\t// Tasks run in the order specified\n\n\t\t\t\tconst lines = stdout.split(/\\r{0,1}\\n/);\n\t\t\t\tlet tasksStart = false;\n\t\t\t\tlet tasksEnd = false;\n\t\t\t\tfor (const line of lines) {\n\t\t\t\t\tif (line.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tasksStart && !tasksEnd) {\n\t\t\t\t\t\tif (line.indexOf('Available tasks') === 0) {\n\t\t\t\t\t\t\ttasksStart = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (tasksStart && !tasksEnd) {\n\t\t\t\t\t\tif (line.indexOf('Tasks run in the order specified') === 0) {\n\t\t\t\t\t\t\ttasksEnd = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst regExp = /^\\s*(\\S.*\\S)  \\S/g;\n\t\t\t\t\t\t\tconst matches = regExp.exec(line);\n\t\t\t\t\t\t\tif (matches && matches.length === 2) {\n\t\t\t\t\t\t\t\tconst name = matches[1];\n\t\t\t\t\t\t\t\tconst kind: GruntTaskDefinition = {\n\t\t\t\t\t\t\t\t\ttype: 'grunt',\n\t\t\t\t\t\t\t\t\ttask: name\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tconst source = 'grunt';\n\t\t\t\t\t\t\t\tconst options: vscode.ShellExecutionOptions = { cwd: this.workspaceFolder.uri.fsPath };\n\t\t\t\t\t\t\t\tconst task = name.indexOf(' ') === -1\n\t\t\t\t\t\t\t\t\t? new vscode.Task(kind, this.workspaceFolder, name, source, new vscode.ShellExecution(`${await this.d} ${name}`, options))\n\t\t\t\t\t\t\t\t\t: new vscode.Task(kind, this.workspaceFolder, name, source, new vscode.ShellExecution(`${await this.d} \"${name}\"`, options));\n\t\t\t\t\t\t\t\tresult.push(task);\n\t\t\t\t\t\t\t\tconst lowerCaseTaskName = name.toLowerCase();\n\t\t\t\t\t\t\t\tif (isBuildTask(lowerCaseTaskName)) {\n\t\t\t\t\t\t\t\t\ttask.group = vscode.TaskGroup.Build;\n\t\t\t\t\t\t\t\t} else if (isTestTask(lowerCaseTaskName)) {\n\t\t\t\t\t\t\t\t\ttask.group = vscode.TaskGroup.Test;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tconst channel = getOutputChannel();\n\t\t\tif (err.stderr) {\n\t\t\t\tchannel.appendLine(err.stderr);\n\t\t\t}\n\t\t\tif (err.stdout) {\n\t\t\t\tchannel.appendLine(err.stdout);\n\t\t\t}\n\t\t\tchannel.appendLine(vscode.l10n.t(\"Auto detecting Grunt for folder {0} failed with error: {1}', this.workspaceFolder.name, err.error ? err.error.toString() : 'unknown\"));\n\t\t\tshowError();\n\t\t\treturn emptyTasks;\n\t\t}\n\t}\n\n\tpublic dispose() {\n\t\tthis.b = undefined;\n\t\tif (this.a) {\n\t\t\tthis.a.dispose();\n\t\t}\n\t}\n}\n\nclass TaskDetector {\n\n\tprivate a: vscode.Disposable | undefined;\n\tprivate b: Map<string, FolderDetector> = new Map();\n\n\tconstructor() {\n\t}\n\n\tpublic start(): void {\n\t\tconst folders = vscode.workspace.workspaceFolders;\n\t\tif (folders) {\n\t\t\tthis.c(folders, []);\n\t\t}\n\t\tvscode.workspace.onDidChangeWorkspaceFolders((event) => this.c(event.added, event.removed));\n\t\tvscode.workspace.onDidChangeConfiguration(this.d, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.a) {\n\t\t\tthis.a.dispose();\n\t\t\tthis.a = undefined;\n\t\t}\n\t\tthis.b.clear();\n\t}\n\n\tprivate c(added: readonly vscode.WorkspaceFolder[], removed: readonly vscode.WorkspaceFolder[]): void {\n\t\tfor (const remove of removed) {\n\t\t\tconst detector = this.b.get(remove.uri.toString());\n\t\t\tif (detector) {\n\t\t\t\tdetector.dispose();\n\t\t\t\tthis.b.delete(remove.uri.toString());\n\t\t\t}\n\t\t}\n\t\tfor (const add of added) {\n\t\t\tconst detector = new FolderDetector(add, findGruntCommand(add.uri.fsPath));\n\t\t\tthis.b.set(add.uri.toString(), detector);\n\t\t\tif (detector.isEnabled()) {\n\t\t\t\tdetector.start();\n\t\t\t}\n\t\t}\n\t\tthis.e();\n\t}\n\n\tprivate d(): void {\n\t\tfor (const detector of this.b.values()) {\n\t\t\tdetector.dispose();\n\t\t\tthis.b.delete(detector.workspaceFolder.uri.toString());\n\t\t}\n\t\tconst folders = vscode.workspace.workspaceFolders;\n\t\tif (folders) {\n\t\t\tfor (const folder of folders) {\n\t\t\t\tif (!this.b.has(folder.uri.toString())) {\n\t\t\t\t\tconst detector = new FolderDetector(folder, findGruntCommand(folder.uri.fsPath));\n\t\t\t\t\tthis.b.set(folder.uri.toString(), detector);\n\t\t\t\t\tif (detector.isEnabled()) {\n\t\t\t\t\t\tdetector.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.e();\n\t}\n\n\tprivate e(): void {\n\t\tif (!this.a && this.b.size > 0) {\n\t\t\tconst thisCapture = this;\n\t\t\tthis.a = vscode.tasks.registerTaskProvider('grunt', {\n\t\t\t\tprovideTasks: (): Promise<vscode.Task[]> => {\n\t\t\t\t\treturn thisCapture.getTasks();\n\t\t\t\t},\n\t\t\t\tresolveTask(_task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\t\t\t\treturn thisCapture.getTask(_task);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse if (this.a && this.b.size === 0) {\n\t\t\tthis.a.dispose();\n\t\t\tthis.a = undefined;\n\t\t}\n\t}\n\n\tpublic getTasks(): Promise<vscode.Task[]> {\n\t\treturn this.f();\n\t}\n\n\tprivate f(): Promise<vscode.Task[]> {\n\t\tif (this.b.size === 0) {\n\t\t\treturn Promise.resolve([]);\n\t\t} else if (this.b.size === 1) {\n\t\t\treturn this.b.values().next().value.getTasks();\n\t\t} else {\n\t\t\tconst promises: Promise<vscode.Task[]>[] = [];\n\t\t\tfor (const detector of this.b.values()) {\n\t\t\t\tpromises.push(detector.getTasks().then((value) => value, () => []));\n\t\t\t}\n\t\t\treturn Promise.all(promises).then((values) => {\n\t\t\t\tconst result: vscode.Task[] = [];\n\t\t\t\tfor (const tasks of values) {\n\t\t\t\t\tif (tasks && tasks.length > 0) {\n\t\t\t\t\t\tresult.push(...tasks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic async getTask(task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\tif (this.b.size === 0) {\n\t\t\treturn undefined;\n\t\t} else if (this.b.size === 1) {\n\t\t\treturn this.b.values().next().value.getTask(task);\n\t\t} else {\n\t\t\tif ((task.scope === vscode.TaskScope.Workspace) || (task.scope === vscode.TaskScope.Global)) {\n\t\t\t\treturn undefined;\n\t\t\t} else if (task.scope) {\n\t\t\t\tconst detector = this.b.get(task.scope.uri.toString());\n\t\t\t\tif (detector) {\n\t\t\t\t\treturn detector.getTask(task);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nlet detector: TaskDetector;\nexport function activate(_context: vscode.ExtensionContext): void {\n\tdetector = new TaskDetector();\n\tdetector.start();\n}\n\nexport function deactivate(): void {\n\tdetector.dispose();\n}\n"],"sourceRoot":""}
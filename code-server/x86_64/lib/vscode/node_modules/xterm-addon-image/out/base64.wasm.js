"use strict";
/**
 * Copyright (c) 2023 Joerg Breitbart.
 * @license MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64Decoder = void 0;
const inwasm_1 = require("inwasm");
/**
 * wasm base64 decoder.
 */
const wasmDecode = (0, inwasm_1.InWasm)(/*inwasm#938b6751b1779621:rdef-start:"decode"*/{s:1,t:0,d:'AGFzbQEAAAABBQFgAAF/Ag8BA2VudgZtZW1vcnkCAAEDAwIAAAcNAgNkZWMAAANlbmQAAQqxAwKuAQEFf0GIKCgCAEGgKGohAUGEKCgCACIAQYAoKAIAQQFrQXxxIgJIBEAgAkGgKGohAyAAQaAoaiEAA0AgAC0AA0ECdCgCgCAgAC0AAkECdCgCgBggAC0AAUECdCgCgBAgAC0AAEECdCgCgAhycnIiBEH///8HSwRAQQEPCyABIAQ2AgAgAUEDaiEBIABBBGoiACADSQ0ACwtBhCggAjYCAEGIKCABQaAoazYCAEEAC/4BAQZ/AkBBgCgoAgAiAUGEKCgCACIAa0EFTgRAQQEhAxAADQFBgCgoAgAhAUGEKCgCACEAC0EBIQMgASAAayIEQQJIDQAgAEGhKGotAABBAnQoAoAQIABBoChqLQAAQQJ0KAKACHIhAQJAIARBAkYEQEEBIQIMAQtBASECIAAtAKIoIgVBPUcEQEECIQIgBUECdCgCgBggAXIhAQsgBEEERw0AIAAtAKMoIgBBPUYNACACQQFqIQIgAEECdCgCgCAgAXIhAQsgAUH///8HSw0AQYgoKAIAQaAoaiABNgIAQYgoQYgoKAIAIAJqIgA2AgAgAEGQKCgCAEchAwsgAwsAdglwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQEFY2xhbmdWMTcuMC4wIChodHRwczovL2dpdGh1Yi5jb20vbGx2bS9sbHZtLXByb2plY3QgODg0MjFlYTk3MzkxNmU2MGMzNGJlYjI2NTk3YTVmYzMzZjgzZGQ4ZikALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0'}/*inwasm#938b6751b1779621:rdef-end:"decode"*/);
// base64 map
const MAP = new Uint8Array('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .map(el => el.charCodeAt(0)));
// init decoder maps in LE order
const D = new Uint32Array(1024);
D.fill(0xFF000000);
for (let i = 0; i < MAP.length; ++i)
    D[MAP[i]] = i << 2;
for (let i = 0; i < MAP.length; ++i)
    D[256 + MAP[i]] = i >> 4 | ((i << 4) & 0xFF) << 8;
for (let i = 0; i < MAP.length; ++i)
    D[512 + MAP[i]] = (i >> 2) << 8 | ((i << 6) & 0xFF) << 16;
for (let i = 0; i < MAP.length; ++i)
    D[768 + MAP[i]] = i << 16;
const EMPTY = new Uint8Array(0);
/**
 * base64 streamline inplace decoder.
 *
 * Features / assumptions:
 * - optimized uint32 read/write (only LE support!)
 * - lazy chunkwise decoding
 * - errors out on any non base64 chars (no support for NL formatted base64)
 * - decodes in wasm
 * - inplace decoding to save memory
 * - supports a keepSize for lazy memory release
 */
class Base64Decoder {
    constructor(keepSize) {
        this.keepSize = keepSize;
    }
    /**
     * Currently decoded bytes (borrowed).
     * Must be accessed before calling `release` or `init`.
     */
    get data8() {
        return this._inst ? this._d.subarray(0, this._m32[1282 /* P32.STATE_DP */]) : EMPTY;
    }
    /**
     * Release memory conditionally based on `keepSize`.
     * If memory gets released, also the wasm instance will be freed and recreated on next `init`,
     * otherwise the instance will be reused.
     */
    release() {
        if (!this._inst)
            return;
        if (this._mem.buffer.byteLength > this.keepSize) {
            this._inst = this._m32 = this._d = this._mem = null;
        }
        else {
            this._m32[1280 /* P32.STATE_WP */] = 0;
            this._m32[1281 /* P32.STATE_SP */] = 0;
            this._m32[1282 /* P32.STATE_DP */] = 0;
        }
    }
    /**
     * Initializes the decoder for new base64 data.
     * Must be called before doing any decoding attempts.
     * `size` is the amount of decoded bytes to be expected.
     * The method will either spawn a new wasm instance or grow
     * the needed memory of an existing instance.
     */
    init(size) {
        let m = this._m32;
        const bytes = (Math.ceil(size / 3) + 1288 /* P32.STATE_DATA */) * 4;
        if (!this._inst) {
            this._mem = new WebAssembly.Memory({ initial: Math.ceil(bytes / 65536) });
            this._inst = wasmDecode({ env: { memory: this._mem } });
            m = new Uint32Array(this._mem.buffer, 0);
            m.set(D, 256 /* P32.D0 */);
            this._d = new Uint8Array(this._mem.buffer, 1288 /* P32.STATE_DATA */ * 4);
        }
        else if (this._mem.buffer.byteLength < bytes) {
            this._mem.grow(Math.ceil((bytes - this._mem.buffer.byteLength) / 65536));
            m = new Uint32Array(this._mem.buffer, 0);
            this._d = new Uint8Array(this._mem.buffer, 1288 /* P32.STATE_DATA */ * 4);
        }
        m[1284 /* P32.STATE_BSIZE */] = size;
        m[1283 /* P32.STATE_ESIZE */] = Math.ceil(size / 3) * 4;
        m[1280 /* P32.STATE_WP */] = 0;
        m[1281 /* P32.STATE_SP */] = 0;
        m[1282 /* P32.STATE_DP */] = 0;
        this._m32 = m;
    }
    /**
     * Put bytes in `data` from `start` to `end` (exclusive) into the decoder.
     * Also decodes base64 data inplace once the payload exceeds 2^17 bytes.
     * Returns 1 on error, else 0.
     */
    put(data, start, end) {
        if (!this._inst)
            return 1;
        const m = this._m32;
        if (end - start + m[1280 /* P32.STATE_WP */] > m[1283 /* P32.STATE_ESIZE */])
            return 1;
        this._d.set(data.subarray(start, end), m[1280 /* P32.STATE_WP */]);
        m[1280 /* P32.STATE_WP */] += end - start;
        // max chunk in input handler is 2^17, try to run in "tandem mode"
        // also assures that we dont run into illegal offsets in the wasm part
        return m[1280 /* P32.STATE_WP */] - m[1281 /* P32.STATE_SP */] >= 131072 ? this._inst.exports.dec() : 0;
    }
    /**
     * End the current decoding.
     * Decodes leftover payload and finally checks for the correct amount of
     * decoded bytes by comparing to the value given to `init`.
     * Returns 1 on error, else 0.
     */
    end() {
        return this._inst ? this._inst.exports.end() : 1;
    }
}
exports.Base64Decoder = Base64Decoder;
//# sourceMappingURL=base64.wasm.js.map
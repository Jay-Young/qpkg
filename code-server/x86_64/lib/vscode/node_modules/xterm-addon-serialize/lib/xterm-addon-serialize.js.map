{"version":3,"file":"xterm-addon-serialize.js","mappings":"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","sources":["webpack://SerializeAddon/webpack/universalModuleDefinition","webpack://SerializeAddon/./src/SerializeAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SerializeAddon\"] = factory();\n\telse\n\t\troot[\"SerializeAddon\"] = factory();\n})(this, () => {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * (EXPERIMENTAL) This Addon is still under development\n */\n\nimport { Terminal, ITerminalAddon, IBuffer, IBufferCell, IBufferRange } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IAttributeData } from 'common/Types';\n\nfunction constrain(value: number, low: number, high: number): number {\n  return Math.max(low, Math.min(value, high));\n}\n\n// TODO: Refine this template class later\nabstract class BaseSerializeHandler {\n  constructor(\n    protected readonly _buffer: IBuffer\n  ) {\n  }\n\n  public serialize(range: IBufferRange): string {\n    // we need two of them to flip between old and new cell\n    const cell1 = this._buffer.getNullCell();\n    const cell2 = this._buffer.getNullCell();\n    let oldCell = cell1;\n\n    const startRow = range.start.x;\n    const endRow = range.end.x;\n    const startColumn = range.start.y;\n    const endColumn = range.end.y;\n\n    this._beforeSerialize(endRow - startRow, startRow, endRow);\n\n    for (let row = startRow; row <= endRow; row++) {\n      const line = this._buffer.getLine(row);\n      if (line) {\n        const startLineColumn = row !== range.start.x ? 0 : startColumn;\n        const endLineColumn = row !== range.end.x ? line.length : endColumn;\n        for (let col = startLineColumn; col < endLineColumn; col++) {\n          const c = line.getCell(col, oldCell === cell1 ? cell2 : cell1);\n          if (!c) {\n            console.warn(`Can't get cell at row=${row}, col=${col}`);\n            continue;\n          }\n          this._nextCell(c, oldCell, row, col);\n          oldCell = c;\n        }\n      }\n      this._rowEnd(row, row === endRow);\n    }\n\n    this._afterSerialize();\n\n    return this._serializeString();\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void { }\n  protected _rowEnd(row: number, isLastRow: boolean): void { }\n  protected _beforeSerialize(rows: number, startRow: number, endRow: number): void { }\n  protected _afterSerialize(): void { }\n  protected _serializeString(): string { return ''; }\n}\n\nfunction equalFg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getFgColorMode() === cell2.getFgColorMode()\n    && cell1.getFgColor() === cell2.getFgColor();\n}\n\nfunction equalBg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getBgColorMode() === cell2.getBgColorMode()\n    && cell1.getBgColor() === cell2.getBgColor();\n}\n\nfunction equalFlags(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.isInverse() === cell2.isInverse()\n    && cell1.isBold() === cell2.isBold()\n    && cell1.isUnderline() === cell2.isUnderline()\n    && cell1.isOverline() === cell2.isOverline()\n    && cell1.isBlink() === cell2.isBlink()\n    && cell1.isInvisible() === cell2.isInvisible()\n    && cell1.isItalic() === cell2.isItalic()\n    && cell1.isDim() === cell2.isDim()\n    && cell1.isStrikethrough() === cell2.isStrikethrough();\n}\n\nclass StringSerializeHandler extends BaseSerializeHandler {\n  private _rowIndex: number = 0;\n  private _allRows: string[] = new Array<string>();\n  private _allRowSeparators: string[] = new Array<string>();\n  private _currentRow: string = '';\n  private _nullCellCount: number = 0;\n\n  // we can see a full colored cell and a null cell that only have background the same style\n  // but the information isn't preserved by null cell itself\n  // so wee need to record it when required.\n  private _cursorStyle: IBufferCell = this._buffer.getNullCell();\n\n  // where exact the cursor styles comes from\n  // because we can't copy the cell directly\n  // so we remember where the content comes from instead\n  private _cursorStyleRow: number = 0;\n  private _cursorStyleCol: number = 0;\n\n  // this is a null cell for reference for checking whether background is empty or not\n  private _backgroundCell: IBufferCell = this._buffer.getNullCell();\n\n  private _firstRow: number = 0;\n  private _lastCursorRow: number = 0;\n  private _lastCursorCol: number = 0;\n  private _lastContentCursorRow: number = 0;\n  private _lastContentCursorCol: number = 0;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal\n  ) {\n    super(buffer);\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._allRows = new Array<string>(rows);\n    this._lastContentCursorRow = start;\n    this._lastCursorRow = start;\n    this._firstRow = start;\n  }\n\n  private _thisRowLastChar: IBufferCell = this._buffer.getNullCell();\n  private _thisRowLastSecondChar: IBufferCell = this._buffer.getNullCell();\n  private _nextRowFirstChar: IBufferCell = this._buffer.getNullCell();\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    // if there is colorful empty cell at line end, whe must pad it back, or the the color block will missing\n    if (this._nullCellCount > 0 && !equalBg(this._cursorStyle, this._backgroundCell)) {\n      // use clear right to set background.\n      this._currentRow += `\\u001b[${this._nullCellCount}X`;\n    }\n\n    let rowSeparator = '';\n\n    // handle row separator\n    if (!isLastRow) {\n      // Enable BCE\n      if (row - this._firstRow >= this._terminal.rows) {\n        this._buffer.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);\n      }\n\n      // Fetch current line\n      const currentLine = this._buffer.getLine(row)!;\n      // Fetch next line\n      const nextLine = this._buffer.getLine(row + 1)!;\n\n      if (!nextLine.isWrapped) {\n        // just insert the line break\n        rowSeparator = '\\r\\n';\n        // we sended the enter\n        this._lastCursorRow = row + 1;\n        this._lastCursorCol = 0;\n      } else {\n        rowSeparator = '';\n        const thisRowLastChar = currentLine.getCell(currentLine.length - 1, this._thisRowLastChar)!;\n        const thisRowLastSecondChar = currentLine.getCell(currentLine.length - 2, this._thisRowLastSecondChar)!;\n        const nextRowFirstChar = nextLine.getCell(0, this._nextRowFirstChar)!;\n        const isNextRowFirstCharDoubleWidth = nextRowFirstChar.getWidth() > 1;\n\n        // validate whether this line wrap is ever possible\n        // which mean whether cursor can placed at a overflow position (x === row) naturally\n        let isValid = false;\n\n        if (\n          // you must output character to cause overflow, control sequence can't do this\n          nextRowFirstChar.getChars() &&\n            isNextRowFirstCharDoubleWidth ? this._nullCellCount <= 1 : this._nullCellCount <= 0\n        ) {\n          if (\n            // the last character can't be null,\n            // you can't use control sequence to move cursor to (x === row)\n            (thisRowLastChar.getChars() || thisRowLastChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n\n          if (\n            // the second to last character can't be null if the next line starts with CJK,\n            // you can't use control sequence to move cursor to (x === row)\n            isNextRowFirstCharDoubleWidth &&\n            (thisRowLastSecondChar.getChars() || thisRowLastSecondChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar) &&\n            equalBg(thisRowLastSecondChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n        }\n\n        if (!isValid) {\n          // force the wrap with magic\n          // insert enough character to force the wrap\n          rowSeparator = '-'.repeat(this._nullCellCount + 1);\n          // move back and erase next line head\n          rowSeparator += '\\u001b[1D\\u001b[1X';\n\n          if (this._nullCellCount > 0) {\n            // do these because we filled the last several null slot, which we shouldn't\n            rowSeparator += '\\u001b[A';\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}C`;\n            rowSeparator += `\\u001b[${this._nullCellCount}X`;\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}D`;\n            rowSeparator += '\\u001b[B';\n          }\n\n          // This is content and need the be serialized even it is invisible.\n          // without this, wrap will be missing from outputs.\n          this._lastContentCursorRow = row + 1;\n          this._lastContentCursorCol = 0;\n\n          // force commit the cursor position\n          this._lastCursorRow = row + 1;\n          this._lastCursorCol = 0;\n        }\n      }\n    }\n\n    this._allRows[this._rowIndex] = this._currentRow;\n    this._allRowSeparators[this._rowIndex++] = rowSeparator;\n    this._currentRow = '';\n    this._nullCellCount = 0;\n  }\n\n  private _diffStyle(cell: IBufferCell | IAttributeData, oldCell: IBufferCell): number[] {\n    const sgrSeq: number[] = [];\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      if (cell.isAttributeDefault()) {\n        if (!oldCell.isAttributeDefault()) {\n          sgrSeq.push(0);\n        }\n      } else {\n        if (fgChanged) {\n          const color = cell.getFgColor();\n          if (cell.isFgRGB()) { sgrSeq.push(38, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isFgPalette()) {\n            if (color >= 16) { sgrSeq.push(38, 5, color); }\n            else { sgrSeq.push(color & 8 ? 90 + (color & 7) : 30 + (color & 7)); }\n          }\n          else { sgrSeq.push(39); }\n        }\n        if (bgChanged) {\n          const color = cell.getBgColor();\n          if (cell.isBgRGB()) { sgrSeq.push(48, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isBgPalette()) {\n            if (color >= 16) { sgrSeq.push(48, 5, color); }\n            else { sgrSeq.push(color & 8 ? 100 + (color & 7) : 40 + (color & 7)); }\n          }\n          else { sgrSeq.push(49); }\n        }\n        if (flagsChanged) {\n          if (cell.isInverse() !== oldCell.isInverse()) { sgrSeq.push(cell.isInverse() ? 7 : 27); }\n          if (cell.isBold() !== oldCell.isBold()) { sgrSeq.push(cell.isBold() ? 1 : 22); }\n          if (cell.isUnderline() !== oldCell.isUnderline()) { sgrSeq.push(cell.isUnderline() ? 4 : 24); }\n          if (cell.isOverline() !== oldCell.isOverline()) { sgrSeq.push(cell.isOverline() ? 53 : 55); }\n          if (cell.isBlink() !== oldCell.isBlink()) { sgrSeq.push(cell.isBlink() ? 5 : 25); }\n          if (cell.isInvisible() !== oldCell.isInvisible()) { sgrSeq.push(cell.isInvisible() ? 8 : 28); }\n          if (cell.isItalic() !== oldCell.isItalic()) { sgrSeq.push(cell.isItalic() ? 3 : 23); }\n          if (cell.isDim() !== oldCell.isDim()) { sgrSeq.push(cell.isDim() ? 2 : 22); }\n          if (cell.isStrikethrough() !== oldCell.isStrikethrough()) { sgrSeq.push(cell.isStrikethrough() ? 9 : 29); }\n        }\n      }\n    }\n\n    return sgrSeq;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const sgrSeq = this._diffStyle(cell, this._cursorStyle);\n\n    // the empty cell style is only assumed to be changed when background changed, because foreground is always 0.\n    const styleChanged = isEmptyCell ? !equalBg(this._cursorStyle, cell) : sgrSeq.length > 0;\n\n    /**\n     *  handles style change\n     */\n    if (styleChanged) {\n      // before update the style, we need to fill empty cell back\n      if (this._nullCellCount > 0) {\n        // use clear right to set background.\n        if (!equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n        }\n        // use move right to move cursor.\n        this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        this._nullCellCount = 0;\n      }\n\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col;\n\n      this._currentRow += `\\u001b[${sgrSeq.join(';')}m`;\n\n      // update the last cursor style\n      const line = this._buffer.getLine(row);\n      if (line !== undefined) {\n        line.getCell(col, this._cursorStyle);\n        this._cursorStyleRow = row;\n        this._cursorStyleCol = col;\n      }\n    }\n\n    /**\n     *  handles actual content\n     */\n    if (isEmptyCell) {\n      this._nullCellCount += cell.getWidth();\n    } else {\n      if (this._nullCellCount > 0) {\n        // we can just assume we have same style with previous one here\n        // because style change is handled by previous stage\n        // use move right when background is empty, use clear right when there is background.\n        if (equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        } else {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        }\n        this._nullCellCount = 0;\n      }\n\n      this._currentRow += cell.getChars();\n\n      // update cursor\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col + cell.getWidth();\n    }\n  }\n\n  protected _serializeString(): string {\n    let rowEnd = this._allRows.length;\n\n    // the fixup is only required for data without scrollback\n    // because it will always be placed at last line otherwise\n    if (this._buffer.length - this._firstRow <= this._terminal.rows) {\n      rowEnd = this._lastContentCursorRow + 1 - this._firstRow;\n      this._lastCursorCol = this._lastContentCursorCol;\n      this._lastCursorRow = this._lastContentCursorRow;\n    }\n\n    let content = '';\n\n    for (let i = 0; i < rowEnd; i++) {\n      content += this._allRows[i];\n      if (i + 1 < rowEnd) {\n        content += this._allRowSeparators[i];\n      }\n    }\n\n    // restore the cursor\n    const realCursorRow = this._buffer.baseY + this._buffer.cursorY;\n    const realCursorCol = this._buffer.cursorX;\n\n    const cursorMoved = (realCursorRow !== this._lastCursorRow || realCursorCol !== this._lastCursorCol);\n\n    const moveRight = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}C`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}D`;\n      }\n    };\n    const moveDown = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}B`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}A`;\n      }\n    };\n\n    if (cursorMoved) {\n      moveDown(realCursorRow - this._lastCursorRow);\n      moveRight(realCursorCol - this._lastCursorCol);\n    }\n\n    // Restore the cursor's current style, see https://github.com/xtermjs/xterm.js/issues/3677\n    // HACK: Internal API access since it's awkward to expose this in the API and serialize will\n    // likely be the only consumer\n    const curAttrData: IAttributeData = (this._terminal as any)._core._inputHandler._curAttrData;\n    const sgrSeq = this._diffStyle(curAttrData, this._cursorStyle);\n    if (sgrSeq.length > 0) {\n      content += `\\u001b[${sgrSeq.join(';')}m`;\n    }\n\n    return content;\n  }\n}\n\nexport class SerializeAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  constructor() { }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  private _serializeBuffer(terminal: Terminal, buffer: IBuffer, scrollback?: number): string {\n    const maxRows = buffer.length;\n    const handler = new StringSerializeHandler(buffer, terminal);\n    const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n    return handler.serialize({\n      start: { x: maxRows - correctRows, y: 0 },\n      end: { x: maxRows - 1, y: terminal.cols }\n    });\n  }\n\n  private _serializeBufferAsHTML(terminal: Terminal, options: Partial<IHTMLSerializeOptions>): string {\n    const buffer = terminal.buffer.active;\n    const handler = new HTMLSerializeHandler(buffer, terminal, options);\n    const onlySelection = options.onlySelection ?? false;\n    if (!onlySelection) {\n      const maxRows = buffer.length;\n      const scrollback = options.scrollback;\n      const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n      return handler.serialize({\n        start: { x: maxRows - correctRows, y: 0 },\n        end: { x: maxRows - 1, y: terminal.cols }\n      });\n    }\n\n    const selection = this._terminal?.getSelectionPosition();\n    if (selection !== undefined) {\n      return handler.serialize({\n        start: { x: selection.start.y, y: selection.start.x },\n        end: { x: selection.end.y, y: selection.end.x }\n      });\n    }\n\n    return '';\n  }\n\n  private _serializeModes(terminal: Terminal): string {\n    let content = '';\n    const modes = terminal.modes;\n\n    // Default: false\n    if (modes.applicationCursorKeysMode) content += '\\x1b[?1h';\n    if (modes.applicationKeypadMode) content += '\\x1b[?66h';\n    if (modes.bracketedPasteMode) content += '\\x1b[?2004h';\n    if (modes.insertMode) content += '\\x1b[4h';\n    if (modes.originMode) content += '\\x1b[?6h';\n    if (modes.reverseWraparoundMode) content += '\\x1b[?45h';\n    if (modes.sendFocusMode) content += '\\x1b[?1004h';\n\n    // Default: true\n    if (modes.wraparoundMode === false) content += '\\x1b[?7l';\n\n    // Default: 'none'\n    if (modes.mouseTrackingMode !== 'none') {\n      switch (modes.mouseTrackingMode) {\n        case 'x10': content += '\\x1b[?9h'; break;\n        case 'vt200': content += '\\x1b[?1000h'; break;\n        case 'drag': content += '\\x1b[?1002h'; break;\n        case 'any': content += '\\x1b[?1003h'; break;\n      }\n    }\n\n    return content;\n  }\n\n  public serialize(options?: ISerializeOptions): string {\n    // TODO: Add combinedData support\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    // Normal buffer\n    let content = this._serializeBuffer(this._terminal, this._terminal.buffer.normal, options?.scrollback);\n\n    // Alternate buffer\n    if (!options?.excludeAltBuffer) {\n      if (this._terminal.buffer.active.type === 'alternate') {\n        const alternativeScreenContent = this._serializeBuffer(this._terminal, this._terminal.buffer.alternate, undefined);\n        content += `\\u001b[?1049h\\u001b[H${alternativeScreenContent}`;\n      }\n    }\n\n    // Modes\n    if (!options?.excludeModes) {\n      content += this._serializeModes(this._terminal);\n    }\n\n    return content;\n  }\n\n  public serializeAsHTML(options?: Partial<IHTMLSerializeOptions>): string {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    return this._serializeBufferAsHTML(this._terminal, options || {});\n  }\n\n  public dispose(): void { }\n}\n\n\ninterface ISerializeOptions {\n  scrollback?: number;\n  excludeModes?: boolean;\n  excludeAltBuffer?: boolean;\n}\n\ninterface IHTMLSerializeOptions {\n  scrollback: number;\n  onlySelection: boolean;\n  includeGlobalBackground: boolean;\n}\n\nexport class HTMLSerializeHandler extends BaseSerializeHandler {\n  private _currentRow: string = '';\n\n  private _htmlContent = '';\n\n  private _colors: IColorSet;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal,\n    private readonly _options: Partial<IHTMLSerializeOptions>\n  ) {\n    super(buffer);\n\n    // https://github.com/xtermjs/xterm.js/issues/3601\n    this._colors = (_terminal as any)._core._themeService.colors;\n  }\n\n  private _padStart(target: string, targetLength: number, padString: string): string {\n    targetLength = targetLength >> 0;\n    padString = padString ?? ' ';\n    if (target.length > targetLength) {\n      return target;\n    }\n\n    targetLength -= target.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + target;\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._htmlContent += '<html><body><!--StartFragment--><pre>';\n\n    let foreground = '#000000';\n    let background = '#ffffff';\n    if (this._options.includeGlobalBackground ?? false) {\n      foreground = this._terminal.options.theme?.foreground ?? '#ffffff';\n      background = this._terminal.options.theme?.background ?? '#000000';\n    }\n\n    const globalStyleDefinitions = [];\n    globalStyleDefinitions.push('color: ' + foreground + ';');\n    globalStyleDefinitions.push('background-color: ' + background + ';');\n    globalStyleDefinitions.push('font-family: ' + this._terminal.options.fontFamily + ';');\n    globalStyleDefinitions.push('font-size: ' + this._terminal.options.fontSize + 'px;');\n    this._htmlContent += '<div style=\\'' + globalStyleDefinitions.join(' ') + '\\'>';\n  }\n\n  protected _afterSerialize(): void {\n    this._htmlContent += '</div>';\n    this._htmlContent += '</pre><!--EndFragment--></body></html>';\n  }\n\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    this._htmlContent += '<div><span>' + this._currentRow + '</span></div>';\n    this._currentRow = '';\n  }\n\n  private _getHexColor(cell: IBufferCell, isFg: boolean): string | undefined {\n    const color = isFg ? cell.getFgColor() : cell.getBgColor();\n    if (isFg ? cell.isFgRGB() : cell.isBgRGB()) {\n      const rgb = [\n        (color >> 16) & 255,\n        (color >>  8) & 255,\n        (color      ) & 255\n      ];\n      return rgb.map(x => this._padStart(x.toString(16), 2, '0')).join('');\n    }\n    if (isFg ? cell.isFgPalette() : cell.isBgPalette()) {\n      return this._colors.ansi[color].css;\n    }\n    return undefined;\n  }\n\n  private _diffStyle(cell: IBufferCell, oldCell: IBufferCell): string[] | undefined {\n    const content: string[] = [];\n\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      const fgHexColor = this._getHexColor(cell, true);\n      if (fgHexColor) {\n        content.push('color: ' + fgHexColor + ';');\n      }\n\n      const bgHexColor = this._getHexColor(cell, false);\n      if (bgHexColor) {\n        content.push('background-color: ' + bgHexColor + ';');\n      }\n\n      if (cell.isInverse()) { content.push('color: #000000; background-color: #BFBFBF;'); }\n      if (cell.isBold()) { content.push('font-weight: bold;'); }\n      if (cell.isUnderline() && cell.isOverline()) { content.push('text-decoration: overline underline;'); }\n      else if (cell.isUnderline()) { content.push('text-decoration: underline;'); }\n      else if (cell.isOverline()) { content.push('text-decoration: overline;'); }\n      if (cell.isBlink()) { content.push('text-decoration: blink;'); }\n      if (cell.isInvisible()) { content.push('visibility: hidden;'); }\n      if (cell.isItalic()) { content.push('font-style: italic;'); }\n      if (cell.isDim()) { content.push('opacity: 0.5;'); }\n      if (cell.isStrikethrough()) { content.push('text-decoration: line-through;'); }\n\n      return content;\n    }\n\n    return undefined;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const styleDefinitions = this._diffStyle(cell, oldCell);\n\n    // handles style change\n    if (styleDefinitions) {\n      this._currentRow += styleDefinitions.length === 0 ?\n        '</span><span>' :\n        '</span><span style=\\'' + styleDefinitions.join(' ') + '\\'>';\n    }\n\n    // handles actual content\n    if (isEmptyCell) {\n      this._currentRow += ' ';\n    } else {\n      this._currentRow += cell.getChars();\n    }\n  }\n\n  protected _serializeString(): string {\n    return this._htmlContent;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","this","constrain","value","low","high","Math","max","min","BaseSerializeHandler","constructor","_buffer","serialize","range","cell1","getNullCell","cell2","oldCell","startRow","start","x","endRow","end","startColumn","y","endColumn","_beforeSerialize","row","line","getLine","startLineColumn","endLineColumn","length","col","c","getCell","_nextCell","console","warn","_rowEnd","_afterSerialize","_serializeString","cell","isLastRow","rows","equalFg","getFgColorMode","getFgColor","equalBg","getBgColorMode","getBgColor","equalFlags","isInverse","isBold","isUnderline","isOverline","isBlink","isInvisible","isItalic","isDim","isStrikethrough","StringSerializeHandler","buffer","_terminal","super","_rowIndex","_allRows","Array","_allRowSeparators","_currentRow","_nullCellCount","_cursorStyle","_cursorStyleRow","_cursorStyleCol","_backgroundCell","_firstRow","_lastCursorRow","_lastCursorCol","_lastContentCursorRow","_lastContentCursorCol","_thisRowLastChar","_thisRowLastSecondChar","_nextRowFirstChar","rowSeparator","currentLine","nextLine","isWrapped","thisRowLastChar","thisRowLastSecondChar","nextRowFirstChar","isNextRowFirstCharDoubleWidth","getWidth","isValid","getChars","repeat","_diffStyle","sgrSeq","fgChanged","bgChanged","flagsChanged","isAttributeDefault","push","color","isFgRGB","isFgPalette","isBgRGB","isBgPalette","isEmptyCell","join","undefined","rowEnd","content","i","realCursorRow","baseY","cursorY","realCursorCol","cursorX","offset","moveRight","curAttrData","_core","_inputHandler","_curAttrData","activate","terminal","_serializeBuffer","scrollback","maxRows","handler","correctRows","cols","_serializeBufferAsHTML","options","active","HTMLSerializeHandler","onlySelection","selection","getSelectionPosition","_serializeModes","modes","applicationCursorKeysMode","applicationKeypadMode","bracketedPasteMode","insertMode","originMode","reverseWraparoundMode","sendFocusMode","wraparoundMode","mouseTrackingMode","Error","normal","excludeAltBuffer","type","alternate","excludeModes","serializeAsHTML","dispose","_options","_htmlContent","_colors","_themeService","colors","_padStart","target","targetLength","padString","slice","foreground","background","includeGlobalBackground","theme","globalStyleDefinitions","fontFamily","fontSize","_getHexColor","isFg","map","toString","ansi","css","fgHexColor","bgHexColor","styleDefinitions"],"sourceRoot":""}
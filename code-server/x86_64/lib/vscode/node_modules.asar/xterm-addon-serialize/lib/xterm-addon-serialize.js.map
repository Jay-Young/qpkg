{"version":3,"file":"xterm-addon-serialize.js","mappings":"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","sources":["webpack://SerializeAddon/webpack/universalModuleDefinition","webpack://SerializeAddon/./src/SerializeAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SerializeAddon\"] = factory();\n\telse\n\t\troot[\"SerializeAddon\"] = factory();\n})(this, function() {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * (EXPERIMENTAL) This Addon is still under development\n */\n\nimport { Terminal, ITerminalAddon, IBuffer, IBufferCell, IBufferRange } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IAttributeData } from 'common/Types';\n\nfunction constrain(value: number, low: number, high: number): number {\n  return Math.max(low, Math.min(value, high));\n}\n\n// TODO: Refine this template class later\nabstract class BaseSerializeHandler {\n  constructor(\n    protected readonly _buffer: IBuffer\n  ) {\n  }\n\n  public serialize(range: IBufferRange): string {\n    // we need two of them to flip between old and new cell\n    const cell1 = this._buffer.getNullCell();\n    const cell2 = this._buffer.getNullCell();\n    let oldCell = cell1;\n\n    const startRow = range.start.x;\n    const endRow = range.end.x;\n    const startColumn = range.start.y;\n    const endColumn = range.end.y;\n\n    this._beforeSerialize(endRow - startRow, startRow, endRow);\n\n    for (let row = startRow; row <= endRow; row++) {\n      const line = this._buffer.getLine(row);\n      if (line) {\n        const startLineColumn = row !== range.start.x ? 0 : startColumn;\n        const endLineColumn = row !== range.end.x ? line.length : endColumn;\n        for (let col = startLineColumn; col < endLineColumn; col++) {\n          const c = line.getCell(col, oldCell === cell1 ? cell2 : cell1);\n          if (!c) {\n            console.warn(`Can't get cell at row=${row}, col=${col}`);\n            continue;\n          }\n          this._nextCell(c, oldCell, row, col);\n          oldCell = c;\n        }\n      }\n      this._rowEnd(row, row === endRow);\n    }\n\n    this._afterSerialize();\n\n    return this._serializeString();\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void { }\n  protected _rowEnd(row: number, isLastRow: boolean): void { }\n  protected _beforeSerialize(rows: number, startRow: number, endRow: number): void { }\n  protected _afterSerialize(): void { }\n  protected _serializeString(): string { return ''; }\n}\n\nfunction equalFg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getFgColorMode() === cell2.getFgColorMode()\n    && cell1.getFgColor() === cell2.getFgColor();\n}\n\nfunction equalBg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getBgColorMode() === cell2.getBgColorMode()\n    && cell1.getBgColor() === cell2.getBgColor();\n}\n\nfunction equalFlags(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.isInverse() === cell2.isInverse()\n    && cell1.isBold() === cell2.isBold()\n    && cell1.isUnderline() === cell2.isUnderline()\n    && cell1.isBlink() === cell2.isBlink()\n    && cell1.isInvisible() === cell2.isInvisible()\n    && cell1.isItalic() === cell2.isItalic()\n    && cell1.isDim() === cell2.isDim()\n    && cell1.isStrikethrough() === cell2.isStrikethrough();\n}\n\nclass StringSerializeHandler extends BaseSerializeHandler {\n  private _rowIndex: number = 0;\n  private _allRows: string[] = new Array<string>();\n  private _allRowSeparators: string[] = new Array<string>();\n  private _currentRow: string = '';\n  private _nullCellCount: number = 0;\n\n  // we can see a full colored cell and a null cell that only have background the same style\n  // but the information isn't preserved by null cell itself\n  // so wee need to record it when required.\n  private _cursorStyle: IBufferCell = this._buffer.getNullCell();\n\n  // where exact the cursor styles comes from\n  // because we can't copy the cell directly\n  // so we remember where the content comes from instead\n  private _cursorStyleRow: number = 0;\n  private _cursorStyleCol: number = 0;\n\n  // this is a null cell for reference for checking whether background is empty or not\n  private _backgroundCell: IBufferCell = this._buffer.getNullCell();\n\n  private _firstRow: number = 0;\n  private _lastCursorRow: number = 0;\n  private _lastCursorCol: number = 0;\n  private _lastContentCursorRow: number = 0;\n  private _lastContentCursorCol: number = 0;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal\n  ) {\n    super(buffer);\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._allRows = new Array<string>(rows);\n    this._lastContentCursorRow = start;\n    this._lastCursorRow = start;\n    this._firstRow = start;\n  }\n\n  private _thisRowLastChar: IBufferCell = this._buffer.getNullCell();\n  private _thisRowLastSecondChar: IBufferCell = this._buffer.getNullCell();\n  private _nextRowFirstChar: IBufferCell = this._buffer.getNullCell();\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    // if there is colorful empty cell at line end, whe must pad it back, or the the color block will missing\n    if (this._nullCellCount > 0 && !equalBg(this._cursorStyle, this._backgroundCell)) {\n      // use clear right to set background.\n      this._currentRow += `\\u001b[${this._nullCellCount}X`;\n    }\n\n    let rowSeparator = '';\n\n    // handle row separator\n    if (!isLastRow) {\n      // Enable BCE\n      if (row - this._firstRow >= this._terminal.rows) {\n        this._buffer.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);\n      }\n\n      // Fetch current line\n      const currentLine = this._buffer.getLine(row)!;\n      // Fetch next line\n      const nextLine = this._buffer.getLine(row + 1)!;\n\n      if (!nextLine.isWrapped) {\n        // just insert the line break\n        rowSeparator = '\\r\\n';\n        // we sended the enter\n        this._lastCursorRow = row + 1;\n        this._lastCursorCol = 0;\n      } else {\n        rowSeparator = '';\n        const thisRowLastChar = currentLine.getCell(currentLine.length - 1, this._thisRowLastChar)!;\n        const thisRowLastSecondChar = currentLine.getCell(currentLine.length - 2, this._thisRowLastSecondChar)!;\n        const nextRowFirstChar = nextLine.getCell(0, this._nextRowFirstChar)!;\n        const isNextRowFirstCharDoubleWidth = nextRowFirstChar.getWidth() > 1;\n\n        // validate whether this line wrap is ever possible\n        // which mean whether cursor can placed at a overflow position (x === row) naturally\n        let isValid = false;\n\n        if (\n          // you must output character to cause overflow, control sequence can't do this\n          nextRowFirstChar.getChars() &&\n            isNextRowFirstCharDoubleWidth ? this._nullCellCount <= 1 : this._nullCellCount <= 0\n        ) {\n          if (\n            // the last character can't be null,\n            // you can't use control sequence to move cursor to (x === row)\n            (thisRowLastChar.getChars() || thisRowLastChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n\n          if (\n            // the second to last character can't be null if the next line starts with CJK,\n            // you can't use control sequence to move cursor to (x === row)\n            isNextRowFirstCharDoubleWidth &&\n            (thisRowLastSecondChar.getChars() || thisRowLastSecondChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar) &&\n            equalBg(thisRowLastSecondChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n        }\n\n        if (!isValid) {\n          // force the wrap with magic\n          // insert enough character to force the wrap\n          rowSeparator = '-'.repeat(this._nullCellCount + 1);\n          // move back and erase next line head\n          rowSeparator += '\\u001b[1D\\u001b[1X';\n\n          if (this._nullCellCount > 0) {\n            // do these because we filled the last several null slot, which we shouldn't\n            rowSeparator += '\\u001b[A';\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}C`;\n            rowSeparator += `\\u001b[${this._nullCellCount}X`;\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}D`;\n            rowSeparator += '\\u001b[B';\n          }\n\n          // This is content and need the be serialized even it is invisible.\n          // without this, wrap will be missing from outputs.\n          this._lastContentCursorRow = row + 1;\n          this._lastContentCursorCol = 0;\n\n          // force commit the cursor position\n          this._lastCursorRow = row + 1;\n          this._lastCursorCol = 0;\n        }\n      }\n    }\n\n    this._allRows[this._rowIndex] = this._currentRow;\n    this._allRowSeparators[this._rowIndex++] = rowSeparator;\n    this._currentRow = '';\n    this._nullCellCount = 0;\n  }\n\n  private _diffStyle(cell: IBufferCell | IAttributeData, oldCell: IBufferCell): number[] {\n    const sgrSeq: number[] = [];\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      if (cell.isAttributeDefault()) {\n        if (!oldCell.isAttributeDefault()) {\n          sgrSeq.push(0);\n        }\n      } else {\n        if (fgChanged) {\n          const color = cell.getFgColor();\n          if (cell.isFgRGB()) { sgrSeq.push(38, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isFgPalette()) {\n            if (color >= 16) { sgrSeq.push(38, 5, color); }\n            else { sgrSeq.push(color & 8 ? 90 + (color & 7) : 30 + (color & 7)); }\n          }\n          else { sgrSeq.push(39); }\n        }\n        if (bgChanged) {\n          const color = cell.getBgColor();\n          if (cell.isBgRGB()) { sgrSeq.push(48, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isBgPalette()) {\n            if (color >= 16) { sgrSeq.push(48, 5, color); }\n            else { sgrSeq.push(color & 8 ? 100 + (color & 7) : 40 + (color & 7)); }\n          }\n          else { sgrSeq.push(49); }\n        }\n        if (flagsChanged) {\n          if (cell.isInverse() !== oldCell.isInverse()) { sgrSeq.push(cell.isInverse() ? 7 : 27); }\n          if (cell.isBold() !== oldCell.isBold()) { sgrSeq.push(cell.isBold() ? 1 : 22); }\n          if (cell.isUnderline() !== oldCell.isUnderline()) { sgrSeq.push(cell.isUnderline() ? 4 : 24); }\n          if (cell.isBlink() !== oldCell.isBlink()) { sgrSeq.push(cell.isBlink() ? 5 : 25); }\n          if (cell.isInvisible() !== oldCell.isInvisible()) { sgrSeq.push(cell.isInvisible() ? 8 : 28); }\n          if (cell.isItalic() !== oldCell.isItalic()) { sgrSeq.push(cell.isItalic() ? 3 : 23); }\n          if (cell.isDim() !== oldCell.isDim()) { sgrSeq.push(cell.isDim() ? 2 : 22); }\n          if (cell.isStrikethrough() !== oldCell.isStrikethrough()) { sgrSeq.push(cell.isStrikethrough() ? 9 : 29); }\n        }\n      }\n    }\n\n    return sgrSeq;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const sgrSeq = this._diffStyle(cell, this._cursorStyle);\n\n    // the empty cell style is only assumed to be changed when background changed, because foreground is always 0.\n    const styleChanged = isEmptyCell ? !equalBg(this._cursorStyle, cell) : sgrSeq.length > 0;\n\n    /**\n     *  handles style change\n     */\n    if (styleChanged) {\n      // before update the style, we need to fill empty cell back\n      if (this._nullCellCount > 0) {\n        // use clear right to set background.\n        if (!equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n        }\n        // use move right to move cursor.\n        this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        this._nullCellCount = 0;\n      }\n\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col;\n\n      this._currentRow += `\\u001b[${sgrSeq.join(';')}m`;\n\n      // update the last cursor style\n      const line = this._buffer.getLine(row);\n      if (line !== undefined) {\n        line.getCell(col, this._cursorStyle);\n        this._cursorStyleRow = row;\n        this._cursorStyleCol = col;\n      }\n    }\n\n    /**\n     *  handles actual content\n     */\n    if (isEmptyCell) {\n      this._nullCellCount += cell.getWidth();\n    } else {\n      if (this._nullCellCount > 0) {\n        // we can just assume we have same style with previous one here\n        // because style change is handled by previous stage\n        // use move right when background is empty, use clear right when there is background.\n        if (equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        } else {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        }\n        this._nullCellCount = 0;\n      }\n\n      this._currentRow += cell.getChars();\n\n      // update cursor\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col + cell.getWidth();\n    }\n  }\n\n  protected _serializeString(): string {\n    let rowEnd = this._allRows.length;\n\n    // the fixup is only required for data without scrollback\n    // because it will always be placed at last line otherwise\n    if (this._buffer.length - this._firstRow <= this._terminal.rows) {\n      rowEnd = this._lastContentCursorRow + 1 - this._firstRow;\n      this._lastCursorCol = this._lastContentCursorCol;\n      this._lastCursorRow = this._lastContentCursorRow;\n    }\n\n    let content = '';\n\n    for (let i = 0; i < rowEnd; i++) {\n      content += this._allRows[i];\n      if (i + 1 < rowEnd) {\n        content += this._allRowSeparators[i];\n      }\n    }\n\n    // restore the cursor\n    const realCursorRow = this._buffer.baseY + this._buffer.cursorY;\n    const realCursorCol = this._buffer.cursorX;\n\n    const cursorMoved = (realCursorRow !== this._lastCursorRow || realCursorCol !== this._lastCursorCol);\n\n    const moveRight = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}C`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}D`;\n      }\n    };\n    const moveDown = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}B`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}A`;\n      }\n    };\n\n    if (cursorMoved) {\n      moveDown(realCursorRow - this._lastCursorRow);\n      moveRight(realCursorCol - this._lastCursorCol);\n    }\n\n    // Restore the cursor's current style, see https://github.com/xtermjs/xterm.js/issues/3677\n    // HACK: Internal API access since it's awkward to expose this in the API and serialize will\n    // likely be the only consumer\n    const curAttrData: IAttributeData = (this._terminal as any)._core._inputHandler._curAttrData;\n    const sgrSeq = this._diffStyle(curAttrData, this._cursorStyle);\n    if (sgrSeq.length > 0) {\n      content += `\\u001b[${sgrSeq.join(';')}m`;\n    }\n\n    return content;\n  }\n}\n\nexport class SerializeAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  constructor() { }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  private _serializeBuffer(terminal: Terminal, buffer: IBuffer, scrollback?: number): string {\n    const maxRows = buffer.length;\n    const handler = new StringSerializeHandler(buffer, terminal);\n    const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n    return handler.serialize({\n      start: { x: maxRows - correctRows, y: 0 },\n      end: { x: maxRows - 1, y: terminal.cols }\n    });\n  }\n\n  private _serializeBufferAsHTML(terminal: Terminal, options: Partial<IHTMLSerializeOptions>): string {\n    const buffer = terminal.buffer.active;\n    const handler = new HTMLSerializeHandler(buffer, terminal, options);\n    const onlySelection = options.onlySelection ?? false;\n    if (!onlySelection) {\n      const maxRows = buffer.length;\n      const scrollback = options.scrollback;\n      const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n      return handler.serialize({\n        start: { x: maxRows - correctRows, y: 0 },\n        end: { x: maxRows - 1, y: terminal.cols }\n      });\n    }\n\n    const selection = this._terminal?.getSelectionPosition();\n    if (selection !== undefined) {\n      return handler.serialize({\n        start: { x: selection.start.y, y: selection.start.x },\n        end: { x: selection.end.y, y: selection.end.x }\n      });\n    }\n\n    return '';\n  }\n\n  private _serializeModes(terminal: Terminal): string {\n    let content = '';\n    const modes = terminal.modes;\n\n    // Default: false\n    if (modes.applicationCursorKeysMode) content += '\\x1b[?1h';\n    if (modes.applicationKeypadMode) content += '\\x1b[?66h';\n    if (modes.bracketedPasteMode) content += '\\x1b[?2004h';\n    if (modes.insertMode) content += '\\x1b[4h';\n    if (modes.originMode) content += '\\x1b[?6h';\n    if (modes.reverseWraparoundMode) content += '\\x1b[?45h';\n    if (modes.sendFocusMode) content += '\\x1b[?1004h';\n\n    // Default: true\n    if (modes.wraparoundMode === false) content += '\\x1b[?7l';\n\n    // Default: 'none'\n    if (modes.mouseTrackingMode !== 'none') {\n      switch (modes.mouseTrackingMode) {\n        case 'x10': content += '\\x1b[?9h'; break;\n        case 'vt200': content += '\\x1b[?1000h'; break;\n        case 'drag': content += '\\x1b[?1002h'; break;\n        case 'any': content += '\\x1b[?1003h'; break;\n      }\n    }\n\n    return content;\n  }\n\n  public serialize(options?: ISerializeOptions): string {\n    // TODO: Add combinedData support\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    // Normal buffer\n    let content = this._serializeBuffer(this._terminal, this._terminal.buffer.normal, options?.scrollback);\n\n    // Alternate buffer\n    if (!options?.excludeAltBuffer) {\n      if (this._terminal.buffer.active.type === 'alternate') {\n        const alternativeScreenContent = this._serializeBuffer(this._terminal, this._terminal.buffer.alternate, undefined);\n        content += `\\u001b[?1049h\\u001b[H${alternativeScreenContent}`;\n      }\n    }\n\n    // Modes\n    if (!options?.excludeModes) {\n      content += this._serializeModes(this._terminal);\n    }\n\n    return content;\n  }\n\n  public serializeAsHTML(options?: Partial<IHTMLSerializeOptions>): string {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    return this._serializeBufferAsHTML(this._terminal, options || {});\n  }\n\n  public dispose(): void { }\n}\n\n\ninterface ISerializeOptions {\n  scrollback?: number;\n  excludeModes?: boolean;\n  excludeAltBuffer?: boolean;\n}\n\ninterface IHTMLSerializeOptions {\n  scrollback: number;\n  onlySelection: boolean;\n  includeGlobalBackground: boolean;\n}\n\nexport class HTMLSerializeHandler extends BaseSerializeHandler {\n  private _currentRow: string = '';\n\n  private _htmlContent = '';\n\n  private _colors: IColorSet;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal,\n    private readonly _options: Partial<IHTMLSerializeOptions>\n  ) {\n    super(buffer);\n\n    // https://github.com/xtermjs/xterm.js/issues/3601\n    this._colors = (_terminal as any)._core._themeService.colors;\n  }\n\n  private _padStart(target: string, targetLength: number, padString: string): string {\n    targetLength = targetLength >> 0;\n    padString = padString ?? ' ';\n    if (target.length > targetLength) {\n      return target;\n    }\n\n    targetLength -= target.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + target;\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._htmlContent += '<html><body><!--StartFragment--><pre>';\n\n    let foreground = '#000000';\n    let background = '#ffffff';\n    if (this._options.includeGlobalBackground ?? false) {\n      foreground = this._terminal.options.theme?.foreground ?? '#ffffff';\n      background = this._terminal.options.theme?.background ?? '#000000';\n    }\n\n    const globalStyleDefinitions = [];\n    globalStyleDefinitions.push('color: ' + foreground + ';');\n    globalStyleDefinitions.push('background-color: ' + background + ';');\n    globalStyleDefinitions.push('font-family: ' + this._terminal.options.fontFamily + ';');\n    globalStyleDefinitions.push('font-size: ' + this._terminal.options.fontSize + 'px;');\n    this._htmlContent += '<div style=\\'' + globalStyleDefinitions.join(' ') + '\\'>';\n  }\n\n  protected _afterSerialize(): void {\n    this._htmlContent += '</div>';\n    this._htmlContent += '</pre><!--EndFragment--></body></html>';\n  }\n\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    this._htmlContent += '<div><span>' + this._currentRow + '</span></div>';\n    this._currentRow = '';\n  }\n\n  private _getHexColor(cell: IBufferCell, isFg: boolean): string | undefined {\n    const color = isFg ? cell.getFgColor() : cell.getBgColor();\n    if (isFg ? cell.isFgRGB() : cell.isBgRGB()) {\n      const rgb = [\n        (color >> 16) & 255,\n        (color >>  8) & 255,\n        (color      ) & 255\n      ];\n      return rgb.map(x => this._padStart(x.toString(16), 2, '0')).join('');\n    }\n    if (isFg ? cell.isFgPalette() : cell.isBgPalette()) {\n      return this._colors.ansi[color].css;\n    }\n    return undefined;\n  }\n\n  private _diffStyle(cell: IBufferCell, oldCell: IBufferCell): string[] | undefined {\n    const content: string[] = [];\n\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      const fgHexColor = this._getHexColor(cell, true);\n      if (fgHexColor) {\n        content.push('color: ' + fgHexColor + ';');\n      }\n\n      const bgHexColor = this._getHexColor(cell, false);\n      if (bgHexColor) {\n        content.push('background-color: ' + bgHexColor + ';');\n      }\n\n      if (cell.isInverse()) { content.push('color: #000000; background-color: #BFBFBF;'); }\n      if (cell.isBold()) { content.push('font-weight: bold;'); }\n      if (cell.isUnderline()) { content.push('text-decoration: underline;'); }\n      if (cell.isBlink()) { content.push('text-decoration: blink;'); }\n      if (cell.isInvisible()) { content.push('visibility: hidden;'); }\n      if (cell.isItalic()) { content.push('font-style: italic;'); }\n      if (cell.isDim()) { content.push('opacity: 0.5;'); }\n      if (cell.isStrikethrough()) { content.push('text-decoration: line-through;'); }\n\n      return content;\n    }\n\n    return undefined;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const styleDefinitions = this._diffStyle(cell, oldCell);\n\n    // handles style change\n    if (styleDefinitions) {\n      this._currentRow += styleDefinitions.length === 0 ?\n        '</span><span>' :\n        '</span><span style=\\'' + styleDefinitions.join(' ') + '\\'>';\n    }\n\n    // handles actual content\n    if (isEmptyCell) {\n      this._currentRow += ' ';\n    } else {\n      this._currentRow += cell.getChars();\n    }\n  }\n\n  protected _serializeString(): string {\n    return this._htmlContent;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","this","constrain","value","low","high","Math","max","min","BaseSerializeHandler","constructor","_buffer","serialize","range","cell1","getNullCell","cell2","oldCell","startRow","start","x","endRow","end","startColumn","y","endColumn","_beforeSerialize","row","line","getLine","startLineColumn","endLineColumn","length","col","c","getCell","_nextCell","console","warn","_rowEnd","_afterSerialize","_serializeString","cell","isLastRow","rows","equalFg","getFgColorMode","getFgColor","equalBg","getBgColorMode","getBgColor","equalFlags","isInverse","isBold","isUnderline","isBlink","isInvisible","isItalic","isDim","isStrikethrough","StringSerializeHandler","buffer","_terminal","super","_rowIndex","_allRows","Array","_allRowSeparators","_currentRow","_nullCellCount","_cursorStyle","_cursorStyleRow","_cursorStyleCol","_backgroundCell","_firstRow","_lastCursorRow","_lastCursorCol","_lastContentCursorRow","_lastContentCursorCol","_thisRowLastChar","_thisRowLastSecondChar","_nextRowFirstChar","rowSeparator","currentLine","nextLine","isWrapped","thisRowLastChar","thisRowLastSecondChar","nextRowFirstChar","isNextRowFirstCharDoubleWidth","getWidth","isValid","getChars","repeat","_diffStyle","sgrSeq","fgChanged","bgChanged","flagsChanged","isAttributeDefault","push","color","isFgRGB","isFgPalette","isBgRGB","isBgPalette","isEmptyCell","join","undefined","rowEnd","content","i","realCursorRow","baseY","cursorY","realCursorCol","cursorX","offset","moveRight","curAttrData","_core","_inputHandler","_curAttrData","activate","terminal","_serializeBuffer","scrollback","maxRows","handler","correctRows","cols","_serializeBufferAsHTML","options","active","HTMLSerializeHandler","onlySelection","selection","getSelectionPosition","_serializeModes","modes","applicationCursorKeysMode","applicationKeypadMode","bracketedPasteMode","insertMode","originMode","reverseWraparoundMode","sendFocusMode","wraparoundMode","mouseTrackingMode","Error","normal","excludeAltBuffer","type","alternate","excludeModes","serializeAsHTML","dispose","_options","_htmlContent","_colors","_themeService","colors","_padStart","target","targetLength","padString","slice","foreground","background","includeGlobalBackground","theme","globalStyleDefinitions","fontFamily","fontSize","_getHexColor","isFg","map","toString","ansi","css","fgHexColor","bgHexColor","styleDefinitions"],"sourceRoot":""}
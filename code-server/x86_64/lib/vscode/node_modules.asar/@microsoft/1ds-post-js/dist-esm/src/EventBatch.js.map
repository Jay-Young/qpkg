{"version":3,"file":"EventBatch.js.map","sources":["EventBatch.js"],"sourcesContent":["import { isNullOrUndefined, isValueAssigned } from \"@microsoft/1ds-core-js\";\r\nimport { strMsfpc } from \"./Constants\";\r\nfunction _getEventMsfpc(theEvent) {\r\n    var intWeb = ((theEvent.ext || {})[\"intweb\"]);\r\n    if (intWeb && isValueAssigned(intWeb[strMsfpc])) {\r\n        return intWeb[strMsfpc];\r\n    }\r\n    return null;\r\n}\r\nfunction _getMsfpc(theEvents) {\r\n    var msfpc = null;\r\n    for (var lp = 0; msfpc === null && lp < theEvents.length; lp++) {\r\n        msfpc = _getEventMsfpc(theEvents[lp]);\r\n    }\r\n    return msfpc;\r\n}\r\n/**\r\n* This class defines a \"batch\" events related to a specific iKey, it is used by the PostChannel and HttpManager\r\n* to collect and transfer ownership of events without duplicating them in-memory. This reduces the previous\r\n* array duplication and shared ownership issues that occurred due to race conditions caused by the async nature\r\n* of sending requests.\r\n*/\r\nvar EventBatch = /** @class */ (function () {\r\n    /**\r\n     * Private constructor so that caller is forced to use the static create method.\r\n     * @param iKey - The iKey to associate with the events (not validated)\r\n     * @param addEvents - The optional collection of events to assign to this batch - defaults to an empty array.\r\n     */\r\n    function EventBatch(iKey, addEvents) {\r\n        var events = addEvents ? [].concat(addEvents) : [];\r\n        var _self = this;\r\n        var _msfpc = _getMsfpc(events);\r\n        _self.iKey = function () {\r\n            return iKey;\r\n        };\r\n        _self.Msfpc = function () {\r\n            // return the cached value unless it's undefined -- used to avoid cpu\r\n            return _msfpc || \"\";\r\n        };\r\n        _self.count = function () {\r\n            return events.length;\r\n        };\r\n        _self.events = function () {\r\n            return events;\r\n        };\r\n        _self.addEvent = function (theEvent) {\r\n            if (theEvent) {\r\n                events.push(theEvent);\r\n                if (!_msfpc) {\r\n                    // Not found so try and find one\r\n                    _msfpc = _getEventMsfpc(theEvent);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        _self.split = function (fromEvent, numEvents) {\r\n            // Create a new batch with the same iKey\r\n            var theEvents;\r\n            if (fromEvent < events.length) {\r\n                var cnt = events.length - fromEvent;\r\n                if (!isNullOrUndefined(numEvents)) {\r\n                    cnt = numEvents < cnt ? numEvents : cnt;\r\n                }\r\n                theEvents = events.splice(fromEvent, cnt);\r\n                // reset the fetched msfpc value\r\n                _msfpc = _getMsfpc(events);\r\n            }\r\n            return new EventBatch(iKey, theEvents);\r\n        };\r\n    }\r\n    /**\r\n     * Creates a new Event Batch object\r\n     * @param iKey The iKey associated with this batch of events\r\n     */\r\n    EventBatch.create = function (iKey, theEvents) {\r\n        return new EventBatch(iKey, theEvents);\r\n    };\r\n    return EventBatch;\r\n}());\r\nexport { EventBatch };\r\n//# sourceMappingURL=EventBatch.js.map"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}